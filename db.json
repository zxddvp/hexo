{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":1,"renderable":1},{"_id":"source/assets/img/16_small.jpg","path":"assets/img/16_small.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/assets/img/alipay.png","path":"assets/img/alipay.png","modified":1,"renderable":0},{"_id":"source/assets/img/weixin.png","path":"assets/img/weixin.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"084c2eeeb45ce64889716986b653fc18e2dcb812","modified":1498041002000},{"_id":"source/CNAME","hash":"45388b3cffa9a4a0cd8ead7d2d3b873b183262a8","modified":1497857788000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1497943151000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1497943151000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1497943151000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1497943151000},{"_id":"themes/yilia/.DS_Store","hash":"baa45013493d4c6a3bb038081d54be7073393d69","modified":1497944691000},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1497943151000},{"_id":"themes/yilia/_config.yml","hash":"60d6d4eea5ac46df73319b0a52098106a6fd1764","modified":1498036016000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1497943151000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1497943151000},{"_id":"source/_posts/JAVA高级面试题.md","hash":"9e9529a511bef525a1c3cc7ca07cf5f123b0fce7","modified":1498121544000},{"_id":"source/_posts/20170619第一次使用HEXO.md","hash":"b17b10c57c6da45e7ab91249478875ad1f35c051","modified":1497948381000},{"_id":"source/_posts/【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）.md","hash":"052279f986dce7f1a8c2cbc63f5df0e9d94c5f82","modified":1498035795000},{"_id":"source/_posts/笔试题20170620.md","hash":"ae52b3f7c82ef9a86b43871ce3dfdd82a2414190","modified":1497954121000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1497943151000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1497943151000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1497943151000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1497943151000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1497943151000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1497943151000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1497943151000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1497943151000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1497943151000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1497943151000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1497943151000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1497943151000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1497943151000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1497943151000},{"_id":"themes/yilia/source/.DS_Store","hash":"532d37d33c7f6b229cfb41676792b54f25d7209c","modified":1497944655000},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1497943151000},{"_id":"themes/yilia/source/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1497943151000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1497943151000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1497943151000},{"_id":"themes/yilia/source/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1497943151000},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1497943151000},{"_id":"source/assets/img/16_small.jpg","hash":"b9d9973b82f4995b45f62d759b3c33599686d697","modified":1497948125000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"7547bc40b533d9db62f430c43dc0e595c9caa5b6","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1497943151000},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1497943151000},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1497943151000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1497943151000},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1497943151000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1497943151000},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1497943151000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1497943151000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1497943151000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1497943151000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1497943151000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1497943151000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1497943151000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1497943151000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1497943151000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1497943151000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"e6e83d4863afcc589d4dd2f327e9f396f7d7b343","modified":1497943151000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1497943151000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1497943151000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1497943151000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1497943151000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"3f5808a49a7365e3f813f78ba96b692f7ca27886","modified":1497943151000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1497943151000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1497943151000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"ac8c3312182519e33d0f729d157deb36e5f42894","modified":1497943151000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1497943151000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"a40400734c6509b9ac6e393a6681ccd8bafed5eb","modified":1497943151000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1497943151000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1497943151000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1497943151000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1497943151000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"b5324302815491d0a5e63142f1ead2048ad3f72f","modified":1497943151000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1497943151000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1497943151000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"17a97f7c38f5dfacc3eadf354b5826d77f1c2bdb","modified":1497943151000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1497943151000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1497943151000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1497943151000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1497943151000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1497943151000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"9591a0f61236a56b2a15a541f572bcfd93823a0f","modified":1497943151000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1497943151000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1497943151000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1497943151000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1497943151000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1497943151000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1497943151000},{"_id":"source/assets/img/alipay.png","hash":"624a39890f768fa44eb77cae729bfd60a4309415","modified":1497948047000},{"_id":"source/assets/img/weixin.png","hash":"09daf087043eaacf11f56cc5b4f1b2ae2b0af8c6","modified":1497948052000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"6160c13783a7f31dab4fdcc6b752b3a368586d67","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"9f9fa4f8b0de5f87a9494fd0cb5064502a5d5ef5","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1497943151000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1497943151000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1497943151000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1497943151000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1497943151000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1497943151000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1497943151000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1497943151000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1497943151000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1497943151000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1497943151000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1497943151000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1497943151000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1497943151000},{"_id":"public/atom.xml","hash":"7cf61f98db4d20e97e34f3f143f451cbe34ea746","modified":1498121603547},{"_id":"public/content.json","hash":"95005d774bd251682299bcfd4dd52e9df9efa707","modified":1498121603671},{"_id":"public/sitemap.xml","hash":"eb2ebe228348f657a5eac08fdd5970147fef31ba","modified":1498121603682},{"_id":"public/2017/06/20/笔试题20170620/index.html","hash":"6766b9a9678ac8f1a1c97bb5a97527a718d53e99","modified":1498121603693},{"_id":"public/2017/06/19/20170619第一次使用HEXO/index.html","hash":"d793b29a26a29f2125ef52ad16ab2900f092f737","modified":1498121603706},{"_id":"public/archives/index.html","hash":"9face32c0a0a4a1c07b72e0289ebe5bb8cd8322a","modified":1498121603708},{"_id":"public/archives/2017/index.html","hash":"955e35d47f2860e15bd3e9d3bc44c884ae8435ba","modified":1498121603708},{"_id":"public/index.html","hash":"bd9b3b5c5f07c6ee3d4020695b38f57ff2aa8326","modified":1498121603708},{"_id":"public/archives/2017/06/index.html","hash":"e6f374ea71c878818ad191afa8fc1e150d0932ad","modified":1498121603709},{"_id":"public/2017/06/21/【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）/index.html","hash":"357e099f1be9ff3ed9927798c89f997d01eba2a3","modified":1498121603709},{"_id":"public/tags/笔试题/index.html","hash":"a71632f50946cea28419f99dd382ee8f906c809e","modified":1498121603709},{"_id":"public/tags/classloader/index.html","hash":"c4fa48590b55d9b54ecfd49ab46fb613d2dd602e","modified":1498121603709},{"_id":"public/2017/06/22/JAVA高级面试题/index.html","hash":"982e36630e7e4e9dc6455f2a8ae78dea0419e119","modified":1498121603715},{"_id":"public/CNAME","hash":"45388b3cffa9a4a0cd8ead7d2d3b873b183262a8","modified":1498121603715},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1498121603715},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1498121603715},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1498121603715},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"772383b62548e2a4fa560d589e05929b9f6f7f7b","modified":1498121603715},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1498121603715},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1498121603715},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1498121603718},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1498121603719},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1498121603721},{"_id":"public/assets/img/16_small.jpg","hash":"b9d9973b82f4995b45f62d759b3c33599686d697","modified":1498121603721},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1498121603723},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1498121603723},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1498121603723},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1498121603723},{"_id":"public/assets/img/alipay.png","hash":"624a39890f768fa44eb77cae729bfd60a4309415","modified":1498121603723},{"_id":"public/assets/img/weixin.png","hash":"09daf087043eaacf11f56cc5b4f1b2ae2b0af8c6","modified":1498121603724}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"JAVA高级面试题1","date":"2017-06-22T07:38:45.000Z","_content":"==【注意，答案都是来自网络，自辨真假】==\n\n1、关于spring的aop的实现方法。\n\n\t1.通知(Advice):\n\t通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。\n\t2.连接点(Joinpoint):\n\t程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。\n\t3.切入点(Pointcut)\n\t通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，spring中允许我们方便的用正则表达式来指定\n\t4.切面(Aspect)\n\t通知和切入点共同组成了切面：时间、地点和要发生的“故事”\n\t5.引入(Introduction)\n\t引入允许我们向现有的类添加新的方法和属性(Spring提供了一个方法注入的功能）\n\t6.目标(Target)\n\t即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）\n\t7.代理(proxy)\n\t应用通知的对象，详细内容参见设计模式里面的代理模式\n\t8.织入(Weaving)\n\t把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:\n\t(1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器\n\t(2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码\n\t(3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术\n\tSpring提供了4种实现AOP的方式：\n\t1.经典的基于代理的AOP\n\t2.@AspectJ注解驱动的切面\n\t3.纯POJO切面\n\t4.注入式AspectJ切面\n\t\n---\n2、关于分布式消息队列，分布式缓存\n\n分布式消息队列：\n\n\t一、消息队列概述\n\n\t消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n\t目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。\n\n\t二、消息队列应用场景\n\n\t以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。\n\n\t2.1异步处理\n\n\t场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。\n\n\t（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。\n\t\n\t（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。\n\t\n\t2.2应用解耦\n\n\t场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。\n\t\n\t传统模式的缺点：\n\n\t1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；\n\n\t2）  订单系统与库存系统耦合；\n\n\t如何解决以上问题呢？引入应用消息队列后的方案\n\t\n\t订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。\n\t\n\t库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。\n\t\n\t假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。\n\t\n\t2.3流量削锋\n\n\t流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。\n\n\t应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\t\n\t2.4日志处理\n\n\t日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题\n\t\n\t日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；\n\tKafka消息队列，负责日志数据的接收，存储和转发；\n\t日志处理应用：订阅并消费kafka队列中的日志数据；\n\t\n\t(1)Kafka：接收用户日志的消息队列。\n\n\t(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n\n\t(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n\n\t(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n\t\n\t2.5消息通讯\n\n\t消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n\n\n\n\n分布式缓存：\n\t\n\t1.1 分布式缓存的特性\n\n\t分布式缓存具有如下特性: \n\n\t1) 高性能:当传统数据库面临大规模数据访问时,磁盘I/O 往往成为性能瓶颈,从而导致过高的响应延迟.分布式缓存将高速内存作为数据对象的存储介质,数据以key/value 形式存储,理想情况下可以获得DRAM 级的读写性能; \n\n\t2) 动态扩展性:支持弹性扩展,通过动态增加或减少节点应对变化的数据访问负载,提供可预测的性能与扩展性;同时,最大限度地提高资源利用率; \n\n\t3) 高可用性:可用性包含数据可用性与服务可用性两方面.基于冗余机制实现高可用性,无单点失效(single point of failure),支持故障的自动发现,透明地实施故障切换,不会因服务器故障而导致缓存服务中断或数据丢失.动态扩展时自动均衡数据分区,同时保障缓存服务持续可用; \n\n\t4) 易用性:提供单一的数据与管理视图;API 接口简单,且与拓扑结构无关;动态扩展或失效恢复时无需人工配置;自动选取备份节点;多数缓存系统提供了图形化的管理控制台,便于统一维护; \n\n\t5) 分布式代码执行(distributed code execution):将任务代码转移到各数据节点并行执行,客户端聚合返回结果,从而有效避免了缓存数据的移动与传输.最新的Java 数据网格规范JSR-347中加入了分布式代码执行与Map/reduce 的API 支持,各主流分布式缓存产品,如IBM WebSphere eXtreme Scale,VMware GemFire,GigaSpaces XAP 和Red Hat Infinispan 等也都支持这一新的编程模型. \n\n\t1.2 典型应用场景 \n\n\t分布式缓存的典型应用场景可分为以下几类: \n\n\t1) 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等; \n\n\t2) 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问; \n\n\t3) 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群; \n\n\t4) 并行处理.通常涉及大量中间计算结果需要共享; \n\n\t5) 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求; \n\n\t6) 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域.\n\n\n---\n\n3、关于rpc\n\n\tRPC(Remote Procedure Call，远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。\n\n\t越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。\n\n\tSocket和RPC的区别再次说明了这点。在传统的编程概念中，过程是由程序员在本地编译完成，并只能局限在本地运行的一段代码，也即其主程序和过程之间的运行关系是本地调用关系。因此这种结构在网络日益发展的今天已无法适应实际需求。众所周知，传统过程调用模式无法充分利用网络上其他主机的资源(如CPU、Memory等)，也无法提高代码在实体间的共享程度，使得主机资源大量浪费。\n\n\t通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接得多台工作站)，这样可以简便地将你的应用分布在多台工作站上，应用程序就像运行在一个多处理器的计算机上一样。你可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。\n\n\tRPC作为普遍的C/S开发方法，开发效率高效，可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力对付实现过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。\n\n\tRPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。\n\n\tRPC的结构原理及其调用机制\n\n\t如前所述，RPC其实也是种C/S的编程模式，有点类似C/S Socket 编程模式，但要比它更高一层。\n\n\t当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。\n\n\t当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。\n\n\t在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。\n\n\t程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。\n\n\t基于RPC的应用系统开发\n\n\t一般而言在开发RPC时，我们通常分为三个步骤：\n\n\tA、定义说明客户/服务器的通信协议:这里所说的通信协议是指定义服务过程的名称、调用参数的数据类型和返回参数的数据类型，还包括底层传输类型(可以是UDP或TCP)，当然也可以由RPC底层函数自动选择连接类型建立TI-RPC。最简单的协议生成的方法是采用协议编译工具，常用的有Rpcgen，我会在后面实例中详细描述其使用方法。\n\n\tB、开发客户端程序。\n\n\tC、开发服务器端程序。\n\n\t开发客户端和服务器端的程序时，RPC提供了我们不同层次的开发例程调用接口。不同层次的接口提供了对RPC不同程度控制。\n\t\n---\n\n4、关于hashmap源码实现\n\nHashMap实现原理及源码分析\n\n　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。\n\n目录\n\n　　一、什么是哈希表\n\n　　二、HashMap实现原理\n\n　　三、为何HashMap的数组长度一定是2的次幂？\n\n　　四、重写equals方法需同时重写hashCode方法\n\n　　五、总结\n\n一、什么是哈希表\n\n　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能\n\n　　数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)\n\n　　线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)\n\n　　二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。\n\n　　哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。\n\n　　我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。\n\n　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。\n\n　　　　　　　　存储位置 = f(关键字)\n\n　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：\n\n　　\n\n　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。\n\n　　哈希冲突\n\n　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，\n\n二、HashMap实现原理\n\n　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n Entry是HashMap中的一个静态内部类。代码如下\n\n\n    static class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;//存储指向下一个Entry的引用，单链表结构\n        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算\n\n        /**\n         * Creates new entry.\n         */\n        Entry(int h, K k, V v, Entry<K,V> n) {\n            value = v;\n            next = n;\n            key = k;\n            hash = h;\n        } \n\n 所以，HashMap的整体结构如下\n\n　　\n\n　　简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。\n\n其他几个重要字段\n\n\n\t//实际存储的key-value键值对的个数\n\ttransient int size;\n\t//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到\n\tint threshold;\n\t//负载因子，代表了table的填充度有多少，默认是0.75\n\tfinal float loadFactor;\n\t//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException\n\ttransient int modCount;\n\nHashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值\n\ninitialCapacity默认为16，loadFactory默认为0.75\n\n我们看下其中一个\n\n\n\tpublic HashMap(int initialCapacity, float loadFactor) {\n\t//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1<<30(230)\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n\n        this.loadFactor = loadFactor;\n        threshold = initialCapacity;\n        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现\n    }\n\n　　从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组\n\n　　OK,接下来我们来看看put操作的实现吧\n\n \n    public V put(K key, V value) {\n        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1<<4(24=16)\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n       //如果key为null，存储位置为table[0]或table[0]的冲突链上\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀\n        int i = indexFor(hash, table.length);//获取在table中的实际位置\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败\n        addEntry(hash, key, value, i);//新增一个entry\n        return null;\n    }    \n\n 先来看看inflateTable这个方法\n\n\n\tprivate void inflateTable(int toSize) {\n        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂\n        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1\n        table = new Entry[capacity];\n        initHashSeedAsNeeded(capacity);\n    }\n\n\n　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.\n\n\tprivate static int roundUpToPowerOf2(int number) {\n        // assert number >= 0 : \"number must be non-negative\";\n        return number >= MAXIMUM_CAPACITY\n                ? MAXIMUM_CAPACITY\n                : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n    }\n\nroundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.\n\nhash函数\n\n\t//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀\n\tfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n\n以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置\n\n\t/**\n     * 返回数组下标\n     */\n    static int indexFor(int h, int length) {\n        return h & (length-1);\n    }\n\n\nh&（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为\n\n        1  0  0  1  0\n    &   0  1  1  1  1\n    __________________\n        0  0  0  1  0    = 2\n　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）\n\n所以最终存储位置的确定流程是这样的：\n\n\n\n再来看看addEntry的实现：\n\n\n\tvoid addEntry(int hash, K key, V value, int bucketIndex) {\n        if ((size >= threshold) && (null != table[bucketIndex])) {\n            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容\n            hash = (null != key) ? hash(key) : 0;\n            bucketIndex = indexFor(hash, table.length);\n        }\n\n        createEntry(hash, key, value, bucketIndex);\n    }\n\n\n　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。\n\n三、为何HashMap的数组长度一定是2的次幂？\n\n我们来继续看上面提到的resize方法\n\n\tvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n如果数组进行扩容，数组长度发生变化，而存储位置 index = h&(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法\n\n\tvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n    \n\n　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。\n\n　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。\n\n　　\n\n 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：\n\n\n\n　　我们看到，上面的&运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。\n\n\n\n　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。\n\nget方法\n\n\tpublic V get(Object key) {\n\t\t//如果key为null,则直接去table[0]处去检索即可。\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n        return null == entry ? null : entry.getValue();\n    }\n    \n\nget方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法\n\n\tfinal Entry<K,V> getEntry(Object key) {\n            \n        if (size == 0) {\n            return null;\n        }\n        //通过key的hashcode值计算hash值\n        int hash = (key == null) ? 0 : hash(key);\n        //indexFor (hash&length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n            Object k;\n            if (e.hash == hash && \n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }    \n\n\n　　可以看出，get方法的实现相对简单，key(hashcode)-->hash-->indexFor-->最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。\n\n四、重写equals方法需同时重写hashCode方法\n\n　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题\n\n\t/**\n \t* Created by chengxiao on 2016/11/15.\n \t*/\n\tpublic class MyTest {\n    private static class Person{\n        int idCard;\n        String name;\n\n        public Person(int idCard, String name) {\n            this.idCard = idCard;\n            this.name = name;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()){\n                return false;\n            }\n            Person person = (Person) o;\n            //两个对象是否等值，通过idCard来确定\n            return this.idCard == person.idCard;\n        }\n\n    }\n    public static void main(String []args){\n        HashMap<Person,String> map = new HashMap<Person, String>();\n        Person person = new Person(1234,\"乔峰\");\n        //put到hashmap中去\n        map.put(person,\"天龙八部\");\n        //get取出，从逻辑上讲应该能输出“天龙八部”\n        System.out.println(\"结果:\"+map.get(new Person(1234,\"萧峰\")));\n    }\n\t}\n\n\n实际输出结果：\n\n结果：null\n\n　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)-->hash-->indexFor-->最终索引位置 ，而通过key取出value的时候 key(hashcode1)-->hash-->indexFor-->最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）\n\n　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。\n\n五、总结\n\n　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。\n\n\n\n","source":"_posts/JAVA高级面试题.md","raw":"---\ntitle: JAVA高级面试题1\ndate: 2017-06-22 15:38:45\ntags:\n---\n==【注意，答案都是来自网络，自辨真假】==\n\n1、关于spring的aop的实现方法。\n\n\t1.通知(Advice):\n\t通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。\n\t2.连接点(Joinpoint):\n\t程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。\n\t3.切入点(Pointcut)\n\t通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，spring中允许我们方便的用正则表达式来指定\n\t4.切面(Aspect)\n\t通知和切入点共同组成了切面：时间、地点和要发生的“故事”\n\t5.引入(Introduction)\n\t引入允许我们向现有的类添加新的方法和属性(Spring提供了一个方法注入的功能）\n\t6.目标(Target)\n\t即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）\n\t7.代理(proxy)\n\t应用通知的对象，详细内容参见设计模式里面的代理模式\n\t8.织入(Weaving)\n\t把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:\n\t(1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器\n\t(2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码\n\t(3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术\n\tSpring提供了4种实现AOP的方式：\n\t1.经典的基于代理的AOP\n\t2.@AspectJ注解驱动的切面\n\t3.纯POJO切面\n\t4.注入式AspectJ切面\n\t\n---\n2、关于分布式消息队列，分布式缓存\n\n分布式消息队列：\n\n\t一、消息队列概述\n\n\t消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n\t目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。\n\n\t二、消息队列应用场景\n\n\t以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。\n\n\t2.1异步处理\n\n\t场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。\n\n\t（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。\n\t\n\t（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。\n\t\n\t2.2应用解耦\n\n\t场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。\n\t\n\t传统模式的缺点：\n\n\t1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；\n\n\t2）  订单系统与库存系统耦合；\n\n\t如何解决以上问题呢？引入应用消息队列后的方案\n\t\n\t订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。\n\t\n\t库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。\n\t\n\t假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。\n\t\n\t2.3流量削锋\n\n\t流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。\n\n\t应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\t\n\t2.4日志处理\n\n\t日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题\n\t\n\t日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；\n\tKafka消息队列，负责日志数据的接收，存储和转发；\n\t日志处理应用：订阅并消费kafka队列中的日志数据；\n\t\n\t(1)Kafka：接收用户日志的消息队列。\n\n\t(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n\n\t(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n\n\t(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n\t\n\t2.5消息通讯\n\n\t消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n\n\n\n\n分布式缓存：\n\t\n\t1.1 分布式缓存的特性\n\n\t分布式缓存具有如下特性: \n\n\t1) 高性能:当传统数据库面临大规模数据访问时,磁盘I/O 往往成为性能瓶颈,从而导致过高的响应延迟.分布式缓存将高速内存作为数据对象的存储介质,数据以key/value 形式存储,理想情况下可以获得DRAM 级的读写性能; \n\n\t2) 动态扩展性:支持弹性扩展,通过动态增加或减少节点应对变化的数据访问负载,提供可预测的性能与扩展性;同时,最大限度地提高资源利用率; \n\n\t3) 高可用性:可用性包含数据可用性与服务可用性两方面.基于冗余机制实现高可用性,无单点失效(single point of failure),支持故障的自动发现,透明地实施故障切换,不会因服务器故障而导致缓存服务中断或数据丢失.动态扩展时自动均衡数据分区,同时保障缓存服务持续可用; \n\n\t4) 易用性:提供单一的数据与管理视图;API 接口简单,且与拓扑结构无关;动态扩展或失效恢复时无需人工配置;自动选取备份节点;多数缓存系统提供了图形化的管理控制台,便于统一维护; \n\n\t5) 分布式代码执行(distributed code execution):将任务代码转移到各数据节点并行执行,客户端聚合返回结果,从而有效避免了缓存数据的移动与传输.最新的Java 数据网格规范JSR-347中加入了分布式代码执行与Map/reduce 的API 支持,各主流分布式缓存产品,如IBM WebSphere eXtreme Scale,VMware GemFire,GigaSpaces XAP 和Red Hat Infinispan 等也都支持这一新的编程模型. \n\n\t1.2 典型应用场景 \n\n\t分布式缓存的典型应用场景可分为以下几类: \n\n\t1) 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等; \n\n\t2) 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问; \n\n\t3) 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群; \n\n\t4) 并行处理.通常涉及大量中间计算结果需要共享; \n\n\t5) 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求; \n\n\t6) 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域.\n\n\n---\n\n3、关于rpc\n\n\tRPC(Remote Procedure Call，远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。\n\n\t越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。\n\n\tSocket和RPC的区别再次说明了这点。在传统的编程概念中，过程是由程序员在本地编译完成，并只能局限在本地运行的一段代码，也即其主程序和过程之间的运行关系是本地调用关系。因此这种结构在网络日益发展的今天已无法适应实际需求。众所周知，传统过程调用模式无法充分利用网络上其他主机的资源(如CPU、Memory等)，也无法提高代码在实体间的共享程度，使得主机资源大量浪费。\n\n\t通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接得多台工作站)，这样可以简便地将你的应用分布在多台工作站上，应用程序就像运行在一个多处理器的计算机上一样。你可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。\n\n\tRPC作为普遍的C/S开发方法，开发效率高效，可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力对付实现过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。\n\n\tRPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。\n\n\tRPC的结构原理及其调用机制\n\n\t如前所述，RPC其实也是种C/S的编程模式，有点类似C/S Socket 编程模式，但要比它更高一层。\n\n\t当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。\n\n\t当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。\n\n\t在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。\n\n\t程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。\n\n\t基于RPC的应用系统开发\n\n\t一般而言在开发RPC时，我们通常分为三个步骤：\n\n\tA、定义说明客户/服务器的通信协议:这里所说的通信协议是指定义服务过程的名称、调用参数的数据类型和返回参数的数据类型，还包括底层传输类型(可以是UDP或TCP)，当然也可以由RPC底层函数自动选择连接类型建立TI-RPC。最简单的协议生成的方法是采用协议编译工具，常用的有Rpcgen，我会在后面实例中详细描述其使用方法。\n\n\tB、开发客户端程序。\n\n\tC、开发服务器端程序。\n\n\t开发客户端和服务器端的程序时，RPC提供了我们不同层次的开发例程调用接口。不同层次的接口提供了对RPC不同程度控制。\n\t\n---\n\n4、关于hashmap源码实现\n\nHashMap实现原理及源码分析\n\n　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。\n\n目录\n\n　　一、什么是哈希表\n\n　　二、HashMap实现原理\n\n　　三、为何HashMap的数组长度一定是2的次幂？\n\n　　四、重写equals方法需同时重写hashCode方法\n\n　　五、总结\n\n一、什么是哈希表\n\n　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能\n\n　　数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)\n\n　　线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)\n\n　　二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。\n\n　　哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。\n\n　　我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。\n\n　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。\n\n　　　　　　　　存储位置 = f(关键字)\n\n　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：\n\n　　\n\n　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。\n\n　　哈希冲突\n\n　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，\n\n二、HashMap实现原理\n\n　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。\n\n//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。\ntransient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;\n Entry是HashMap中的一个静态内部类。代码如下\n\n\n    static class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;//存储指向下一个Entry的引用，单链表结构\n        int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算\n\n        /**\n         * Creates new entry.\n         */\n        Entry(int h, K k, V v, Entry<K,V> n) {\n            value = v;\n            next = n;\n            key = k;\n            hash = h;\n        } \n\n 所以，HashMap的整体结构如下\n\n　　\n\n　　简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。\n\n其他几个重要字段\n\n\n\t//实际存储的key-value键值对的个数\n\ttransient int size;\n\t//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到\n\tint threshold;\n\t//负载因子，代表了table的填充度有多少，默认是0.75\n\tfinal float loadFactor;\n\t//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException\n\ttransient int modCount;\n\nHashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值\n\ninitialCapacity默认为16，loadFactory默认为0.75\n\n我们看下其中一个\n\n\n\tpublic HashMap(int initialCapacity, float loadFactor) {\n\t//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1<<30(230)\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                               loadFactor);\n\n        this.loadFactor = loadFactor;\n        threshold = initialCapacity;\n        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现\n    }\n\n　　从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组\n\n　　OK,接下来我们来看看put操作的实现吧\n\n \n    public V put(K key, V value) {\n        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1<<4(24=16)\n        if (table == EMPTY_TABLE) {\n            inflateTable(threshold);\n        }\n       //如果key为null，存储位置为table[0]或table[0]的冲突链上\n        if (key == null)\n            return putForNullKey(value);\n        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀\n        int i = indexFor(hash, table.length);//获取在table中的实际位置\n        for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value\n            Object k;\n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败\n        addEntry(hash, key, value, i);//新增一个entry\n        return null;\n    }    \n\n 先来看看inflateTable这个方法\n\n\n\tprivate void inflateTable(int toSize) {\n        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂\n        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1\n        table = new Entry[capacity];\n        initHashSeedAsNeeded(capacity);\n    }\n\n\n　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.\n\n\tprivate static int roundUpToPowerOf2(int number) {\n        // assert number >= 0 : \"number must be non-negative\";\n        return number >= MAXIMUM_CAPACITY\n                ? MAXIMUM_CAPACITY\n                : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n    }\n\nroundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.\n\nhash函数\n\n\t//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀\n\tfinal int hash(Object k) {\n        int h = hashSeed;\n        if (0 != h && k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n        h ^= k.hashCode();\n\n        h ^= (h >>> 20) ^ (h >>> 12);\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }\n\n以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置\n\n\t/**\n     * 返回数组下标\n     */\n    static int indexFor(int h, int length) {\n        return h & (length-1);\n    }\n\n\nh&（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为\n\n        1  0  0  1  0\n    &   0  1  1  1  1\n    __________________\n        0  0  0  1  0    = 2\n　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）\n\n所以最终存储位置的确定流程是这样的：\n\n\n\n再来看看addEntry的实现：\n\n\n\tvoid addEntry(int hash, K key, V value, int bucketIndex) {\n        if ((size >= threshold) && (null != table[bucketIndex])) {\n            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容\n            hash = (null != key) ? hash(key) : 0;\n            bucketIndex = indexFor(hash, table.length);\n        }\n\n        createEntry(hash, key, value, bucketIndex);\n    }\n\n\n　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。\n\n三、为何HashMap的数组长度一定是2的次幂？\n\n我们来继续看上面提到的resize方法\n\n\tvoid resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n    }\n\n如果数组进行扩容，数组长度发生变化，而存储位置 index = h&(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法\n\n\tvoid transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）\n        for (Entry<K,V> e : table) {\n            while(null != e) {\n                Entry<K,V> next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n    }\n    \n\n　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。\n\n　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。\n\n　　\n\n 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：\n\n\n\n　　我们看到，上面的&运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。\n\n\n\n　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。\n\nget方法\n\n\tpublic V get(Object key) {\n\t\t//如果key为null,则直接去table[0]处去检索即可。\n        if (key == null)\n            return getForNullKey();\n        Entry<K,V> entry = getEntry(key);\n        return null == entry ? null : entry.getValue();\n    }\n    \n\nget方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法\n\n\tfinal Entry<K,V> getEntry(Object key) {\n            \n        if (size == 0) {\n            return null;\n        }\n        //通过key的hashcode值计算hash值\n        int hash = (key == null) ? 0 : hash(key);\n        //indexFor (hash&length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录\n        for (Entry<K,V> e = table[indexFor(hash, table.length)];\n             e != null;\n             e = e.next) {\n            Object k;\n            if (e.hash == hash && \n                ((k = e.key) == key || (key != null && key.equals(k))))\n                return e;\n        }\n        return null;\n    }    \n\n\n　　可以看出，get方法的实现相对简单，key(hashcode)-->hash-->indexFor-->最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。\n\n四、重写equals方法需同时重写hashCode方法\n\n　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题\n\n\t/**\n \t* Created by chengxiao on 2016/11/15.\n \t*/\n\tpublic class MyTest {\n    private static class Person{\n        int idCard;\n        String name;\n\n        public Person(int idCard, String name) {\n            this.idCard = idCard;\n            this.name = name;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()){\n                return false;\n            }\n            Person person = (Person) o;\n            //两个对象是否等值，通过idCard来确定\n            return this.idCard == person.idCard;\n        }\n\n    }\n    public static void main(String []args){\n        HashMap<Person,String> map = new HashMap<Person, String>();\n        Person person = new Person(1234,\"乔峰\");\n        //put到hashmap中去\n        map.put(person,\"天龙八部\");\n        //get取出，从逻辑上讲应该能输出“天龙八部”\n        System.out.println(\"结果:\"+map.get(new Person(1234,\"萧峰\")));\n    }\n\t}\n\n\n实际输出结果：\n\n结果：null\n\n　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)-->hash-->indexFor-->最终索引位置 ，而通过key取出value的时候 key(hashcode1)-->hash-->indexFor-->最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）\n\n　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。\n\n五、总结\n\n　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。\n\n\n\n","slug":"JAVA高级面试题","published":1,"updated":"2017-06-22T08:52:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj486x73v00007k26usx8d9pd","content":"<p>==【注意，答案都是来自网络，自辨真假】==</p>\n<p>1、关于spring的aop的实现方法。</p>\n<pre><code>1.通知(Advice):\n通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。\n2.连接点(Joinpoint):\n程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。\n3.切入点(Pointcut)\n通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，spring中允许我们方便的用正则表达式来指定\n4.切面(Aspect)\n通知和切入点共同组成了切面：时间、地点和要发生的“故事”\n5.引入(Introduction)\n引入允许我们向现有的类添加新的方法和属性(Spring提供了一个方法注入的功能）\n6.目标(Target)\n即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）\n7.代理(proxy)\n应用通知的对象，详细内容参见设计模式里面的代理模式\n8.织入(Weaving)\n把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:\n(1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器\n(2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码\n(3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术\nSpring提供了4种实现AOP的方式：\n1.经典的基于代理的AOP\n2.@AspectJ注解驱动的切面\n3.纯POJO切面\n4.注入式AspectJ切面\n</code></pre><hr>\n<p>2、关于分布式消息队列，分布式缓存</p>\n<p>分布式消息队列：</p>\n<pre><code>一、消息队列概述\n\n消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。\n\n二、消息队列应用场景\n\n以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。\n\n2.1异步处理\n\n场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。\n\n（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。\n\n（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。\n\n2.2应用解耦\n\n场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。\n\n传统模式的缺点：\n\n1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；\n\n2）  订单系统与库存系统耦合；\n\n如何解决以上问题呢？引入应用消息队列后的方案\n\n订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。\n\n库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。\n\n假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。\n\n2.3流量削锋\n\n流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。\n\n应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\n2.4日志处理\n\n日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题\n\n日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；\nKafka消息队列，负责日志数据的接收，存储和转发；\n日志处理应用：订阅并消费kafka队列中的日志数据；\n\n(1)Kafka：接收用户日志的消息队列。\n\n(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n\n(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n\n(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n\n2.5消息通讯\n\n消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n</code></pre><p>分布式缓存：</p>\n<pre><code>1.1 分布式缓存的特性\n\n分布式缓存具有如下特性: \n\n1) 高性能:当传统数据库面临大规模数据访问时,磁盘I/O 往往成为性能瓶颈,从而导致过高的响应延迟.分布式缓存将高速内存作为数据对象的存储介质,数据以key/value 形式存储,理想情况下可以获得DRAM 级的读写性能; \n\n2) 动态扩展性:支持弹性扩展,通过动态增加或减少节点应对变化的数据访问负载,提供可预测的性能与扩展性;同时,最大限度地提高资源利用率; \n\n3) 高可用性:可用性包含数据可用性与服务可用性两方面.基于冗余机制实现高可用性,无单点失效(single point of failure),支持故障的自动发现,透明地实施故障切换,不会因服务器故障而导致缓存服务中断或数据丢失.动态扩展时自动均衡数据分区,同时保障缓存服务持续可用; \n\n4) 易用性:提供单一的数据与管理视图;API 接口简单,且与拓扑结构无关;动态扩展或失效恢复时无需人工配置;自动选取备份节点;多数缓存系统提供了图形化的管理控制台,便于统一维护; \n\n5) 分布式代码执行(distributed code execution):将任务代码转移到各数据节点并行执行,客户端聚合返回结果,从而有效避免了缓存数据的移动与传输.最新的Java 数据网格规范JSR-347中加入了分布式代码执行与Map/reduce 的API 支持,各主流分布式缓存产品,如IBM WebSphere eXtreme Scale,VMware GemFire,GigaSpaces XAP 和Red Hat Infinispan 等也都支持这一新的编程模型. \n\n1.2 典型应用场景 \n\n分布式缓存的典型应用场景可分为以下几类: \n\n1) 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等; \n\n2) 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问; \n\n3) 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群; \n\n4) 并行处理.通常涉及大量中间计算结果需要共享; \n\n5) 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求; \n\n6) 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域.\n</code></pre><hr>\n<p>3、关于rpc</p>\n<pre><code>RPC(Remote Procedure Call，远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。\n\n越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。\n\nSocket和RPC的区别再次说明了这点。在传统的编程概念中，过程是由程序员在本地编译完成，并只能局限在本地运行的一段代码，也即其主程序和过程之间的运行关系是本地调用关系。因此这种结构在网络日益发展的今天已无法适应实际需求。众所周知，传统过程调用模式无法充分利用网络上其他主机的资源(如CPU、Memory等)，也无法提高代码在实体间的共享程度，使得主机资源大量浪费。\n\n通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接得多台工作站)，这样可以简便地将你的应用分布在多台工作站上，应用程序就像运行在一个多处理器的计算机上一样。你可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。\n\nRPC作为普遍的C/S开发方法，开发效率高效，可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力对付实现过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。\n\nRPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。\n\nRPC的结构原理及其调用机制\n\n如前所述，RPC其实也是种C/S的编程模式，有点类似C/S Socket 编程模式，但要比它更高一层。\n\n当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。\n\n当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。\n\n在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。\n\n程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。\n\n基于RPC的应用系统开发\n\n一般而言在开发RPC时，我们通常分为三个步骤：\n\nA、定义说明客户/服务器的通信协议:这里所说的通信协议是指定义服务过程的名称、调用参数的数据类型和返回参数的数据类型，还包括底层传输类型(可以是UDP或TCP)，当然也可以由RPC底层函数自动选择连接类型建立TI-RPC。最简单的协议生成的方法是采用协议编译工具，常用的有Rpcgen，我会在后面实例中详细描述其使用方法。\n\nB、开发客户端程序。\n\nC、开发服务器端程序。\n\n开发客户端和服务器端的程序时，RPC提供了我们不同层次的开发例程调用接口。不同层次的接口提供了对RPC不同程度控制。\n</code></pre><hr>\n<p>4、关于hashmap源码实现</p>\n<p>HashMap实现原理及源码分析</p>\n<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>\n<p>目录</p>\n<p>　　一、什么是哈希表</p>\n<p>　　二、HashMap实现原理</p>\n<p>　　三、为何HashMap的数组长度一定是2的次幂？</p>\n<p>　　四、重写equals方法需同时重写hashCode方法</p>\n<p>　　五、总结</p>\n<p>一、什么是哈希表</p>\n<p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>\n<p>　　数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>\n<p>　　线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>\n<p>　　二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>\n<p>　　哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>\n<p>　　我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。</p>\n<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>\n<p>　　　　　　　　存储位置 = f(关键字)</p>\n<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>\n<p>　　</p>\n<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>\n<p>　　哈希冲突</p>\n<p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，</p>\n<p>二、HashMap实现原理</p>\n<p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>\n<p>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。<br>transient Entry<k,v>[] table = (Entry<k,v>[]) EMPTY_TABLE;<br> Entry是HashMap中的一个静态内部类。代码如下</k,v></k,v></p>\n<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构\n    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算\n\n    /**\n     * Creates new entry.\n     */\n    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {\n        value = v;\n        next = n;\n        key = k;\n        hash = h;\n    } \n</code></pre><p> 所以，HashMap的整体结构如下</p>\n<p>　　</p>\n<p>　　简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>\n<p>其他几个重要字段</p>\n<pre><code>//实际存储的key-value键值对的个数\ntransient int size;\n//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到\nint threshold;\n//负载因子，代表了table的填充度有多少，默认是0.75\nfinal float loadFactor;\n//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException\ntransient int modCount;\n</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>\n<p>initialCapacity默认为16，loadFactory默认为0.75</p>\n<p>我们看下其中一个</p>\n<pre><code>public HashMap(int initialCapacity, float loadFactor) {\n//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n\n    this.loadFactor = loadFactor;\n    threshold = initialCapacity;\n    init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现\n}\n</code></pre><p>　　从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</p>\n<p>　　OK,接下来我们来看看put操作的实现吧</p>\n<pre><code>public V put(K key, V value) {\n    //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n   //如果key为null，存储位置为table[0]或table[0]的冲突链上\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀\n    int i = indexFor(hash, table.length);//获取在table中的实际位置\n    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {\n    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value\n        Object k;\n        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败\n    addEntry(hash, key, value, i);//新增一个entry\n    return null;\n}    \n</code></pre><p> 先来看看inflateTable这个方法</p>\n<pre><code>private void inflateTable(int toSize) {\n    int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n</code></pre><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>\n<pre><code>private static int roundUpToPowerOf2(int number) {\n    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;\n    return number &gt;= MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n}\n</code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>\n<p>hash函数</p>\n<pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀\nfinal int hash(Object k) {\n    int h = hashSeed;\n    if (0 != h &amp;&amp; k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\n    h ^= k.hashCode();\n\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>\n<pre><code>/**\n * 返回数组下标\n */\nstatic int indexFor(int h, int length) {\n    return h &amp; (length-1);\n}\n</code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>\n<pre><code>    1  0  0  1  0\n&amp;   0  1  1  1  1\n__________________\n    0  0  0  1  0    = 2\n</code></pre><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>\n<p>所以最终存储位置的确定流程是这样的：</p>\n<p>再来看看addEntry的实现：</p>\n<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {\n        resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n</code></pre><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>\n<p>三、为何HashMap的数组长度一定是2的次幂？</p>\n<p>我们来继续看上面提到的resize方法</p>\n<pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n</code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>\n<pre><code>void transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>\n<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>\n<p>　　</p>\n<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>\n<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>\n<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>\n<p>get方法</p>\n<pre><code>public V get(Object key) {\n    //如果key为null,则直接去table[0]处去检索即可。\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n    return null == entry ? null : entry.getValue();\n}\n</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>\n<pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {\n\n    if (size == 0) {\n        return null;\n    }\n    //通过key的hashcode值计算hash值\n    int hash = (key == null) ? 0 : hash(key);\n    //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp; \n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}    \n</code></pre><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>\n<p>四、重写equals方法需同时重写hashCode方法</p>\n<p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>\n<pre><code>/**\n * Created by chengxiao on 2016/11/15.\n */\npublic class MyTest {\nprivate static class Person{\n    int idCard;\n    String name;\n\n    public Person(int idCard, String name) {\n        this.idCard = idCard;\n        this.name = name;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()){\n            return false;\n        }\n        Person person = (Person) o;\n        //两个对象是否等值，通过idCard来确定\n        return this.idCard == person.idCard;\n    }\n\n}\npublic static void main(String []args){\n    HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();\n    Person person = new Person(1234,&quot;乔峰&quot;);\n    //put到hashmap中去\n    map.put(person,&quot;天龙八部&quot;);\n    //get取出，从逻辑上讲应该能输出“天龙八部”\n    System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));\n}\n}\n</code></pre><p>实际输出结果：</p>\n<p>结果：null</p>\n<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>\n<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>\n<p>五、总结</p>\n<p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>==【注意，答案都是来自网络，自辨真假】==</p>\n<p>1、关于spring的aop的实现方法。</p>\n<pre><code>1.通知(Advice):\n通知定义了切面是什么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。\n2.连接点(Joinpoint):\n程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法被调用时、异常被抛出时等等。\n3.切入点(Pointcut)\n通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，spring中允许我们方便的用正则表达式来指定\n4.切面(Aspect)\n通知和切入点共同组成了切面：时间、地点和要发生的“故事”\n5.引入(Introduction)\n引入允许我们向现有的类添加新的方法和属性(Spring提供了一个方法注入的功能）\n6.目标(Target)\n即被通知的对象，如果没有AOP,那么它的逻辑将要交叉别的事务逻辑，有了AOP之后它可以只关注自己要做的事（AOP让他做爱做的事）\n7.代理(proxy)\n应用通知的对象，详细内容参见设计模式里面的代理模式\n8.织入(Weaving)\n把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机:\n(1)编译时：当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器\n(2)类加载时：使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码\n(3)运行时：切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术\nSpring提供了4种实现AOP的方式：\n1.经典的基于代理的AOP\n2.@AspectJ注解驱动的切面\n3.纯POJO切面\n4.注入式AspectJ切面\n</code></pre><hr>\n<p>2、关于分布式消息队列，分布式缓存</p>\n<p>分布式消息队列：</p>\n<pre><code>一、消息队列概述\n\n消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n目前在生产环境，使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ等。\n\n二、消息队列应用场景\n\n以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景。\n\n2.1异步处理\n\n场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种1.串行的方式；2.并行方式。\n\n（1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。\n\n（2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间。\n\n2.2应用解耦\n\n场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。\n\n传统模式的缺点：\n\n1）  假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；\n\n2）  订单系统与库存系统耦合；\n\n如何解决以上问题呢？引入应用消息队列后的方案\n\n订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。\n\n库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。\n\n假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。\n\n2.3流量削锋\n\n流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。\n\n应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。\n\n2.4日志处理\n\n日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题\n\n日志采集客户端，负责日志数据采集，定时写受写入Kafka队列；\nKafka消息队列，负责日志数据的接收，存储和转发；\n日志处理应用：订阅并消费kafka队列中的日志数据；\n\n(1)Kafka：接收用户日志的消息队列。\n\n(2)Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n\n(3)Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n\n(4)Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n\n2.5消息通讯\n\n消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n</code></pre><p>分布式缓存：</p>\n<pre><code>1.1 分布式缓存的特性\n\n分布式缓存具有如下特性: \n\n1) 高性能:当传统数据库面临大规模数据访问时,磁盘I/O 往往成为性能瓶颈,从而导致过高的响应延迟.分布式缓存将高速内存作为数据对象的存储介质,数据以key/value 形式存储,理想情况下可以获得DRAM 级的读写性能; \n\n2) 动态扩展性:支持弹性扩展,通过动态增加或减少节点应对变化的数据访问负载,提供可预测的性能与扩展性;同时,最大限度地提高资源利用率; \n\n3) 高可用性:可用性包含数据可用性与服务可用性两方面.基于冗余机制实现高可用性,无单点失效(single point of failure),支持故障的自动发现,透明地实施故障切换,不会因服务器故障而导致缓存服务中断或数据丢失.动态扩展时自动均衡数据分区,同时保障缓存服务持续可用; \n\n4) 易用性:提供单一的数据与管理视图;API 接口简单,且与拓扑结构无关;动态扩展或失效恢复时无需人工配置;自动选取备份节点;多数缓存系统提供了图形化的管理控制台,便于统一维护; \n\n5) 分布式代码执行(distributed code execution):将任务代码转移到各数据节点并行执行,客户端聚合返回结果,从而有效避免了缓存数据的移动与传输.最新的Java 数据网格规范JSR-347中加入了分布式代码执行与Map/reduce 的API 支持,各主流分布式缓存产品,如IBM WebSphere eXtreme Scale,VMware GemFire,GigaSpaces XAP 和Red Hat Infinispan 等也都支持这一新的编程模型. \n\n1.2 典型应用场景 \n\n分布式缓存的典型应用场景可分为以下几类: \n\n1) 页面缓存.用来缓存Web 页面的内容片段,包括HTML、CSS 和图片等,多应用于社交网站等; \n\n2) 应用对象缓存.缓存系统作为ORM 框架的二级缓存对外提供服务,目的是减轻数据库的负载压力,加速应用访问; \n\n3) 状态缓存.缓存包括Session 会话状态及应用横向扩展时的状态数据等,这类数据一般是难以恢复的,对可用性要求较高,多应用于高可用集群; \n\n4) 并行处理.通常涉及大量中间计算结果需要共享; \n\n5) 事件处理.分布式缓存提供了针对事件流的连续查询(continuous query)处理技术,满足实时性需求; \n\n6) 极限事务处理.分布式缓存为事务型应用提供高吞吐率、低延时的解决方案,支持高并发事务请求处理,多应用于铁路、金融服务和电信等领域.\n</code></pre><hr>\n<p>3、关于rpc</p>\n<pre><code>RPC(Remote Procedure Call，远程过程调用)是建立在Socket之上的，在一台机器上运行的主程序，可以调用另一台机器上准备好的子程序，就像LPC(本地过程调用)。\n\n越底层，代码越复杂、灵活性越高、效率越高；越上层，抽象封装的越好、代码越简单、效率越差。\n\nSocket和RPC的区别再次说明了这点。在传统的编程概念中，过程是由程序员在本地编译完成，并只能局限在本地运行的一段代码，也即其主程序和过程之间的运行关系是本地调用关系。因此这种结构在网络日益发展的今天已无法适应实际需求。众所周知，传统过程调用模式无法充分利用网络上其他主机的资源(如CPU、Memory等)，也无法提高代码在实体间的共享程度，使得主机资源大量浪费。\n\n通过RPC，我们可以充分利用非共享内存的多处理器环境(例如通过局域网连接得多台工作站)，这样可以简便地将你的应用分布在多台工作站上，应用程序就像运行在一个多处理器的计算机上一样。你可以方便的实现过程代码共享，提高系统资源的利用率，也可以将以大量数值处理的操作放在处理能力较强的系统上运行，从而减轻前端机的负担。\n\nRPC作为普遍的C/S开发方法，开发效率高效，可靠。但RPC方法的基本原则是：以模块调用的简单性忽略通讯的具体细节，以便程序员不用关心C/S之间的通讯协议，集中精力对付实现过程。这就决定了 RPC生成的通讯包不可能对每种应用都有最恰当的处理办法，与Socket方法相比，传输相同的有效数据，RPC占用更多的网络带宽。\n\nRPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。\n\nRPC的结构原理及其调用机制\n\n如前所述，RPC其实也是种C/S的编程模式，有点类似C/S Socket 编程模式，但要比它更高一层。\n\n当我们在建立RPC服务以后，客户端的调用参数通过底层的RPC传输通道，可以是UDP，也可以是TCP，并根据传输前所提供的目的地址及RPC上层应用程序号转至相应的RPC应用程序服务端，且此时的客户端处于等待状态，直至收到应答或Time Out超时信号。当服务器端获得请求消息，则会根据注册RPC时告诉RPC系统的例程入口地址，执行相应的操作，并将结果返回至客户端。\n\n当一次RPC调用结束后，相应线程发送相应的信号，客户端程序才会继续运行。\n\n在这个过程中，一个远程过程是有三个要素来唯一确定的：程序号、版本号和过程号。\n\n程序号是用来区别一组相关的并且具有唯一过程好的远程过程。一个程序可以有一个或几个不同的版本，而每个版本的程序都包含一系列能被远程调用的过程，通过版本的引入，使得不同版本下的RPC能同时提供服务。每个版本都包含有许多可供远程调用的过程，每个过程则有其唯一标示的过程号。\n\n基于RPC的应用系统开发\n\n一般而言在开发RPC时，我们通常分为三个步骤：\n\nA、定义说明客户/服务器的通信协议:这里所说的通信协议是指定义服务过程的名称、调用参数的数据类型和返回参数的数据类型，还包括底层传输类型(可以是UDP或TCP)，当然也可以由RPC底层函数自动选择连接类型建立TI-RPC。最简单的协议生成的方法是采用协议编译工具，常用的有Rpcgen，我会在后面实例中详细描述其使用方法。\n\nB、开发客户端程序。\n\nC、开发服务器端程序。\n\n开发客户端和服务器端的程序时，RPC提供了我们不同层次的开发例程调用接口。不同层次的接口提供了对RPC不同程度控制。\n</code></pre><hr>\n<p>4、关于hashmap源码实现</p>\n<p>HashMap实现原理及源码分析</p>\n<p>　　哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>\n<p>目录</p>\n<p>　　一、什么是哈希表</p>\n<p>　　二、HashMap实现原理</p>\n<p>　　三、为何HashMap的数组长度一定是2的次幂？</p>\n<p>　　四、重写equals方法需同时重写hashCode方法</p>\n<p>　　五、总结</p>\n<p>一、什么是哈希表</p>\n<p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>\n<p>　　数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p>\n<p>　　线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p>\n<p>　　二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p>\n<p>　　哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>\n<p>　　我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。</p>\n<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>\n<p>　　　　　　　　存储位置 = f(关键字)</p>\n<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>\n<p>　　</p>\n<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>\n<p>　　哈希冲突</p>\n<p>　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，</p>\n<p>二、HashMap实现原理</p>\n<p>　HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>\n<p>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。<br>transient Entry<k,v>[] table = (Entry<k,v>[]) EMPTY_TABLE;<br> Entry是HashMap中的一个静态内部类。代码如下</k,v></k,v></p>\n<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final K key;\n    V value;\n    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构\n    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算\n\n    /**\n     * Creates new entry.\n     */\n    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {\n        value = v;\n        next = n;\n        key = k;\n        hash = h;\n    } \n</code></pre><p> 所以，HashMap的整体结构如下</p>\n<p>　　</p>\n<p>　　简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>\n<p>其他几个重要字段</p>\n<pre><code>//实际存储的key-value键值对的个数\ntransient int size;\n//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到\nint threshold;\n//负载因子，代表了table的填充度有多少，默认是0.75\nfinal float loadFactor;\n//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException\ntransient int modCount;\n</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p>\n<p>initialCapacity默认为16，loadFactory默认为0.75</p>\n<p>我们看下其中一个</p>\n<pre><code>public HashMap(int initialCapacity, float loadFactor) {\n//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n\n    this.loadFactor = loadFactor;\n    threshold = initialCapacity;\n    init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现\n}\n</code></pre><p>　　从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</p>\n<p>　　OK,接下来我们来看看put操作的实现吧</p>\n<pre><code>public V put(K key, V value) {\n    //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    }\n   //如果key为null，存储位置为table[0]或table[0]的冲突链上\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀\n    int i = indexFor(hash, table.length);//获取在table中的实际位置\n    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {\n    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value\n        Object k;\n        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败\n    addEntry(hash, key, value, i);//新增一个entry\n    return null;\n}    \n</code></pre><p> 先来看看inflateTable这个方法</p>\n<pre><code>private void inflateTable(int toSize) {\n    int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂\n    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1\n    table = new Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n</code></pre><p>　　inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>\n<pre><code>private static int roundUpToPowerOf2(int number) {\n    // assert number &gt;= 0 : &quot;number must be non-negative&quot;;\n    return number &gt;= MAXIMUM_CAPACITY\n            ? MAXIMUM_CAPACITY\n            : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;\n}\n</code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</p>\n<p>hash函数</p>\n<pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀\nfinal int hash(Object k) {\n    int h = hashSeed;\n    if (0 != h &amp;&amp; k instanceof String) {\n        return sun.misc.Hashing.stringHash32((String) k);\n    }\n\n    h ^= k.hashCode();\n\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>\n<pre><code>/**\n * 返回数组下标\n */\nstatic int indexFor(int h, int length) {\n    return h &amp; (length-1);\n}\n</code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>\n<pre><code>    1  0  0  1  0\n&amp;   0  1  1  1  1\n__________________\n    0  0  0  1  0    = 2\n</code></pre><p>　　最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p>\n<p>所以最终存储位置的确定流程是这样的：</p>\n<p>再来看看addEntry的实现：</p>\n<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {\n        resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    }\n\n    createEntry(hash, key, value, bucketIndex);\n}\n</code></pre><p>　　通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>\n<p>三、为何HashMap的数组长度一定是2的次幂？</p>\n<p>我们来继续看上面提到的resize方法</p>\n<pre><code>void resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable, initHashSeedAsNeeded(newCapacity));\n    table = newTable;\n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n</code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>\n<pre><code>void transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）\n    for (Entry&lt;K,V&gt; e : table) {\n        while(null != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre><p>　　这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p>\n<p>　　hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p>\n<p>　　</p>\n<p> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p>\n<p>　　我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p>\n<p>　　如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p>\n<p>get方法</p>\n<pre><code>public V get(Object key) {\n    //如果key为null,则直接去table[0]处去检索即可。\n    if (key == null)\n        return getForNullKey();\n    Entry&lt;K,V&gt; entry = getEntry(key);\n    return null == entry ? null : entry.getValue();\n}\n</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>\n<pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {\n\n    if (size == 0) {\n        return null;\n    }\n    //通过key的hashcode值计算hash值\n    int hash = (key == null) ? 0 : hash(key);\n    //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录\n    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];\n         e != null;\n         e = e.next) {\n        Object k;\n        if (e.hash == hash &amp;&amp; \n            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return e;\n    }\n    return null;\n}    \n</code></pre><p>　　可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>\n<p>四、重写equals方法需同时重写hashCode方法</p>\n<p>　　关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>\n<pre><code>/**\n * Created by chengxiao on 2016/11/15.\n */\npublic class MyTest {\nprivate static class Person{\n    int idCard;\n    String name;\n\n    public Person(int idCard, String name) {\n        this.idCard = idCard;\n        this.name = name;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()){\n            return false;\n        }\n        Person person = (Person) o;\n        //两个对象是否等值，通过idCard来确定\n        return this.idCard == person.idCard;\n    }\n\n}\npublic static void main(String []args){\n    HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();\n    Person person = new Person(1234,&quot;乔峰&quot;);\n    //put到hashmap中去\n    map.put(person,&quot;天龙八部&quot;);\n    //get取出，从逻辑上讲应该能输出“天龙八部”\n    System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));\n}\n}\n</code></pre><p>实际输出结果：</p>\n<p>结果：null</p>\n<p>　　如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p>\n<p>　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>\n<p>五、总结</p>\n<p>　　本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。</p>\n"},{"title":"20170619第一次使用HEXO","date":"2017-06-19T10:29:33.000Z","_content":"\n正在努力学习中，然后记录以后工作中遇到的问题，或者学习中发现的好的东西分享。\n\n加油加油加油！\n\n\n\n\n\n\n","source":"_posts/20170619第一次使用HEXO.md","raw":"---\ntitle: 20170619第一次使用HEXO\ndate: 2017-06-19 18:29:33\ntags:\n---\n\n正在努力学习中，然后记录以后工作中遇到的问题，或者学习中发现的好的东西分享。\n\n加油加油加油！\n\n\n\n\n\n\n","slug":"20170619第一次使用HEXO","published":1,"updated":"2017-06-20T08:46:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj486x74q00017k26kad1lixa","content":"<p>正在努力学习中，然后记录以后工作中遇到的问题，或者学习中发现的好的东西分享。</p>\n<p>加油加油加油！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>正在努力学习中，然后记录以后工作中遇到的问题，或者学习中发现的好的东西分享。</p>\n<p>加油加油加油！</p>\n"},{"title":"【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）","date":"2017-06-21T09:02:02.000Z","_content":"\n\n转载请注明出处（corey）\n最近在研究osgi，在osgi里面里面有个很重要的东西，就是ClassLoader，所以，在网上搜集了一些资料，整理一下，\n并加入了自己的一些理解；\n\n(1)jvm的装载过程以及装载原理\n所谓装载就是寻找一个类或是一个接口的二进制形式并用该二进制形式来构造代表这个类或是这个接口的class对象的过程，\n其中类或接口的名称是给定了的。当然名称也可以通过计算得到，但是更常见的是通过搜索源代码经过编译器编译后所得到\n的二进制形式来构造。 \n\n在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，\n其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：\n\n　　装载：查找和导入类或接口的二进制数据； \n　　\n　　链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； \n　　\n　　校验：检查导入类或接口的二进制数据的正确性；\n　　 \n　　准备：给类的静态变量分配并初始化存储空间； \n　　\n　　解析：将符号引用转成直接引用； \n　　\n　　初始化：激活类的静态变量的初始化Java代码和静态Java代码块。\n　　\n(2)：java中的类是什么？\n\n一个类代表要执行的代码，而数据则表示其相关状态。状态时常改变，而代码则不会。当我们将一个特定的状态与一个类相对应起来，也就意味着将一个类事例化。尽管相同的类对应的实例其状态千差万别，但其本质都对应着同一段代码。在JAVA中，一个类通常有着一个.class文件，但也有例外。在JAVA的运行时环境中（Java runtime），每一个类都有一个以第一类(first-class)的Java对象所表现出现的代码，其是java.lang.Class的实例。我们编译一个JAVA文件，编译器都会嵌入一个public, static, final修饰的类型为java.lang.Class，名称为class的域变量在其字节码文件中。因为使用了public修饰，我们可以采用如下的形式对其访问：\njava.lang.Class klass = Myclass.class;\n\n一旦一个类被载入JVM中，同一个类就不会被再次载入了（切记，同一个类）。这里存在一个问题就是什么是“同一个类”？正如一个对象有一个具体的状态，即标识，一个对象始终和其代码(类)相关联。同理，载入JVM的类也有一个具体的标识，我们接下来看。\n\n在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识。因此，如果一个名为Pg的包中，有一个名为Cl的类，被类加载器KlassLoader的一个实例kl1加载，Cl的实例，即C1.class在JVM中表示为(Cl, Pg, kl1)。这意味着两个类加载器的实例(Cl, Pg, kl1) 和 (Cl, Pg, kl2)是不同的，被它们所加载的类也因此完全不同，互不兼容的。那么在JVM中到底有多少种类加载器的实例？下一节我们揭示答案。\n\n(3)：java的几种ClassLoader：\n\n在java中，我们可以取得这么以下三个ClassLoader类：\n\n一．    ClassLoader基本概念\n\n1．ClassLoader分类\n\n类装载器是用来把类(class)装载进JVM的。\n\nJVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。\n\nJVM在运行时会产生三个ClassLoader:Bootstrap ClassLoader、Extension ClassLoader和AppClassLoader。Bootstrap是用C++编写的，我们在Java中看不到它,是null,是JVM自带的类装载器，用来装载核心类库，如java.lang.*等。\n\nAppClassLoader的Parent是ExtClassLoader，而ExtClassLoader的Parent为Bootstrap ClassLoader。\n \nJava提供了抽象类ClassLoader，所有用户自定义类装载器都实例化自ClassLoader的子类。 System Class Loader是一个特殊的用户自定义类装载器，由JVM的实现者提供，在编程者不特别指定装载器的情况下默认装载用户类。系统类装载器可以通过\n\nClassLoader.getSystemClassLoader() 方法得到。\n \n \n例1，测试你所使用的JVM的ClassLoader\n\n\t/*LoaderSample1.java*/\n\tpublic   class  LoaderSample1 {\n     public   static   void  main(String[] args) {\n        Class c;\n        ClassLoader cl;\n        cl  =  ClassLoader.getSystemClassLoader();\n        System.out.println(cl);\n         while  (cl  !=   null ) {\n            cl  =  cl.getParent();\n            System.out.println(cl);\n        }\n         try  {\n            c  =  Class.forName( \" java.lang.Object \" );\n            cl  =  c.getClassLoader();\n            System.out.println( \" java.lang.Object's loader is  \"   +  cl);\n            c  =  Class.forName( \" LoaderSample1 \" );\n            cl  =  c.getClassLoader();\n            System.out.println( \" LoaderSample1's loader is  \"   +  cl);\n        }  catch  (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t}\n\n在我的机器上(Sun Java 1.4.2)的运行结果\n\nsun.misc.Launcher$AppClassLoader@1a0c10f\nsun.misc.Launcher$ExtClassLoader@e2eec8\nnull\njava.lang.Object's loader is null\nLoaderSample1's loader is sun.misc.Launcher$AppClassLoader@1a0c10f\n\n第一行表示，系统类装载器实例化自类\n\nsun.misc.Launcher$AppClassLoader\n\n第二行表示，系统类装载器的parent实例化自类\n\nsun.misc.Launcher$ExtClassLoader\n\n第三行表示，系统类装载器parent的parent为bootstrap\n\n第四行表示，核心类java.lang.Object是由bootstrap装载的\n\n第五行表示，用户类LoaderSample1是由系统类装载器装载的\n\n注意，我们清晰的看见这个三个ClassLoader类之间的父子关系（不是继承关系），父子关系在ClassLoader的实现中有一个ClassLoader类型的属性，我们可以在自己实现自定义的ClassLoader的时候初始化定义，而这三个系统定义的ClassLoader的父子关系分别是\n\nAppClassLoader——————》（Parent）ExtClassLoader——————————》（parent）BootClassLoader(null c++实现)\n\n系统为什么要分别指定这么多的ClassLoader类呢？\n\n答案在于因为java是动态加载类的，这样的话，可以节省内存，用到什么加载什么，就是这个道理，然而系统在运行的时候并不知道我们这个应用与需要加载些什么类，那么，就采用这种逐级加载的方式\n\n(1)首先加载核心API，让系统最基本的运行起来\n\n(2)加载扩展类\n\n(3)加载用户自定义的类\n\n\tpackage org.corey.clsloader;\n\timport java.net.MalformedURLException;\n\timport java.net.URL;\n\timport java.net.URLClassLoader;\n\timport sun.net.spi.nameservice.dns.DNSNameService;\n\tpublic class ClsLoaderDemo {\n\t /**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n\tSystem.out.println(System.getProperty(\"sun.boot.class.path\"));\n\tSystem.out.println(System.getProperty(\"java.ext.dirs\"));\n \tSystem.out.println(System.getProperty(\"java.class.path\"));\n \t}\n\t}\n\n程序结果为：\n\nE:/MyEclipse 6.0/jre/lib/rt.jar;E:/MyEclipse 6.0/jre/lib/i18n.jar;E:/MyEclipse 6.0/jre/lib/sunrsasign.jar;E:/MyEclipse 6.0/jre/lib/jsse.jar;E:/MyEclipse 6.0/jre/lib/jce.jar;E:/MyEclipse 6.0/jre/lib/charsets.jar;E:/MyEclipse 6.0/jre/classes\n\nE:/MyEclipse 6.0/jre/lib/ext\n\nE:/workspace/ClassLoaderDemo/bin\n\n在上面的结果中，你可以清晰看见三个ClassLoader分别加载类的路径；也知道为什么我们在编写程序的时候，要把用到的jar包放在工程的classpath下面啦，也知道我们为什么可以不加载java.lang.*包啦！其中java.lang.*就在rt.jar包中；\n\n(4)ClassLoader的加载机制：\n\n现在我们设计这种一下Demo:\n\n\tpackage java.net;\n\tpublic class URL {\n \tprivate String path;\n \tpublic URL(String path) {\n \t this.path = path;\n \t}\n \tpublic String toString() {\n \t return this.path + \" new Path\";\n \t}\n\t}\n\n\tpackage java.net;\n\timport java.net.*;\n\tpublic class TheSameClsDemo {\n\t /**\n \t * @param args\n  \t*/\n\t public static void main(String[] args) {\n \t URL url = new URL(\"http://www.baidu.com\");\n \t System.out.println(url.toString());\n\t }\n\t}\n\t\n在这种情况下，系统会提示我们出现异常，因为我们有两个相同的类，一个是真正的URL，一个是我在上面实现的伪类；出现异常是正常的，因为你想想，如果我们在执行一个applet的时候，程序自己实现了一个String的类覆盖了我们虚拟机上面的真正的String类，那么在这个String里面，不怀好意的人可以任意的实现一些功能；这就造成极不安全的隐患；所以java采用了一种名为“双亲委托”的加载模式；\n\n以下是jdk源代码：\n\n\tprotected synchronized Class<?> loadClass(String name, boolean resolve)\n \tthrows ClassNotFoundException\n    \t{\n \t// First, check if the class has already been loaded\n \tClass c = findLoadedClass(name);\n \tif (c == null) {\n     \ttry {\n  \tif (parent != null) {\n    \t  c = parent.loadClass(name, false);\n  \t} else {\n     \t c = findBootstrapClass0(name);\n  \t}\n     \t} catch (ClassNotFoundException e) {\n         // If still not found, then invoke findClass in order\n         // to find the class.\n         c = findClass(name);\n     \t}\n \t}\n \tif (resolve) {\n     \tresolveClass(c);\n\t }\n \t\treturn c;\n    }\n    \n在上面的代码中，我们可以清晰的看见，我们调用一个ClassLoader加载程序的时候，这个ClassLoader会先调用设置好的parent ClassLoader来加载这个类，如果parent是null的话，则默认为Boot ClassLoader类，只有在parent没有找的情况下，自己才会加载，这就避免我们重写一些系统类，来破坏系统的安全；\n再来看一个明显的例子：\n\n\tpackage org.corey;\n\tpublic class MyCls{\n \tprivate String name;\n \n \tpublic MyCls(){\n \n \t}\n \tpublic MyCls(String name){\n \tthis.name=name;\n\t }\n  \n \tpublic void say(){\n \t\tSystem.out.println(this.name); \n \t}\n\t}\n\t\n把上面这个MyCls类打成jar包，丢进ext classLoader的加载路径；\n然后写出main类：\n\n\tpackage org.corey.clsloader;\n\timport org.corey.MyCls;\n\tpublic class TheSameClsDemo {\n \t/**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n \t MyCls myClsOb=new MyCls(\"name\");\n     myClsOb.say(); \n     System.out.println(MyCls.class.getClassLoader());\n     System.out.println(System.getProperty(\"java.class.path\"));\n     System.out.println(TheSameClsDemo.class.getClassLoader());\n \t}\n\t}\n\t\n并且把MyCls类加入biild-path里面方便引用；\n结果是：\n\nname\nsun.misc.Launcher$ExtClassLoader@16930e2\n\nE:/workspace/ClassLoaderDemo/bin;E:/MyEclipse 6.0/jre/lib/ext/corey.jar\n\nsun.misc.Launcher$AppClassLoader@7259da\n\n从上面的例子可以清晰的看出ClassLoader之间的这种双亲委托加载模式；\n\n再来看下一个例子(摘自http://bbs.cnw.com.cn/viewthread.php?tid=95389)\n\n下面我们就来看一个综合的例子。首先在eclipse中建立一个简单的java应用工程，然后写一个简单的JavaBean如下：\n\n\tpackage classloader.test.bean;\n \n\tpublicclass TestBean {\n \n\n\tpublic TestBean() {}\n\n\t}\n\t\n在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下：\n测试一：\n\n\tpublicclass ClassLoaderTest {\n \tpublicstaticvoid main(String[] args) {\n \ttry {\n \t//查看当前系统类路径中包含的路径条目\n\tSystem.out.println(System.getProperty(\"java.class.path\"));\n\t//调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean\n\tClass typeLoaded = Class.forName(\"classloader.test.bean.TestBean\");\n\t//查看被加载的TestBean类型是被那个类加载器加载的\n\tSystem.out.println(typeLoaded.getClassLoader());\n \t} catch (Exception e) {\n\t \te.printStackTrace();\n \t}\n\t}\n\t}\n\n对应的输出如下：\n\n\tD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\n\tsun.misc.Launcher$AppClassLoader@197d257\n\t\n（说明：当前类路径默认的含有的一个条目就是工程的输出目录）\n\n测试二：\n\n将当前工程输出目录下的…/classloader/test/bean/TestBean.class打包进test.jar剪贴到< Java_Runtime_Home >/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下：\n\nD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\nsun.misc.Launcher$ExtClassLoader@7259da\n\n对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。\n\n测试三：\n\n将test.jar拷贝一份到< Java_Runtime_Home >/lib下，运行测试代码，输出如下：\n\nD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\nsun.misc.Launcher$ExtClassLoader@7259da\n\n测试三和测试二输出结果一致。那就是说，放置到< Java_Runtime_Home >/lib目录下的TestBean对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载< Java_Runtime_Home >/lib存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除< Java_Runtime_Home >/lib/ext目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有ClassNotFoundException异常抛出。有关这个问题，大家可以在java.lang.ClassLoader中的loadClass(String name, boolean resolve)方法中设置相应断点运行测试三进行调试，会发现findBootstrapClass0()会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（sun.misc.Launcher$ExtClassLoader），这一点可以通过JDT中变量视图查看验证。\n\n(5)被不同的ClassLoader加载的两个类之间有什么限制和不同?\n\n现在我们来看一下一个现象：\n\n在eclipse里面我是这样做的：\n\nOneCls.java\n\n\tpackage org.corey.one;\n\timport org.corey.two.TwoCls;\n\tpublic class OneCls {\n\t public OneCls() {\n\t System.out.println();\n  \t TwoCls two = new TwoCls();\n \t two.say();\n \t}\n\t}\n\t\nTwoCls.java\n\n\tpackage org.corey.two;\n\tpublic class TwoCls {\n \n\t public void say() {\n\t  System.out.println(\"i am two\");\n\t }\n\t}\n\t\nDemo.java:\n\n\tpackage org.corey.Demo;\n\timport org.corey.one.OneCls;\n\tpublic class Demo {\n\t /**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n \t OneCls one=new OneCls();\n \t}\n\t}\n\t\n在这里，我们来仔细看下，one引用了two，demo引用了one，这是三个类都是由AppClassLoader加载的；运行正常；\n\n把OneCls打成jar包，放在lib/ext路径下面，然后在工程里面引入这个jar包；运行：异常，这是因为：\n\nDemo是由AppClassLoader载入，委托给双亲加载失败后，由AppClassLoader加载，而加载OneCls的时候，委托给双亲，被ExtClassLoader加载成功，但是在载入OneCls的时候，同时引用了TwoCls,但是ExtClassLoader引用TwoCls失败，但是他只会委托给双亲，而不会委托给AppClassLoader这个儿子，所以会出现异常；\n\n\\3. 奇怪的隔离性\n\n我们不难发现，图2中的类装载器AA和AB， AB和BB，AA和B等等位于不同分支下，他们之间没有父子关系，我不知道如何定义这种关系，姑且称他们位于不同分支下。两个位于不同分支的类装载器具有隔离性，这种隔离性使得在分别使用它们装载同一个类，也会在内存中出现两个Class类的实例。因为被具有隔离性的类装载器装载的类不会共享内存空间，使得使用一个类装载器不可能完成的任务变得可以轻而易举，例如类的静态变量可能同时拥有多个值（虽然好像作用不大），因为就算是被装载类的同一静态变量，它们也将被保存不同的内存空间，又例如程序需要使用某些包，但又不希望被程序另外一些包所使用，很简单，编写自定义的类装载器。类装载器的这种隔离性在许多大型的软件应用和服务程序得到了很好的应用。下面是同一个类静态变量为不同值的例子。\n\npackage test;\npublic class A {\n  public static void main( String[] args ) {\n    try {\n      //定义两个类装载器\n      MyClassLoader aa= new MyClassLoader();\n      MyClassLoader bb = new MyClassLoader();\n      //用类装载器aa装载testb.B类\n      Class clazz=aa.loadClass(\"testb. B\");\n      Constructor constructor= \n        clazz.getConstructor(new Class[]{Integer.class});\n      Object object = \n     constructor.newInstance(new Object[]{new Integer(1)});\n      Method method = \n     clazz.getDeclaredMethod(\"printB\",new Class[0]);\n      //用类装载器bb装载testb.B类\n      Class clazz2=bb.loadClass(\"testb. B\");\n      Constructor constructor2 = \n        clazz2.getConstructor(new Class[]{Integer.class});\n      Object object2 = \n     constructor2.newInstance(new Object[]{new Integer(2)});\n      Method method2 = \n     clazz2.getDeclaredMethod(\"printB\",new Class[0]);\n      //显示test.B中的静态变量的值 \n      method.invoke( object,new Object[0]);\n      method2.invoke( object2,new Object[0]);\n    } catch ( Exception e ) {\n      e.printStackTrace();\n    }\n  }\n}\n \n//Class B 必须位于MyClassLoader的查找范围内，\n//而不应该在MyClassLoader的父类装载器的查找范围内。\npackage testb;\npublic class B {\n    static int b ;\n    public B(Integer testb) {\n        b = testb.intValue();\n    }\n    public void printB() {\n        System.out.print(\"my static field b is \", b);\n    }\n}\n \npublic class MyClassLoader extends URLClassLoader{\n  private static File file = new File(\"c://classes \");\n  //该路径存放着class B，但是没有class A\n  public MyClassLoader() {\n    super(getUrl());\n  }\n  public static URL[] getUrl() {\n    try {\n      return new URL[]{file.toURL()};\n    } catch ( MalformedURLException e ) {\n      return new URL[0];\n    }\n  }\n}\n程序的运行结果为：\nmy static field b is 1\nmy static field b is 2\n程序的结果非常有意思，从编程者的角度，我们甚至可以把不在同一个分支的类装载器看作不同的java虚拟机，因为它们彼此觉察不到对方的存在。程序在使用具有分支的类装载的体系结构时要非常小心，弄清楚每个类装载器的类查找范围，尽量避免父类装载器和子类装载器的类查找范围中有相同类名的类（包括包名和类名），下面这个例子就是用来说明这种情况可能带来的问题。\n \n(6) 类如何被装载及类被装载的方式(转自Java类装载体系中的隔离性  作者：盛戈歆)\n在java2中，JVM是如何装载类的呢，可以分为两种类型，一种是隐式的类装载，一种式显式的类装载。\n2.1 隐式的类装载\n隐式的类装载是编码中最常用得方式：\nA b = new A();\n如果程序运行到这段代码时还没有A类，那么JVM会请求装载当前类的类装器来装载类。问题来了，我把代码弄得复杂一点点，但依旧没有任何难度，请思考JVM得装载次序：\npackage test;\nPublic class A{\n    public void static main(String args[]){\n        B b ＝ new B();\n    }\n}\nclass B{C c;}\nclass C{}\n揭晓答案，类装载的次序为A->B，而类C根本不会被JVM理会,先不要惊讶，仔细想想，这不正是我们最需要得到的结果。我们仔细了解一下JVM装载顺序。当使用Java A命令运行A类时，JVM会首先要求类路径类装载器(AppClassLoader)装载A类，但是这时只装载A，不会装载A中出现的其他类(B类)，接着它会调用A中的main函数，直到运行语句b ＝ new B()时，JVM发现必须装载B类程序才能继续运行，于是类路径类装载器会去装载B类，虽然我们可以看到B中有有C类的声明，但是并不是实际的执行语句，所以并不去装载C类，也就是说JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。\n2.2 显式的类装载\n使用显示的类装载方法很多，我们都装载类test.A为例。\n使用Class类的forName方法。它可以指定装载器，也可以使用装载当前类的装载器。例如：\nClass.forName(\"test.A\");\n它的效果和\nClass.forName(\"test.A\",true,this.getClass().getClassLoader());\n是一样的。\n使用类路径类装载装载.\nClassLoader.getSystemClassLoader().loadClass(\"test.A\");\n使用当前进程上下文的使用的类装载器进行装载，这种装载类的方法常常被有着复杂类装载体系结构的系统所使用。\nThread.currentThread().getContextClassLoader().loadClass(\"test.A\")\n使用自定义的类装载器装载类\npublic class MyClassLoader extends URLClassLoader{\npublic MyClassLoader() {\n        super(new URL[0]);\n    }\n}\nMyClassLoader myClassLoader = new MyClassLoader();\nmyClassLoader.loadClass(\"test.A\");\nMyClassLoader继承了URLClassLoader类，这是JDK核心包中的类装载器，在没有指定父类装载器的情况下，类路径类装载器就是它的父类装载器，MyClassLoader并没有增加类的查找范围，因此它和类路径装载器有相同的效果。\n \n(7)ClassLoader的一些方法实现的功能：\n方法 loadClass\n \n \nClassLoader.loadClass() 是 ClassLoader 的入口点。其特征如下：\n\nClass loadClass( String name, boolean resolve ); name 参数指定了 JVM 需要的类的名称，该名称以包表示法表示，如 Foo 或 java.lang.Object。\nresolve 参数告诉方法是否需要解析类。在准备执行类之前，应考虑类解析。并不总是需要解析。如果 JVM 只需要知道该类是否存在或找出该类的超类，那么就不需要解析。\n在 Java 版本 1.1 和以前的版本中，loadClass 方法是创建定制的 ClassLoader 时唯一需要覆盖的方法。（Java 2 中 ClassLoader 的变动提供了关于 Java 1.2 中 findClass() 方法的信息。）\n \n\n方法 defineClass\n\ndefineClass 方法是 ClassLoader 的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class 对象。原始数组包含如从文件系统或网络装入的数据。\ndefineClass 管理 JVM 的许多复杂、神秘和倚赖于实现的方面 -- 它把字节码分析成运行时数据结构、校验有效性等等。不必担心，您无需亲自编写它。事实上，即使您想要这么做也不能覆盖它，因为它已被标记成最终的。\n你可以看见native标记，知道defineClass是一个jni调用的方法，是由c++实现数据到内存的加载的；\n \n\n方法 findSystemClass\n\nfindSystemClass 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。（Java 2 中 ClassLoader 的变动提供了关于 Java 版本 1.2 这个过程变动的详细信息。）\n对于定制的 ClassLoader，只有在尝试其它方法装入类之后，再使用 findSystemClass。原因很简单：ClassLoader 是负责执行装入类的特殊步骤，不是负责所有类。例如，即使 ClassLoader 从远程的 Web 站点装入了某些类，仍然需要在本地机器上装入大量的基本 Java 库。而这些类不是我们所关心的，所以要 JVM 以缺省方式装入它们：从本地文件系统。这就是 findSystemClass 的用途。\n其工作流程如下：\n\n请求定制的 ClassLoader 装入类。 \n检查远程 Web 站点，查看是否有所需要的类。 \n如果有，那么好；抓取这个类，完成任务。 \n如果没有，假定这个类是在基本 Java 库中，那么调用 findSystemClass，使它从文件系统装入该类。 \n在大多数定制 ClassLoaders 中，首先调用 findSystemClass 以节省在本地就可以装入的许多 Java 库类而要在远程 Web 站点上查找所花的时间。然而，正如，在下一章节所看到的，直到确信能自动编译我们的应用程序代码时，才让 JVM 从本地文件系统装入类。\n \n\n方法 resolveClass\n正如前面所提到的，可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值。\n方法 findLoadedClass\nfindLoadedClass 充当一个缓存：当请求 loadClass 装入类时，它调用该方法来查看ClassLoader 是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法。\n\n三．命名空间及其作用\n每个类装载器有自己的命名空间，命名空间由所有以此装载器为创始类装载器的类组成。不同命名空间的两个类是不可见的，但只要得到类所对应的Class对象的reference，还是可以访问另一命名空间的类。\n \n例2演示了一个命名空间的类如何使用另一命名空间的类。在例子中，LoaderSample2由系统类装载器装载，LoaderSample3由自定义的装载器loader负责装载，两个类不在同一命名空间，但LoaderSample2得到了LoaderSample3所对应的Class对象的reference，所以它可以访问LoaderSampl3中公共的成员(如age)。\n例2不同命名空间的类的访问\n\n/\\*LoaderSample2.java*/\n\n\timport  java.net. * ;\n\timport  java.lang.reflect. * ;\n\tpublic   class  LoaderSample2 {\n     public   static   void  main(String[] args) {\n         try  {\n            String path  =  System.getProperty( \" user.dir \" );\n            URL[] us  =  { new  URL( \" file:// \"   +  path  +   \" /sub/ \" )};\n            ClassLoader loader  =   new  URLClassLoader(us);\n            Class c  =  loader.loadClass( \" LoaderSample3 \" );\n            Object o  =  c.newInstance();\n            Field f  =  c.getField( \" age \" );\n             int  age  =  f.getInt(o);\n            System.out.println( \" age is  \"   +  age);\n        }  catch  (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t}\n\n/\\*sub/Loadersample3.java*/\n\n\tpublic   class  LoaderSample3 {\n     static  {\n        System.out.println( \" LoaderSample3 loaded \" );\n    }\n     public   int  age  =   30 ;\n\t}\n\t\n编译：javac LoaderSample2.java; javac sub/LoaderSample3.java\n\n运行：java LoaderSample2\n\nLoaderSample3 loaded\n\nage is 30\n\n从运行结果中可以看出，在类LoaderSample2中可以创建处于另一命名空间的类LoaderSample3中的对象并可以访问其公共成员age。\n\n运行时包(runtime package)\n\n由同一类装载器定义装载的属于相同包的类组成了运行时包，决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看的定义类装载器是否相同。只有属于同一运行时包的类才能互相访问包可见的类和成员。这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。假设用户自己定义了一个类java.lang.Yes，并用用户自定义的类装载器装载，由于java.lang.Yes和核心类库java.lang.*由不同的装载器装载，它们属于不同的运行时包，所以java.lang.Yes不能访问核心类库java.lang中类的包可见的成员。\n\n(7)有关ClassLoader的重载\n\n  扩展ClassLoader方法\n  \n我们目的是从本地文件系统使用我们实现的类装载器装载一个类。为了创建自己的类装载器我们应该扩展ClassLoader类，这是一个抽象类。我们创建一个FileClassLoader extends ClassLoader。我们需要覆盖ClassLoader中的findClass(String name)方法，这个方法通过类的名字而得到一个Class对象。\n\n     \tpublic  Class findClass(String name)    {\n         byte [] data  =  loadClassData(name);\n         return  defineClass(name, data,  0 , data.length);\n    \t}\n\n   我们还应该提供一个方法loadClassData(String name)，通过类的名称返回class文件的字节数组。然后使用ClassLoader提供的defineClass()方法我们就可以返回Class对象了。\n     \n     public   byte [] loadClassData(String name)    {\n        FileInputStream fis  =   null ;\n         byte [] data  =   null ;\n         try  {\n            fis  =   new  FileInputStream( new  File(drive  +  name  +  fileType));\n            ByteArrayOutputStream baos  =   new  ByteArrayOutputStream();\n             int  ch  =   0 ;\n             while  ((ch  =  fis.read())  !=   - 1 )  {\n                baos.write(ch);              \n            }\n            data  =  baos.toByteArray();\n        }  catch  (IOException e)  {\n            e.printStackTrace();\n        }       \n         return  data;\n    }","source":"_posts/【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）.md","raw":"---\ntitle: 【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）\ndate: 2017-06-21 17:02:02\ntags: classloader\n---\n\n\n转载请注明出处（corey）\n最近在研究osgi，在osgi里面里面有个很重要的东西，就是ClassLoader，所以，在网上搜集了一些资料，整理一下，\n并加入了自己的一些理解；\n\n(1)jvm的装载过程以及装载原理\n所谓装载就是寻找一个类或是一个接口的二进制形式并用该二进制形式来构造代表这个类或是这个接口的class对象的过程，\n其中类或接口的名称是给定了的。当然名称也可以通过计算得到，但是更常见的是通过搜索源代码经过编译器编译后所得到\n的二进制形式来构造。 \n\n在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，\n其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：\n\n　　装载：查找和导入类或接口的二进制数据； \n　　\n　　链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； \n　　\n　　校验：检查导入类或接口的二进制数据的正确性；\n　　 \n　　准备：给类的静态变量分配并初始化存储空间； \n　　\n　　解析：将符号引用转成直接引用； \n　　\n　　初始化：激活类的静态变量的初始化Java代码和静态Java代码块。\n　　\n(2)：java中的类是什么？\n\n一个类代表要执行的代码，而数据则表示其相关状态。状态时常改变，而代码则不会。当我们将一个特定的状态与一个类相对应起来，也就意味着将一个类事例化。尽管相同的类对应的实例其状态千差万别，但其本质都对应着同一段代码。在JAVA中，一个类通常有着一个.class文件，但也有例外。在JAVA的运行时环境中（Java runtime），每一个类都有一个以第一类(first-class)的Java对象所表现出现的代码，其是java.lang.Class的实例。我们编译一个JAVA文件，编译器都会嵌入一个public, static, final修饰的类型为java.lang.Class，名称为class的域变量在其字节码文件中。因为使用了public修饰，我们可以采用如下的形式对其访问：\njava.lang.Class klass = Myclass.class;\n\n一旦一个类被载入JVM中，同一个类就不会被再次载入了（切记，同一个类）。这里存在一个问题就是什么是“同一个类”？正如一个对象有一个具体的状态，即标识，一个对象始终和其代码(类)相关联。同理，载入JVM的类也有一个具体的标识，我们接下来看。\n\n在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识。因此，如果一个名为Pg的包中，有一个名为Cl的类，被类加载器KlassLoader的一个实例kl1加载，Cl的实例，即C1.class在JVM中表示为(Cl, Pg, kl1)。这意味着两个类加载器的实例(Cl, Pg, kl1) 和 (Cl, Pg, kl2)是不同的，被它们所加载的类也因此完全不同，互不兼容的。那么在JVM中到底有多少种类加载器的实例？下一节我们揭示答案。\n\n(3)：java的几种ClassLoader：\n\n在java中，我们可以取得这么以下三个ClassLoader类：\n\n一．    ClassLoader基本概念\n\n1．ClassLoader分类\n\n类装载器是用来把类(class)装载进JVM的。\n\nJVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。\n\nJVM在运行时会产生三个ClassLoader:Bootstrap ClassLoader、Extension ClassLoader和AppClassLoader。Bootstrap是用C++编写的，我们在Java中看不到它,是null,是JVM自带的类装载器，用来装载核心类库，如java.lang.*等。\n\nAppClassLoader的Parent是ExtClassLoader，而ExtClassLoader的Parent为Bootstrap ClassLoader。\n \nJava提供了抽象类ClassLoader，所有用户自定义类装载器都实例化自ClassLoader的子类。 System Class Loader是一个特殊的用户自定义类装载器，由JVM的实现者提供，在编程者不特别指定装载器的情况下默认装载用户类。系统类装载器可以通过\n\nClassLoader.getSystemClassLoader() 方法得到。\n \n \n例1，测试你所使用的JVM的ClassLoader\n\n\t/*LoaderSample1.java*/\n\tpublic   class  LoaderSample1 {\n     public   static   void  main(String[] args) {\n        Class c;\n        ClassLoader cl;\n        cl  =  ClassLoader.getSystemClassLoader();\n        System.out.println(cl);\n         while  (cl  !=   null ) {\n            cl  =  cl.getParent();\n            System.out.println(cl);\n        }\n         try  {\n            c  =  Class.forName( \" java.lang.Object \" );\n            cl  =  c.getClassLoader();\n            System.out.println( \" java.lang.Object's loader is  \"   +  cl);\n            c  =  Class.forName( \" LoaderSample1 \" );\n            cl  =  c.getClassLoader();\n            System.out.println( \" LoaderSample1's loader is  \"   +  cl);\n        }  catch  (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t}\n\n在我的机器上(Sun Java 1.4.2)的运行结果\n\nsun.misc.Launcher$AppClassLoader@1a0c10f\nsun.misc.Launcher$ExtClassLoader@e2eec8\nnull\njava.lang.Object's loader is null\nLoaderSample1's loader is sun.misc.Launcher$AppClassLoader@1a0c10f\n\n第一行表示，系统类装载器实例化自类\n\nsun.misc.Launcher$AppClassLoader\n\n第二行表示，系统类装载器的parent实例化自类\n\nsun.misc.Launcher$ExtClassLoader\n\n第三行表示，系统类装载器parent的parent为bootstrap\n\n第四行表示，核心类java.lang.Object是由bootstrap装载的\n\n第五行表示，用户类LoaderSample1是由系统类装载器装载的\n\n注意，我们清晰的看见这个三个ClassLoader类之间的父子关系（不是继承关系），父子关系在ClassLoader的实现中有一个ClassLoader类型的属性，我们可以在自己实现自定义的ClassLoader的时候初始化定义，而这三个系统定义的ClassLoader的父子关系分别是\n\nAppClassLoader——————》（Parent）ExtClassLoader——————————》（parent）BootClassLoader(null c++实现)\n\n系统为什么要分别指定这么多的ClassLoader类呢？\n\n答案在于因为java是动态加载类的，这样的话，可以节省内存，用到什么加载什么，就是这个道理，然而系统在运行的时候并不知道我们这个应用与需要加载些什么类，那么，就采用这种逐级加载的方式\n\n(1)首先加载核心API，让系统最基本的运行起来\n\n(2)加载扩展类\n\n(3)加载用户自定义的类\n\n\tpackage org.corey.clsloader;\n\timport java.net.MalformedURLException;\n\timport java.net.URL;\n\timport java.net.URLClassLoader;\n\timport sun.net.spi.nameservice.dns.DNSNameService;\n\tpublic class ClsLoaderDemo {\n\t /**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n\tSystem.out.println(System.getProperty(\"sun.boot.class.path\"));\n\tSystem.out.println(System.getProperty(\"java.ext.dirs\"));\n \tSystem.out.println(System.getProperty(\"java.class.path\"));\n \t}\n\t}\n\n程序结果为：\n\nE:/MyEclipse 6.0/jre/lib/rt.jar;E:/MyEclipse 6.0/jre/lib/i18n.jar;E:/MyEclipse 6.0/jre/lib/sunrsasign.jar;E:/MyEclipse 6.0/jre/lib/jsse.jar;E:/MyEclipse 6.0/jre/lib/jce.jar;E:/MyEclipse 6.0/jre/lib/charsets.jar;E:/MyEclipse 6.0/jre/classes\n\nE:/MyEclipse 6.0/jre/lib/ext\n\nE:/workspace/ClassLoaderDemo/bin\n\n在上面的结果中，你可以清晰看见三个ClassLoader分别加载类的路径；也知道为什么我们在编写程序的时候，要把用到的jar包放在工程的classpath下面啦，也知道我们为什么可以不加载java.lang.*包啦！其中java.lang.*就在rt.jar包中；\n\n(4)ClassLoader的加载机制：\n\n现在我们设计这种一下Demo:\n\n\tpackage java.net;\n\tpublic class URL {\n \tprivate String path;\n \tpublic URL(String path) {\n \t this.path = path;\n \t}\n \tpublic String toString() {\n \t return this.path + \" new Path\";\n \t}\n\t}\n\n\tpackage java.net;\n\timport java.net.*;\n\tpublic class TheSameClsDemo {\n\t /**\n \t * @param args\n  \t*/\n\t public static void main(String[] args) {\n \t URL url = new URL(\"http://www.baidu.com\");\n \t System.out.println(url.toString());\n\t }\n\t}\n\t\n在这种情况下，系统会提示我们出现异常，因为我们有两个相同的类，一个是真正的URL，一个是我在上面实现的伪类；出现异常是正常的，因为你想想，如果我们在执行一个applet的时候，程序自己实现了一个String的类覆盖了我们虚拟机上面的真正的String类，那么在这个String里面，不怀好意的人可以任意的实现一些功能；这就造成极不安全的隐患；所以java采用了一种名为“双亲委托”的加载模式；\n\n以下是jdk源代码：\n\n\tprotected synchronized Class<?> loadClass(String name, boolean resolve)\n \tthrows ClassNotFoundException\n    \t{\n \t// First, check if the class has already been loaded\n \tClass c = findLoadedClass(name);\n \tif (c == null) {\n     \ttry {\n  \tif (parent != null) {\n    \t  c = parent.loadClass(name, false);\n  \t} else {\n     \t c = findBootstrapClass0(name);\n  \t}\n     \t} catch (ClassNotFoundException e) {\n         // If still not found, then invoke findClass in order\n         // to find the class.\n         c = findClass(name);\n     \t}\n \t}\n \tif (resolve) {\n     \tresolveClass(c);\n\t }\n \t\treturn c;\n    }\n    \n在上面的代码中，我们可以清晰的看见，我们调用一个ClassLoader加载程序的时候，这个ClassLoader会先调用设置好的parent ClassLoader来加载这个类，如果parent是null的话，则默认为Boot ClassLoader类，只有在parent没有找的情况下，自己才会加载，这就避免我们重写一些系统类，来破坏系统的安全；\n再来看一个明显的例子：\n\n\tpackage org.corey;\n\tpublic class MyCls{\n \tprivate String name;\n \n \tpublic MyCls(){\n \n \t}\n \tpublic MyCls(String name){\n \tthis.name=name;\n\t }\n  \n \tpublic void say(){\n \t\tSystem.out.println(this.name); \n \t}\n\t}\n\t\n把上面这个MyCls类打成jar包，丢进ext classLoader的加载路径；\n然后写出main类：\n\n\tpackage org.corey.clsloader;\n\timport org.corey.MyCls;\n\tpublic class TheSameClsDemo {\n \t/**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n \t MyCls myClsOb=new MyCls(\"name\");\n     myClsOb.say(); \n     System.out.println(MyCls.class.getClassLoader());\n     System.out.println(System.getProperty(\"java.class.path\"));\n     System.out.println(TheSameClsDemo.class.getClassLoader());\n \t}\n\t}\n\t\n并且把MyCls类加入biild-path里面方便引用；\n结果是：\n\nname\nsun.misc.Launcher$ExtClassLoader@16930e2\n\nE:/workspace/ClassLoaderDemo/bin;E:/MyEclipse 6.0/jre/lib/ext/corey.jar\n\nsun.misc.Launcher$AppClassLoader@7259da\n\n从上面的例子可以清晰的看出ClassLoader之间的这种双亲委托加载模式；\n\n再来看下一个例子(摘自http://bbs.cnw.com.cn/viewthread.php?tid=95389)\n\n下面我们就来看一个综合的例子。首先在eclipse中建立一个简单的java应用工程，然后写一个简单的JavaBean如下：\n\n\tpackage classloader.test.bean;\n \n\tpublicclass TestBean {\n \n\n\tpublic TestBean() {}\n\n\t}\n\t\n在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下：\n测试一：\n\n\tpublicclass ClassLoaderTest {\n \tpublicstaticvoid main(String[] args) {\n \ttry {\n \t//查看当前系统类路径中包含的路径条目\n\tSystem.out.println(System.getProperty(\"java.class.path\"));\n\t//调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean\n\tClass typeLoaded = Class.forName(\"classloader.test.bean.TestBean\");\n\t//查看被加载的TestBean类型是被那个类加载器加载的\n\tSystem.out.println(typeLoaded.getClassLoader());\n \t} catch (Exception e) {\n\t \te.printStackTrace();\n \t}\n\t}\n\t}\n\n对应的输出如下：\n\n\tD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\n\tsun.misc.Launcher$AppClassLoader@197d257\n\t\n（说明：当前类路径默认的含有的一个条目就是工程的输出目录）\n\n测试二：\n\n将当前工程输出目录下的…/classloader/test/bean/TestBean.class打包进test.jar剪贴到< Java_Runtime_Home >/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下：\n\nD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\nsun.misc.Launcher$ExtClassLoader@7259da\n\n对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。\n\n测试三：\n\n将test.jar拷贝一份到< Java_Runtime_Home >/lib下，运行测试代码，输出如下：\n\nD:\"DEMO\"dev\"Study\"ClassLoaderTest\"bin\n\nsun.misc.Launcher$ExtClassLoader@7259da\n\n测试三和测试二输出结果一致。那就是说，放置到< Java_Runtime_Home >/lib目录下的TestBean对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载< Java_Runtime_Home >/lib存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除< Java_Runtime_Home >/lib/ext目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有ClassNotFoundException异常抛出。有关这个问题，大家可以在java.lang.ClassLoader中的loadClass(String name, boolean resolve)方法中设置相应断点运行测试三进行调试，会发现findBootstrapClass0()会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（sun.misc.Launcher$ExtClassLoader），这一点可以通过JDT中变量视图查看验证。\n\n(5)被不同的ClassLoader加载的两个类之间有什么限制和不同?\n\n现在我们来看一下一个现象：\n\n在eclipse里面我是这样做的：\n\nOneCls.java\n\n\tpackage org.corey.one;\n\timport org.corey.two.TwoCls;\n\tpublic class OneCls {\n\t public OneCls() {\n\t System.out.println();\n  \t TwoCls two = new TwoCls();\n \t two.say();\n \t}\n\t}\n\t\nTwoCls.java\n\n\tpackage org.corey.two;\n\tpublic class TwoCls {\n \n\t public void say() {\n\t  System.out.println(\"i am two\");\n\t }\n\t}\n\t\nDemo.java:\n\n\tpackage org.corey.Demo;\n\timport org.corey.one.OneCls;\n\tpublic class Demo {\n\t /**\n \t * @param args\n \t */\n \tpublic static void main(String[] args) {\n \t OneCls one=new OneCls();\n \t}\n\t}\n\t\n在这里，我们来仔细看下，one引用了two，demo引用了one，这是三个类都是由AppClassLoader加载的；运行正常；\n\n把OneCls打成jar包，放在lib/ext路径下面，然后在工程里面引入这个jar包；运行：异常，这是因为：\n\nDemo是由AppClassLoader载入，委托给双亲加载失败后，由AppClassLoader加载，而加载OneCls的时候，委托给双亲，被ExtClassLoader加载成功，但是在载入OneCls的时候，同时引用了TwoCls,但是ExtClassLoader引用TwoCls失败，但是他只会委托给双亲，而不会委托给AppClassLoader这个儿子，所以会出现异常；\n\n\\3. 奇怪的隔离性\n\n我们不难发现，图2中的类装载器AA和AB， AB和BB，AA和B等等位于不同分支下，他们之间没有父子关系，我不知道如何定义这种关系，姑且称他们位于不同分支下。两个位于不同分支的类装载器具有隔离性，这种隔离性使得在分别使用它们装载同一个类，也会在内存中出现两个Class类的实例。因为被具有隔离性的类装载器装载的类不会共享内存空间，使得使用一个类装载器不可能完成的任务变得可以轻而易举，例如类的静态变量可能同时拥有多个值（虽然好像作用不大），因为就算是被装载类的同一静态变量，它们也将被保存不同的内存空间，又例如程序需要使用某些包，但又不希望被程序另外一些包所使用，很简单，编写自定义的类装载器。类装载器的这种隔离性在许多大型的软件应用和服务程序得到了很好的应用。下面是同一个类静态变量为不同值的例子。\n\npackage test;\npublic class A {\n  public static void main( String[] args ) {\n    try {\n      //定义两个类装载器\n      MyClassLoader aa= new MyClassLoader();\n      MyClassLoader bb = new MyClassLoader();\n      //用类装载器aa装载testb.B类\n      Class clazz=aa.loadClass(\"testb. B\");\n      Constructor constructor= \n        clazz.getConstructor(new Class[]{Integer.class});\n      Object object = \n     constructor.newInstance(new Object[]{new Integer(1)});\n      Method method = \n     clazz.getDeclaredMethod(\"printB\",new Class[0]);\n      //用类装载器bb装载testb.B类\n      Class clazz2=bb.loadClass(\"testb. B\");\n      Constructor constructor2 = \n        clazz2.getConstructor(new Class[]{Integer.class});\n      Object object2 = \n     constructor2.newInstance(new Object[]{new Integer(2)});\n      Method method2 = \n     clazz2.getDeclaredMethod(\"printB\",new Class[0]);\n      //显示test.B中的静态变量的值 \n      method.invoke( object,new Object[0]);\n      method2.invoke( object2,new Object[0]);\n    } catch ( Exception e ) {\n      e.printStackTrace();\n    }\n  }\n}\n \n//Class B 必须位于MyClassLoader的查找范围内，\n//而不应该在MyClassLoader的父类装载器的查找范围内。\npackage testb;\npublic class B {\n    static int b ;\n    public B(Integer testb) {\n        b = testb.intValue();\n    }\n    public void printB() {\n        System.out.print(\"my static field b is \", b);\n    }\n}\n \npublic class MyClassLoader extends URLClassLoader{\n  private static File file = new File(\"c://classes \");\n  //该路径存放着class B，但是没有class A\n  public MyClassLoader() {\n    super(getUrl());\n  }\n  public static URL[] getUrl() {\n    try {\n      return new URL[]{file.toURL()};\n    } catch ( MalformedURLException e ) {\n      return new URL[0];\n    }\n  }\n}\n程序的运行结果为：\nmy static field b is 1\nmy static field b is 2\n程序的结果非常有意思，从编程者的角度，我们甚至可以把不在同一个分支的类装载器看作不同的java虚拟机，因为它们彼此觉察不到对方的存在。程序在使用具有分支的类装载的体系结构时要非常小心，弄清楚每个类装载器的类查找范围，尽量避免父类装载器和子类装载器的类查找范围中有相同类名的类（包括包名和类名），下面这个例子就是用来说明这种情况可能带来的问题。\n \n(6) 类如何被装载及类被装载的方式(转自Java类装载体系中的隔离性  作者：盛戈歆)\n在java2中，JVM是如何装载类的呢，可以分为两种类型，一种是隐式的类装载，一种式显式的类装载。\n2.1 隐式的类装载\n隐式的类装载是编码中最常用得方式：\nA b = new A();\n如果程序运行到这段代码时还没有A类，那么JVM会请求装载当前类的类装器来装载类。问题来了，我把代码弄得复杂一点点，但依旧没有任何难度，请思考JVM得装载次序：\npackage test;\nPublic class A{\n    public void static main(String args[]){\n        B b ＝ new B();\n    }\n}\nclass B{C c;}\nclass C{}\n揭晓答案，类装载的次序为A->B，而类C根本不会被JVM理会,先不要惊讶，仔细想想，这不正是我们最需要得到的结果。我们仔细了解一下JVM装载顺序。当使用Java A命令运行A类时，JVM会首先要求类路径类装载器(AppClassLoader)装载A类，但是这时只装载A，不会装载A中出现的其他类(B类)，接着它会调用A中的main函数，直到运行语句b ＝ new B()时，JVM发现必须装载B类程序才能继续运行，于是类路径类装载器会去装载B类，虽然我们可以看到B中有有C类的声明，但是并不是实际的执行语句，所以并不去装载C类，也就是说JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。\n2.2 显式的类装载\n使用显示的类装载方法很多，我们都装载类test.A为例。\n使用Class类的forName方法。它可以指定装载器，也可以使用装载当前类的装载器。例如：\nClass.forName(\"test.A\");\n它的效果和\nClass.forName(\"test.A\",true,this.getClass().getClassLoader());\n是一样的。\n使用类路径类装载装载.\nClassLoader.getSystemClassLoader().loadClass(\"test.A\");\n使用当前进程上下文的使用的类装载器进行装载，这种装载类的方法常常被有着复杂类装载体系结构的系统所使用。\nThread.currentThread().getContextClassLoader().loadClass(\"test.A\")\n使用自定义的类装载器装载类\npublic class MyClassLoader extends URLClassLoader{\npublic MyClassLoader() {\n        super(new URL[0]);\n    }\n}\nMyClassLoader myClassLoader = new MyClassLoader();\nmyClassLoader.loadClass(\"test.A\");\nMyClassLoader继承了URLClassLoader类，这是JDK核心包中的类装载器，在没有指定父类装载器的情况下，类路径类装载器就是它的父类装载器，MyClassLoader并没有增加类的查找范围，因此它和类路径装载器有相同的效果。\n \n(7)ClassLoader的一些方法实现的功能：\n方法 loadClass\n \n \nClassLoader.loadClass() 是 ClassLoader 的入口点。其特征如下：\n\nClass loadClass( String name, boolean resolve ); name 参数指定了 JVM 需要的类的名称，该名称以包表示法表示，如 Foo 或 java.lang.Object。\nresolve 参数告诉方法是否需要解析类。在准备执行类之前，应考虑类解析。并不总是需要解析。如果 JVM 只需要知道该类是否存在或找出该类的超类，那么就不需要解析。\n在 Java 版本 1.1 和以前的版本中，loadClass 方法是创建定制的 ClassLoader 时唯一需要覆盖的方法。（Java 2 中 ClassLoader 的变动提供了关于 Java 1.2 中 findClass() 方法的信息。）\n \n\n方法 defineClass\n\ndefineClass 方法是 ClassLoader 的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class 对象。原始数组包含如从文件系统或网络装入的数据。\ndefineClass 管理 JVM 的许多复杂、神秘和倚赖于实现的方面 -- 它把字节码分析成运行时数据结构、校验有效性等等。不必担心，您无需亲自编写它。事实上，即使您想要这么做也不能覆盖它，因为它已被标记成最终的。\n你可以看见native标记，知道defineClass是一个jni调用的方法，是由c++实现数据到内存的加载的；\n \n\n方法 findSystemClass\n\nfindSystemClass 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。（Java 2 中 ClassLoader 的变动提供了关于 Java 版本 1.2 这个过程变动的详细信息。）\n对于定制的 ClassLoader，只有在尝试其它方法装入类之后，再使用 findSystemClass。原因很简单：ClassLoader 是负责执行装入类的特殊步骤，不是负责所有类。例如，即使 ClassLoader 从远程的 Web 站点装入了某些类，仍然需要在本地机器上装入大量的基本 Java 库。而这些类不是我们所关心的，所以要 JVM 以缺省方式装入它们：从本地文件系统。这就是 findSystemClass 的用途。\n其工作流程如下：\n\n请求定制的 ClassLoader 装入类。 \n检查远程 Web 站点，查看是否有所需要的类。 \n如果有，那么好；抓取这个类，完成任务。 \n如果没有，假定这个类是在基本 Java 库中，那么调用 findSystemClass，使它从文件系统装入该类。 \n在大多数定制 ClassLoaders 中，首先调用 findSystemClass 以节省在本地就可以装入的许多 Java 库类而要在远程 Web 站点上查找所花的时间。然而，正如，在下一章节所看到的，直到确信能自动编译我们的应用程序代码时，才让 JVM 从本地文件系统装入类。\n \n\n方法 resolveClass\n正如前面所提到的，可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值。\n方法 findLoadedClass\nfindLoadedClass 充当一个缓存：当请求 loadClass 装入类时，它调用该方法来查看ClassLoader 是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法。\n\n三．命名空间及其作用\n每个类装载器有自己的命名空间，命名空间由所有以此装载器为创始类装载器的类组成。不同命名空间的两个类是不可见的，但只要得到类所对应的Class对象的reference，还是可以访问另一命名空间的类。\n \n例2演示了一个命名空间的类如何使用另一命名空间的类。在例子中，LoaderSample2由系统类装载器装载，LoaderSample3由自定义的装载器loader负责装载，两个类不在同一命名空间，但LoaderSample2得到了LoaderSample3所对应的Class对象的reference，所以它可以访问LoaderSampl3中公共的成员(如age)。\n例2不同命名空间的类的访问\n\n/\\*LoaderSample2.java*/\n\n\timport  java.net. * ;\n\timport  java.lang.reflect. * ;\n\tpublic   class  LoaderSample2 {\n     public   static   void  main(String[] args) {\n         try  {\n            String path  =  System.getProperty( \" user.dir \" );\n            URL[] us  =  { new  URL( \" file:// \"   +  path  +   \" /sub/ \" )};\n            ClassLoader loader  =   new  URLClassLoader(us);\n            Class c  =  loader.loadClass( \" LoaderSample3 \" );\n            Object o  =  c.newInstance();\n            Field f  =  c.getField( \" age \" );\n             int  age  =  f.getInt(o);\n            System.out.println( \" age is  \"   +  age);\n        }  catch  (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\t}\n\n/\\*sub/Loadersample3.java*/\n\n\tpublic   class  LoaderSample3 {\n     static  {\n        System.out.println( \" LoaderSample3 loaded \" );\n    }\n     public   int  age  =   30 ;\n\t}\n\t\n编译：javac LoaderSample2.java; javac sub/LoaderSample3.java\n\n运行：java LoaderSample2\n\nLoaderSample3 loaded\n\nage is 30\n\n从运行结果中可以看出，在类LoaderSample2中可以创建处于另一命名空间的类LoaderSample3中的对象并可以访问其公共成员age。\n\n运行时包(runtime package)\n\n由同一类装载器定义装载的属于相同包的类组成了运行时包，决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看的定义类装载器是否相同。只有属于同一运行时包的类才能互相访问包可见的类和成员。这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。假设用户自己定义了一个类java.lang.Yes，并用用户自定义的类装载器装载，由于java.lang.Yes和核心类库java.lang.*由不同的装载器装载，它们属于不同的运行时包，所以java.lang.Yes不能访问核心类库java.lang中类的包可见的成员。\n\n(7)有关ClassLoader的重载\n\n  扩展ClassLoader方法\n  \n我们目的是从本地文件系统使用我们实现的类装载器装载一个类。为了创建自己的类装载器我们应该扩展ClassLoader类，这是一个抽象类。我们创建一个FileClassLoader extends ClassLoader。我们需要覆盖ClassLoader中的findClass(String name)方法，这个方法通过类的名字而得到一个Class对象。\n\n     \tpublic  Class findClass(String name)    {\n         byte [] data  =  loadClassData(name);\n         return  defineClass(name, data,  0 , data.length);\n    \t}\n\n   我们还应该提供一个方法loadClassData(String name)，通过类的名称返回class文件的字节数组。然后使用ClassLoader提供的defineClass()方法我们就可以返回Class对象了。\n     \n     public   byte [] loadClassData(String name)    {\n        FileInputStream fis  =   null ;\n         byte [] data  =   null ;\n         try  {\n            fis  =   new  FileInputStream( new  File(drive  +  name  +  fileType));\n            ByteArrayOutputStream baos  =   new  ByteArrayOutputStream();\n             int  ch  =   0 ;\n             while  ((ch  =  fis.read())  !=   - 1 )  {\n                baos.write(ch);              \n            }\n            data  =  baos.toByteArray();\n        }  catch  (IOException e)  {\n            e.printStackTrace();\n        }       \n         return  data;\n    }","slug":"【转】由osgi引出的classLoader的大总结（整理理解ClassLoader）","published":1,"updated":"2017-06-21T09:03:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj486x74t00027k26jarbuauu","content":"<p>转载请注明出处（corey）<br>最近在研究osgi，在osgi里面里面有个很重要的东西，就是ClassLoader，所以，在网上搜集了一些资料，整理一下，<br>并加入了自己的一些理解；</p>\n<p>(1)jvm的装载过程以及装载原理<br>所谓装载就是寻找一个类或是一个接口的二进制形式并用该二进制形式来构造代表这个类或是这个接口的class对象的过程，<br>其中类或接口的名称是给定了的。当然名称也可以通过计算得到，但是更常见的是通过搜索源代码经过编译器编译后所得到<br>的二进制形式来构造。 </p>\n<p>在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，<br>其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：</p>\n<p>　　装载：查找和导入类或接口的二进制数据；<br>　　<br>　　链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；<br>　　<br>　　校验：检查导入类或接口的二进制数据的正确性；<br>　　<br>　　准备：给类的静态变量分配并初始化存储空间；<br>　　<br>　　解析：将符号引用转成直接引用；<br>　　<br>　　初始化：激活类的静态变量的初始化Java代码和静态Java代码块。<br>　　<br>(2)：java中的类是什么？</p>\n<p>一个类代表要执行的代码，而数据则表示其相关状态。状态时常改变，而代码则不会。当我们将一个特定的状态与一个类相对应起来，也就意味着将一个类事例化。尽管相同的类对应的实例其状态千差万别，但其本质都对应着同一段代码。在JAVA中，一个类通常有着一个.class文件，但也有例外。在JAVA的运行时环境中（Java runtime），每一个类都有一个以第一类(first-class)的Java对象所表现出现的代码，其是java.lang.Class的实例。我们编译一个JAVA文件，编译器都会嵌入一个public, static, final修饰的类型为java.lang.Class，名称为class的域变量在其字节码文件中。因为使用了public修饰，我们可以采用如下的形式对其访问：<br>java.lang.Class klass = Myclass.class;</p>\n<p>一旦一个类被载入JVM中，同一个类就不会被再次载入了（切记，同一个类）。这里存在一个问题就是什么是“同一个类”？正如一个对象有一个具体的状态，即标识，一个对象始终和其代码(类)相关联。同理，载入JVM的类也有一个具体的标识，我们接下来看。</p>\n<p>在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识。因此，如果一个名为Pg的包中，有一个名为Cl的类，被类加载器KlassLoader的一个实例kl1加载，Cl的实例，即C1.class在JVM中表示为(Cl, Pg, kl1)。这意味着两个类加载器的实例(Cl, Pg, kl1) 和 (Cl, Pg, kl2)是不同的，被它们所加载的类也因此完全不同，互不兼容的。那么在JVM中到底有多少种类加载器的实例？下一节我们揭示答案。</p>\n<p>(3)：java的几种ClassLoader：</p>\n<p>在java中，我们可以取得这么以下三个ClassLoader类：</p>\n<p>一．    ClassLoader基本概念</p>\n<p>1．ClassLoader分类</p>\n<p>类装载器是用来把类(class)装载进JVM的。</p>\n<p>JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。</p>\n<p>JVM在运行时会产生三个ClassLoader:Bootstrap ClassLoader、Extension ClassLoader和AppClassLoader。Bootstrap是用C++编写的，我们在Java中看不到它,是null,是JVM自带的类装载器，用来装载核心类库，如java.lang.*等。</p>\n<p>AppClassLoader的Parent是ExtClassLoader，而ExtClassLoader的Parent为Bootstrap ClassLoader。</p>\n<p>Java提供了抽象类ClassLoader，所有用户自定义类装载器都实例化自ClassLoader的子类。 System Class Loader是一个特殊的用户自定义类装载器，由JVM的实现者提供，在编程者不特别指定装载器的情况下默认装载用户类。系统类装载器可以通过</p>\n<p>ClassLoader.getSystemClassLoader() 方法得到。</p>\n<p>例1，测试你所使用的JVM的ClassLoader</p>\n<pre><code>/*LoaderSample1.java*/\npublic   class  LoaderSample1 {\n public   static   void  main(String[] args) {\n    Class c;\n    ClassLoader cl;\n    cl  =  ClassLoader.getSystemClassLoader();\n    System.out.println(cl);\n     while  (cl  !=   null ) {\n        cl  =  cl.getParent();\n        System.out.println(cl);\n    }\n     try  {\n        c  =  Class.forName( &quot; java.lang.Object &quot; );\n        cl  =  c.getClassLoader();\n        System.out.println( &quot; java.lang.Object&apos;s loader is  &quot;   +  cl);\n        c  =  Class.forName( &quot; LoaderSample1 &quot; );\n        cl  =  c.getClassLoader();\n        System.out.println( &quot; LoaderSample1&apos;s loader is  &quot;   +  cl);\n    }  catch  (Exception e) {\n        e.printStackTrace();\n    }\n}\n}\n</code></pre><p>在我的机器上(Sun Java 1.4.2)的运行结果</p>\n<p>sun.misc.Launcher$AppClassLoader@1a0c10f<br>sun.misc.Launcher$ExtClassLoader@e2eec8<br>null<br>java.lang.Object’s loader is null<br>LoaderSample1’s loader is sun.misc.Launcher$AppClassLoader@1a0c10f</p>\n<p>第一行表示，系统类装载器实例化自类</p>\n<p>sun.misc.Launcher$AppClassLoader</p>\n<p>第二行表示，系统类装载器的parent实例化自类</p>\n<p>sun.misc.Launcher$ExtClassLoader</p>\n<p>第三行表示，系统类装载器parent的parent为bootstrap</p>\n<p>第四行表示，核心类java.lang.Object是由bootstrap装载的</p>\n<p>第五行表示，用户类LoaderSample1是由系统类装载器装载的</p>\n<p>注意，我们清晰的看见这个三个ClassLoader类之间的父子关系（不是继承关系），父子关系在ClassLoader的实现中有一个ClassLoader类型的属性，我们可以在自己实现自定义的ClassLoader的时候初始化定义，而这三个系统定义的ClassLoader的父子关系分别是</p>\n<p>AppClassLoader——————》（Parent）ExtClassLoader——————————》（parent）BootClassLoader(null c++实现)</p>\n<p>系统为什么要分别指定这么多的ClassLoader类呢？</p>\n<p>答案在于因为java是动态加载类的，这样的话，可以节省内存，用到什么加载什么，就是这个道理，然而系统在运行的时候并不知道我们这个应用与需要加载些什么类，那么，就采用这种逐级加载的方式</p>\n<p>(1)首先加载核心API，让系统最基本的运行起来</p>\n<p>(2)加载扩展类</p>\n<p>(3)加载用户自定义的类</p>\n<pre><code>package org.corey.clsloader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport sun.net.spi.nameservice.dns.DNSNameService;\npublic class ClsLoaderDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\nSystem.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));\nSystem.out.println(System.getProperty(&quot;java.ext.dirs&quot;));\n System.out.println(System.getProperty(&quot;java.class.path&quot;));\n }\n}\n</code></pre><p>程序结果为：</p>\n<p>E:/MyEclipse 6.0/jre/lib/rt.jar;E:/MyEclipse 6.0/jre/lib/i18n.jar;E:/MyEclipse 6.0/jre/lib/sunrsasign.jar;E:/MyEclipse 6.0/jre/lib/jsse.jar;E:/MyEclipse 6.0/jre/lib/jce.jar;E:/MyEclipse 6.0/jre/lib/charsets.jar;E:/MyEclipse 6.0/jre/classes</p>\n<p>E:/MyEclipse 6.0/jre/lib/ext</p>\n<p>E:/workspace/ClassLoaderDemo/bin</p>\n<p>在上面的结果中，你可以清晰看见三个ClassLoader分别加载类的路径；也知道为什么我们在编写程序的时候，要把用到的jar包放在工程的classpath下面啦，也知道我们为什么可以不加载java.lang.<em>包啦！其中java.lang.</em>就在rt.jar包中；</p>\n<p>(4)ClassLoader的加载机制：</p>\n<p>现在我们设计这种一下Demo:</p>\n<pre><code>package java.net;\npublic class URL {\n private String path;\n public URL(String path) {\n  this.path = path;\n }\n public String toString() {\n  return this.path + &quot; new Path&quot;;\n }\n}\n\npackage java.net;\nimport java.net.*;\npublic class TheSameClsDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  URL url = new URL(&quot;http://www.baidu.com&quot;);\n  System.out.println(url.toString());\n }\n}\n</code></pre><p>在这种情况下，系统会提示我们出现异常，因为我们有两个相同的类，一个是真正的URL，一个是我在上面实现的伪类；出现异常是正常的，因为你想想，如果我们在执行一个applet的时候，程序自己实现了一个String的类覆盖了我们虚拟机上面的真正的String类，那么在这个String里面，不怀好意的人可以任意的实现一些功能；这就造成极不安全的隐患；所以java采用了一种名为“双亲委托”的加载模式；</p>\n<p>以下是jdk源代码：</p>\n<pre><code>protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)\n throws ClassNotFoundException\n    {\n // First, check if the class has already been loaded\n Class c = findLoadedClass(name);\n if (c == null) {\n     try {\n  if (parent != null) {\n      c = parent.loadClass(name, false);\n  } else {\n      c = findBootstrapClass0(name);\n  }\n     } catch (ClassNotFoundException e) {\n     // If still not found, then invoke findClass in order\n     // to find the class.\n     c = findClass(name);\n     }\n }\n if (resolve) {\n     resolveClass(c);\n }\n     return c;\n}\n</code></pre><p>在上面的代码中，我们可以清晰的看见，我们调用一个ClassLoader加载程序的时候，这个ClassLoader会先调用设置好的parent ClassLoader来加载这个类，如果parent是null的话，则默认为Boot ClassLoader类，只有在parent没有找的情况下，自己才会加载，这就避免我们重写一些系统类，来破坏系统的安全；<br>再来看一个明显的例子：</p>\n<pre><code>package org.corey;\npublic class MyCls{\n private String name;\n\n public MyCls(){\n\n }\n public MyCls(String name){\n this.name=name;\n }\n\n public void say(){\n     System.out.println(this.name); \n }\n}\n</code></pre><p>把上面这个MyCls类打成jar包，丢进ext classLoader的加载路径；<br>然后写出main类：</p>\n<pre><code>package org.corey.clsloader;\nimport org.corey.MyCls;\npublic class TheSameClsDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  MyCls myClsOb=new MyCls(&quot;name&quot;);\n myClsOb.say(); \n System.out.println(MyCls.class.getClassLoader());\n System.out.println(System.getProperty(&quot;java.class.path&quot;));\n System.out.println(TheSameClsDemo.class.getClassLoader());\n }\n}\n</code></pre><p>并且把MyCls类加入biild-path里面方便引用；<br>结果是：</p>\n<p>name<br>sun.misc.Launcher$ExtClassLoader@16930e2</p>\n<p>E:/workspace/ClassLoaderDemo/bin;E:/MyEclipse 6.0/jre/lib/ext/corey.jar</p>\n<p>sun.misc.Launcher$AppClassLoader@7259da</p>\n<p>从上面的例子可以清晰的看出ClassLoader之间的这种双亲委托加载模式；</p>\n<p>再来看下一个例子(摘自<a href=\"http://bbs.cnw.com.cn/viewthread.php?tid=95389\" target=\"_blank\" rel=\"external\">http://bbs.cnw.com.cn/viewthread.php?tid=95389</a>)</p>\n<p>下面我们就来看一个综合的例子。首先在eclipse中建立一个简单的java应用工程，然后写一个简单的JavaBean如下：</p>\n<pre><code>package classloader.test.bean;\n\npublicclass TestBean {\n\n\npublic TestBean() {}\n\n}\n</code></pre><p>在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下：<br>测试一：</p>\n<pre><code>publicclass ClassLoaderTest {\n publicstaticvoid main(String[] args) {\n try {\n //查看当前系统类路径中包含的路径条目\nSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\n//调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean\nClass typeLoaded = Class.forName(&quot;classloader.test.bean.TestBean&quot;);\n//查看被加载的TestBean类型是被那个类加载器加载的\nSystem.out.println(typeLoaded.getClassLoader());\n } catch (Exception e) {\n     e.printStackTrace();\n }\n}\n}\n</code></pre><p>对应的输出如下：</p>\n<pre><code>D:&quot;DEMO&quot;dev&quot;Study&quot;ClassLoaderTest&quot;bin\n\nsun.misc.Launcher$AppClassLoader@197d257\n</code></pre><p>（说明：当前类路径默认的含有的一个条目就是工程的输出目录）</p>\n<p>测试二：</p>\n<p>将当前工程输出目录下的…/classloader/test/bean/TestBean.class打包进test.jar剪贴到&lt; Java_Runtime_Home &gt;/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下：</p>\n<p>D:”DEMO”dev”Study”ClassLoaderTest”bin</p>\n<p>sun.misc.Launcher$ExtClassLoader@7259da</p>\n<p>对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。</p>\n<p>测试三：</p>\n<p>将test.jar拷贝一份到&lt; Java_Runtime_Home &gt;/lib下，运行测试代码，输出如下：</p>\n<p>D:”DEMO”dev”Study”ClassLoaderTest”bin</p>\n<p>sun.misc.Launcher$ExtClassLoader@7259da</p>\n<p>测试三和测试二输出结果一致。那就是说，放置到&lt; Java_Runtime_Home &gt;/lib目录下的TestBean对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载&lt; Java_Runtime_Home &gt;/lib存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除&lt; Java_Runtime_Home &gt;/lib/ext目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有ClassNotFoundException异常抛出。有关这个问题，大家可以在java.lang.ClassLoader中的loadClass(String name, boolean resolve)方法中设置相应断点运行测试三进行调试，会发现findBootstrapClass0()会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（sun.misc.Launcher$ExtClassLoader），这一点可以通过JDT中变量视图查看验证。</p>\n<p>(5)被不同的ClassLoader加载的两个类之间有什么限制和不同?</p>\n<p>现在我们来看一下一个现象：</p>\n<p>在eclipse里面我是这样做的：</p>\n<p>OneCls.java</p>\n<pre><code>package org.corey.one;\nimport org.corey.two.TwoCls;\npublic class OneCls {\n public OneCls() {\n System.out.println();\n   TwoCls two = new TwoCls();\n  two.say();\n }\n}\n</code></pre><p>TwoCls.java</p>\n<pre><code>package org.corey.two;\npublic class TwoCls {\n\n public void say() {\n  System.out.println(&quot;i am two&quot;);\n }\n}\n</code></pre><p>Demo.java:</p>\n<pre><code>package org.corey.Demo;\nimport org.corey.one.OneCls;\npublic class Demo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  OneCls one=new OneCls();\n }\n}\n</code></pre><p>在这里，我们来仔细看下，one引用了two，demo引用了one，这是三个类都是由AppClassLoader加载的；运行正常；</p>\n<p>把OneCls打成jar包，放在lib/ext路径下面，然后在工程里面引入这个jar包；运行：异常，这是因为：</p>\n<p>Demo是由AppClassLoader载入，委托给双亲加载失败后，由AppClassLoader加载，而加载OneCls的时候，委托给双亲，被ExtClassLoader加载成功，但是在载入OneCls的时候，同时引用了TwoCls,但是ExtClassLoader引用TwoCls失败，但是他只会委托给双亲，而不会委托给AppClassLoader这个儿子，所以会出现异常；</p>\n<p>\\3. 奇怪的隔离性</p>\n<p>我们不难发现，图2中的类装载器AA和AB， AB和BB，AA和B等等位于不同分支下，他们之间没有父子关系，我不知道如何定义这种关系，姑且称他们位于不同分支下。两个位于不同分支的类装载器具有隔离性，这种隔离性使得在分别使用它们装载同一个类，也会在内存中出现两个Class类的实例。因为被具有隔离性的类装载器装载的类不会共享内存空间，使得使用一个类装载器不可能完成的任务变得可以轻而易举，例如类的静态变量可能同时拥有多个值（虽然好像作用不大），因为就算是被装载类的同一静态变量，它们也将被保存不同的内存空间，又例如程序需要使用某些包，但又不希望被程序另外一些包所使用，很简单，编写自定义的类装载器。类装载器的这种隔离性在许多大型的软件应用和服务程序得到了很好的应用。下面是同一个类静态变量为不同值的例子。</p>\n<p>package test;<br>public class A {<br>  public static void main( String[] args ) {<br>    try {<br>      //定义两个类装载器<br>      MyClassLoader aa= new MyClassLoader();<br>      MyClassLoader bb = new MyClassLoader();<br>      //用类装载器aa装载testb.B类<br>      Class clazz=aa.loadClass(“testb. B”);<br>      Constructor constructor=<br>        clazz.getConstructor(new Class[]{Integer.class});<br>      Object object =<br>     constructor.newInstance(new Object[]{new Integer(1)});<br>      Method method =<br>     clazz.getDeclaredMethod(“printB”,new Class[0]);<br>      //用类装载器bb装载testb.B类<br>      Class clazz2=bb.loadClass(“testb. B”);<br>      Constructor constructor2 =<br>        clazz2.getConstructor(new Class[]{Integer.class});<br>      Object object2 =<br>     constructor2.newInstance(new Object[]{new Integer(2)});<br>      Method method2 =<br>     clazz2.getDeclaredMethod(“printB”,new Class[0]);<br>      //显示test.B中的静态变量的值<br>      method.invoke( object,new Object[0]);<br>      method2.invoke( object2,new Object[0]);<br>    } catch ( Exception e ) {<br>      e.printStackTrace();<br>    }<br>  }<br>}</p>\n<p>//Class B 必须位于MyClassLoader的查找范围内，<br>//而不应该在MyClassLoader的父类装载器的查找范围内。<br>package testb;<br>public class B {<br>    static int b ;<br>    public B(Integer testb) {<br>        b = testb.intValue();<br>    }<br>    public void printB() {<br>        System.out.print(“my static field b is “, b);<br>    }<br>}</p>\n<p>public class MyClassLoader extends URLClassLoader{<br>  private static File file = new File(“c://classes “);<br>  //该路径存放着class B，但是没有class A<br>  public MyClassLoader() {<br>    super(getUrl());<br>  }<br>  public static URL[] getUrl() {<br>    try {<br>      return new URL[]{file.toURL()};<br>    } catch ( MalformedURLException e ) {<br>      return new URL[0];<br>    }<br>  }<br>}<br>程序的运行结果为：<br>my static field b is 1<br>my static field b is 2<br>程序的结果非常有意思，从编程者的角度，我们甚至可以把不在同一个分支的类装载器看作不同的java虚拟机，因为它们彼此觉察不到对方的存在。程序在使用具有分支的类装载的体系结构时要非常小心，弄清楚每个类装载器的类查找范围，尽量避免父类装载器和子类装载器的类查找范围中有相同类名的类（包括包名和类名），下面这个例子就是用来说明这种情况可能带来的问题。</p>\n<p>(6) 类如何被装载及类被装载的方式(转自Java类装载体系中的隔离性  作者：盛戈歆)<br>在java2中，JVM是如何装载类的呢，可以分为两种类型，一种是隐式的类装载，一种式显式的类装载。<br>2.1 隐式的类装载<br>隐式的类装载是编码中最常用得方式：<br>A b = new A();<br>如果程序运行到这段代码时还没有A类，那么JVM会请求装载当前类的类装器来装载类。问题来了，我把代码弄得复杂一点点，但依旧没有任何难度，请思考JVM得装载次序：<br>package test;<br>Public class A{<br>    public void static main(String args[]){<br>        B b ＝ new B();<br>    }<br>}<br>class B{C c;}<br>class C{}<br>揭晓答案，类装载的次序为A-&gt;B，而类C根本不会被JVM理会,先不要惊讶，仔细想想，这不正是我们最需要得到的结果。我们仔细了解一下JVM装载顺序。当使用Java A命令运行A类时，JVM会首先要求类路径类装载器(AppClassLoader)装载A类，但是这时只装载A，不会装载A中出现的其他类(B类)，接着它会调用A中的main函数，直到运行语句b ＝ new B()时，JVM发现必须装载B类程序才能继续运行，于是类路径类装载器会去装载B类，虽然我们可以看到B中有有C类的声明，但是并不是实际的执行语句，所以并不去装载C类，也就是说JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。<br>2.2 显式的类装载<br>使用显示的类装载方法很多，我们都装载类test.A为例。<br>使用Class类的forName方法。它可以指定装载器，也可以使用装载当前类的装载器。例如：<br>Class.forName(“test.A”);<br>它的效果和<br>Class.forName(“test.A”,true,this.getClass().getClassLoader());<br>是一样的。<br>使用类路径类装载装载.<br>ClassLoader.getSystemClassLoader().loadClass(“test.A”);<br>使用当前进程上下文的使用的类装载器进行装载，这种装载类的方法常常被有着复杂类装载体系结构的系统所使用。<br>Thread.currentThread().getContextClassLoader().loadClass(“test.A”)<br>使用自定义的类装载器装载类<br>public class MyClassLoader extends URLClassLoader{<br>public MyClassLoader() {<br>        super(new URL[0]);<br>    }<br>}<br>MyClassLoader myClassLoader = new MyClassLoader();<br>myClassLoader.loadClass(“test.A”);<br>MyClassLoader继承了URLClassLoader类，这是JDK核心包中的类装载器，在没有指定父类装载器的情况下，类路径类装载器就是它的父类装载器，MyClassLoader并没有增加类的查找范围，因此它和类路径装载器有相同的效果。</p>\n<p>(7)ClassLoader的一些方法实现的功能：<br>方法 loadClass</p>\n<p>ClassLoader.loadClass() 是 ClassLoader 的入口点。其特征如下：</p>\n<p>Class loadClass( String name, boolean resolve ); name 参数指定了 JVM 需要的类的名称，该名称以包表示法表示，如 Foo 或 java.lang.Object。<br>resolve 参数告诉方法是否需要解析类。在准备执行类之前，应考虑类解析。并不总是需要解析。如果 JVM 只需要知道该类是否存在或找出该类的超类，那么就不需要解析。<br>在 Java 版本 1.1 和以前的版本中，loadClass 方法是创建定制的 ClassLoader 时唯一需要覆盖的方法。（Java 2 中 ClassLoader 的变动提供了关于 Java 1.2 中 findClass() 方法的信息。）</p>\n<p>方法 defineClass</p>\n<p>defineClass 方法是 ClassLoader 的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class 对象。原始数组包含如从文件系统或网络装入的数据。<br>defineClass 管理 JVM 的许多复杂、神秘和倚赖于实现的方面 – 它把字节码分析成运行时数据结构、校验有效性等等。不必担心，您无需亲自编写它。事实上，即使您想要这么做也不能覆盖它，因为它已被标记成最终的。<br>你可以看见native标记，知道defineClass是一个jni调用的方法，是由c++实现数据到内存的加载的；</p>\n<p>方法 findSystemClass</p>\n<p>findSystemClass 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。（Java 2 中 ClassLoader 的变动提供了关于 Java 版本 1.2 这个过程变动的详细信息。）<br>对于定制的 ClassLoader，只有在尝试其它方法装入类之后，再使用 findSystemClass。原因很简单：ClassLoader 是负责执行装入类的特殊步骤，不是负责所有类。例如，即使 ClassLoader 从远程的 Web 站点装入了某些类，仍然需要在本地机器上装入大量的基本 Java 库。而这些类不是我们所关心的，所以要 JVM 以缺省方式装入它们：从本地文件系统。这就是 findSystemClass 的用途。<br>其工作流程如下：</p>\n<p>请求定制的 ClassLoader 装入类。<br>检查远程 Web 站点，查看是否有所需要的类。<br>如果有，那么好；抓取这个类，完成任务。<br>如果没有，假定这个类是在基本 Java 库中，那么调用 findSystemClass，使它从文件系统装入该类。<br>在大多数定制 ClassLoaders 中，首先调用 findSystemClass 以节省在本地就可以装入的许多 Java 库类而要在远程 Web 站点上查找所花的时间。然而，正如，在下一章节所看到的，直到确信能自动编译我们的应用程序代码时，才让 JVM 从本地文件系统装入类。</p>\n<p>方法 resolveClass<br>正如前面所提到的，可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值。<br>方法 findLoadedClass<br>findLoadedClass 充当一个缓存：当请求 loadClass 装入类时，它调用该方法来查看ClassLoader 是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法。</p>\n<p>三．命名空间及其作用<br>每个类装载器有自己的命名空间，命名空间由所有以此装载器为创始类装载器的类组成。不同命名空间的两个类是不可见的，但只要得到类所对应的Class对象的reference，还是可以访问另一命名空间的类。</p>\n<p>例2演示了一个命名空间的类如何使用另一命名空间的类。在例子中，LoaderSample2由系统类装载器装载，LoaderSample3由自定义的装载器loader负责装载，两个类不在同一命名空间，但LoaderSample2得到了LoaderSample3所对应的Class对象的reference，所以它可以访问LoaderSampl3中公共的成员(如age)。<br>例2不同命名空间的类的访问</p>\n<p>/*LoaderSample2.java*/</p>\n<pre><code>import  java.net. * ;\nimport  java.lang.reflect. * ;\npublic   class  LoaderSample2 {\n public   static   void  main(String[] args) {\n     try  {\n        String path  =  System.getProperty( &quot; user.dir &quot; );\n        URL[] us  =  { new  URL( &quot; file:// &quot;   +  path  +   &quot; /sub/ &quot; )};\n        ClassLoader loader  =   new  URLClassLoader(us);\n        Class c  =  loader.loadClass( &quot; LoaderSample3 &quot; );\n        Object o  =  c.newInstance();\n        Field f  =  c.getField( &quot; age &quot; );\n         int  age  =  f.getInt(o);\n        System.out.println( &quot; age is  &quot;   +  age);\n    }  catch  (Exception e) {\n        e.printStackTrace();\n    }\n}\n}\n</code></pre><p>/*sub/Loadersample3.java*/</p>\n<pre><code>public   class  LoaderSample3 {\n static  {\n    System.out.println( &quot; LoaderSample3 loaded &quot; );\n}\n public   int  age  =   30 ;\n}\n</code></pre><p>编译：javac LoaderSample2.java; javac sub/LoaderSample3.java</p>\n<p>运行：java LoaderSample2</p>\n<p>LoaderSample3 loaded</p>\n<p>age is 30</p>\n<p>从运行结果中可以看出，在类LoaderSample2中可以创建处于另一命名空间的类LoaderSample3中的对象并可以访问其公共成员age。</p>\n<p>运行时包(runtime package)</p>\n<p>由同一类装载器定义装载的属于相同包的类组成了运行时包，决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看的定义类装载器是否相同。只有属于同一运行时包的类才能互相访问包可见的类和成员。这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。假设用户自己定义了一个类java.lang.Yes，并用用户自定义的类装载器装载，由于java.lang.Yes和核心类库java.lang.*由不同的装载器装载，它们属于不同的运行时包，所以java.lang.Yes不能访问核心类库java.lang中类的包可见的成员。</p>\n<p>(7)有关ClassLoader的重载</p>\n<p>  扩展ClassLoader方法</p>\n<p>我们目的是从本地文件系统使用我们实现的类装载器装载一个类。为了创建自己的类装载器我们应该扩展ClassLoader类，这是一个抽象类。我们创建一个FileClassLoader extends ClassLoader。我们需要覆盖ClassLoader中的findClass(String name)方法，这个方法通过类的名字而得到一个Class对象。</p>\n<pre><code> public  Class findClass(String name)    {\n byte [] data  =  loadClassData(name);\n return  defineClass(name, data,  0 , data.length);\n}\n</code></pre><p>   我们还应该提供一个方法loadClassData(String name)，通过类的名称返回class文件的字节数组。然后使用ClassLoader提供的defineClass()方法我们就可以返回Class对象了。</p>\n<pre><code> public   byte [] loadClassData(String name)    {\n    FileInputStream fis  =   null ;\n     byte [] data  =   null ;\n     try  {\n        fis  =   new  FileInputStream( new  File(drive  +  name  +  fileType));\n        ByteArrayOutputStream baos  =   new  ByteArrayOutputStream();\n         int  ch  =   0 ;\n         while  ((ch  =  fis.read())  !=   - 1 )  {\n            baos.write(ch);              \n        }\n        data  =  baos.toByteArray();\n    }  catch  (IOException e)  {\n        e.printStackTrace();\n    }       \n     return  data;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>转载请注明出处（corey）<br>最近在研究osgi，在osgi里面里面有个很重要的东西，就是ClassLoader，所以，在网上搜集了一些资料，整理一下，<br>并加入了自己的一些理解；</p>\n<p>(1)jvm的装载过程以及装载原理<br>所谓装载就是寻找一个类或是一个接口的二进制形式并用该二进制形式来构造代表这个类或是这个接口的class对象的过程，<br>其中类或接口的名称是给定了的。当然名称也可以通过计算得到，但是更常见的是通过搜索源代码经过编译器编译后所得到<br>的二进制形式来构造。 </p>\n<p>在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，<br>其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：</p>\n<p>　　装载：查找和导入类或接口的二进制数据；<br>　　<br>　　链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；<br>　　<br>　　校验：检查导入类或接口的二进制数据的正确性；<br>　　<br>　　准备：给类的静态变量分配并初始化存储空间；<br>　　<br>　　解析：将符号引用转成直接引用；<br>　　<br>　　初始化：激活类的静态变量的初始化Java代码和静态Java代码块。<br>　　<br>(2)：java中的类是什么？</p>\n<p>一个类代表要执行的代码，而数据则表示其相关状态。状态时常改变，而代码则不会。当我们将一个特定的状态与一个类相对应起来，也就意味着将一个类事例化。尽管相同的类对应的实例其状态千差万别，但其本质都对应着同一段代码。在JAVA中，一个类通常有着一个.class文件，但也有例外。在JAVA的运行时环境中（Java runtime），每一个类都有一个以第一类(first-class)的Java对象所表现出现的代码，其是java.lang.Class的实例。我们编译一个JAVA文件，编译器都会嵌入一个public, static, final修饰的类型为java.lang.Class，名称为class的域变量在其字节码文件中。因为使用了public修饰，我们可以采用如下的形式对其访问：<br>java.lang.Class klass = Myclass.class;</p>\n<p>一旦一个类被载入JVM中，同一个类就不会被再次载入了（切记，同一个类）。这里存在一个问题就是什么是“同一个类”？正如一个对象有一个具体的状态，即标识，一个对象始终和其代码(类)相关联。同理，载入JVM的类也有一个具体的标识，我们接下来看。</p>\n<p>在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识。因此，如果一个名为Pg的包中，有一个名为Cl的类，被类加载器KlassLoader的一个实例kl1加载，Cl的实例，即C1.class在JVM中表示为(Cl, Pg, kl1)。这意味着两个类加载器的实例(Cl, Pg, kl1) 和 (Cl, Pg, kl2)是不同的，被它们所加载的类也因此完全不同，互不兼容的。那么在JVM中到底有多少种类加载器的实例？下一节我们揭示答案。</p>\n<p>(3)：java的几种ClassLoader：</p>\n<p>在java中，我们可以取得这么以下三个ClassLoader类：</p>\n<p>一．    ClassLoader基本概念</p>\n<p>1．ClassLoader分类</p>\n<p>类装载器是用来把类(class)装载进JVM的。</p>\n<p>JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user-defined class loader)。</p>\n<p>JVM在运行时会产生三个ClassLoader:Bootstrap ClassLoader、Extension ClassLoader和AppClassLoader。Bootstrap是用C++编写的，我们在Java中看不到它,是null,是JVM自带的类装载器，用来装载核心类库，如java.lang.*等。</p>\n<p>AppClassLoader的Parent是ExtClassLoader，而ExtClassLoader的Parent为Bootstrap ClassLoader。</p>\n<p>Java提供了抽象类ClassLoader，所有用户自定义类装载器都实例化自ClassLoader的子类。 System Class Loader是一个特殊的用户自定义类装载器，由JVM的实现者提供，在编程者不特别指定装载器的情况下默认装载用户类。系统类装载器可以通过</p>\n<p>ClassLoader.getSystemClassLoader() 方法得到。</p>\n<p>例1，测试你所使用的JVM的ClassLoader</p>\n<pre><code>/*LoaderSample1.java*/\npublic   class  LoaderSample1 {\n public   static   void  main(String[] args) {\n    Class c;\n    ClassLoader cl;\n    cl  =  ClassLoader.getSystemClassLoader();\n    System.out.println(cl);\n     while  (cl  !=   null ) {\n        cl  =  cl.getParent();\n        System.out.println(cl);\n    }\n     try  {\n        c  =  Class.forName( &quot; java.lang.Object &quot; );\n        cl  =  c.getClassLoader();\n        System.out.println( &quot; java.lang.Object&apos;s loader is  &quot;   +  cl);\n        c  =  Class.forName( &quot; LoaderSample1 &quot; );\n        cl  =  c.getClassLoader();\n        System.out.println( &quot; LoaderSample1&apos;s loader is  &quot;   +  cl);\n    }  catch  (Exception e) {\n        e.printStackTrace();\n    }\n}\n}\n</code></pre><p>在我的机器上(Sun Java 1.4.2)的运行结果</p>\n<p>sun.misc.Launcher$AppClassLoader@1a0c10f<br>sun.misc.Launcher$ExtClassLoader@e2eec8<br>null<br>java.lang.Object’s loader is null<br>LoaderSample1’s loader is sun.misc.Launcher$AppClassLoader@1a0c10f</p>\n<p>第一行表示，系统类装载器实例化自类</p>\n<p>sun.misc.Launcher$AppClassLoader</p>\n<p>第二行表示，系统类装载器的parent实例化自类</p>\n<p>sun.misc.Launcher$ExtClassLoader</p>\n<p>第三行表示，系统类装载器parent的parent为bootstrap</p>\n<p>第四行表示，核心类java.lang.Object是由bootstrap装载的</p>\n<p>第五行表示，用户类LoaderSample1是由系统类装载器装载的</p>\n<p>注意，我们清晰的看见这个三个ClassLoader类之间的父子关系（不是继承关系），父子关系在ClassLoader的实现中有一个ClassLoader类型的属性，我们可以在自己实现自定义的ClassLoader的时候初始化定义，而这三个系统定义的ClassLoader的父子关系分别是</p>\n<p>AppClassLoader——————》（Parent）ExtClassLoader——————————》（parent）BootClassLoader(null c++实现)</p>\n<p>系统为什么要分别指定这么多的ClassLoader类呢？</p>\n<p>答案在于因为java是动态加载类的，这样的话，可以节省内存，用到什么加载什么，就是这个道理，然而系统在运行的时候并不知道我们这个应用与需要加载些什么类，那么，就采用这种逐级加载的方式</p>\n<p>(1)首先加载核心API，让系统最基本的运行起来</p>\n<p>(2)加载扩展类</p>\n<p>(3)加载用户自定义的类</p>\n<pre><code>package org.corey.clsloader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport sun.net.spi.nameservice.dns.DNSNameService;\npublic class ClsLoaderDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\nSystem.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));\nSystem.out.println(System.getProperty(&quot;java.ext.dirs&quot;));\n System.out.println(System.getProperty(&quot;java.class.path&quot;));\n }\n}\n</code></pre><p>程序结果为：</p>\n<p>E:/MyEclipse 6.0/jre/lib/rt.jar;E:/MyEclipse 6.0/jre/lib/i18n.jar;E:/MyEclipse 6.0/jre/lib/sunrsasign.jar;E:/MyEclipse 6.0/jre/lib/jsse.jar;E:/MyEclipse 6.0/jre/lib/jce.jar;E:/MyEclipse 6.0/jre/lib/charsets.jar;E:/MyEclipse 6.0/jre/classes</p>\n<p>E:/MyEclipse 6.0/jre/lib/ext</p>\n<p>E:/workspace/ClassLoaderDemo/bin</p>\n<p>在上面的结果中，你可以清晰看见三个ClassLoader分别加载类的路径；也知道为什么我们在编写程序的时候，要把用到的jar包放在工程的classpath下面啦，也知道我们为什么可以不加载java.lang.<em>包啦！其中java.lang.</em>就在rt.jar包中；</p>\n<p>(4)ClassLoader的加载机制：</p>\n<p>现在我们设计这种一下Demo:</p>\n<pre><code>package java.net;\npublic class URL {\n private String path;\n public URL(String path) {\n  this.path = path;\n }\n public String toString() {\n  return this.path + &quot; new Path&quot;;\n }\n}\n\npackage java.net;\nimport java.net.*;\npublic class TheSameClsDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  URL url = new URL(&quot;http://www.baidu.com&quot;);\n  System.out.println(url.toString());\n }\n}\n</code></pre><p>在这种情况下，系统会提示我们出现异常，因为我们有两个相同的类，一个是真正的URL，一个是我在上面实现的伪类；出现异常是正常的，因为你想想，如果我们在执行一个applet的时候，程序自己实现了一个String的类覆盖了我们虚拟机上面的真正的String类，那么在这个String里面，不怀好意的人可以任意的实现一些功能；这就造成极不安全的隐患；所以java采用了一种名为“双亲委托”的加载模式；</p>\n<p>以下是jdk源代码：</p>\n<pre><code>protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)\n throws ClassNotFoundException\n    {\n // First, check if the class has already been loaded\n Class c = findLoadedClass(name);\n if (c == null) {\n     try {\n  if (parent != null) {\n      c = parent.loadClass(name, false);\n  } else {\n      c = findBootstrapClass0(name);\n  }\n     } catch (ClassNotFoundException e) {\n     // If still not found, then invoke findClass in order\n     // to find the class.\n     c = findClass(name);\n     }\n }\n if (resolve) {\n     resolveClass(c);\n }\n     return c;\n}\n</code></pre><p>在上面的代码中，我们可以清晰的看见，我们调用一个ClassLoader加载程序的时候，这个ClassLoader会先调用设置好的parent ClassLoader来加载这个类，如果parent是null的话，则默认为Boot ClassLoader类，只有在parent没有找的情况下，自己才会加载，这就避免我们重写一些系统类，来破坏系统的安全；<br>再来看一个明显的例子：</p>\n<pre><code>package org.corey;\npublic class MyCls{\n private String name;\n\n public MyCls(){\n\n }\n public MyCls(String name){\n this.name=name;\n }\n\n public void say(){\n     System.out.println(this.name); \n }\n}\n</code></pre><p>把上面这个MyCls类打成jar包，丢进ext classLoader的加载路径；<br>然后写出main类：</p>\n<pre><code>package org.corey.clsloader;\nimport org.corey.MyCls;\npublic class TheSameClsDemo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  MyCls myClsOb=new MyCls(&quot;name&quot;);\n myClsOb.say(); \n System.out.println(MyCls.class.getClassLoader());\n System.out.println(System.getProperty(&quot;java.class.path&quot;));\n System.out.println(TheSameClsDemo.class.getClassLoader());\n }\n}\n</code></pre><p>并且把MyCls类加入biild-path里面方便引用；<br>结果是：</p>\n<p>name<br>sun.misc.Launcher$ExtClassLoader@16930e2</p>\n<p>E:/workspace/ClassLoaderDemo/bin;E:/MyEclipse 6.0/jre/lib/ext/corey.jar</p>\n<p>sun.misc.Launcher$AppClassLoader@7259da</p>\n<p>从上面的例子可以清晰的看出ClassLoader之间的这种双亲委托加载模式；</p>\n<p>再来看下一个例子(摘自<a href=\"http://bbs.cnw.com.cn/viewthread.php?tid=95389\" target=\"_blank\" rel=\"external\">http://bbs.cnw.com.cn/viewthread.php?tid=95389</a>)</p>\n<p>下面我们就来看一个综合的例子。首先在eclipse中建立一个简单的java应用工程，然后写一个简单的JavaBean如下：</p>\n<pre><code>package classloader.test.bean;\n\npublicclass TestBean {\n\n\npublic TestBean() {}\n\n}\n</code></pre><p>在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下：<br>测试一：</p>\n<pre><code>publicclass ClassLoaderTest {\n publicstaticvoid main(String[] args) {\n try {\n //查看当前系统类路径中包含的路径条目\nSystem.out.println(System.getProperty(&quot;java.class.path&quot;));\n//调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean\nClass typeLoaded = Class.forName(&quot;classloader.test.bean.TestBean&quot;);\n//查看被加载的TestBean类型是被那个类加载器加载的\nSystem.out.println(typeLoaded.getClassLoader());\n } catch (Exception e) {\n     e.printStackTrace();\n }\n}\n}\n</code></pre><p>对应的输出如下：</p>\n<pre><code>D:&quot;DEMO&quot;dev&quot;Study&quot;ClassLoaderTest&quot;bin\n\nsun.misc.Launcher$AppClassLoader@197d257\n</code></pre><p>（说明：当前类路径默认的含有的一个条目就是工程的输出目录）</p>\n<p>测试二：</p>\n<p>将当前工程输出目录下的…/classloader/test/bean/TestBean.class打包进test.jar剪贴到&lt; Java_Runtime_Home &gt;/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下：</p>\n<p>D:”DEMO”dev”Study”ClassLoaderTest”bin</p>\n<p>sun.misc.Launcher$ExtClassLoader@7259da</p>\n<p>对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。</p>\n<p>测试三：</p>\n<p>将test.jar拷贝一份到&lt; Java_Runtime_Home &gt;/lib下，运行测试代码，输出如下：</p>\n<p>D:”DEMO”dev”Study”ClassLoaderTest”bin</p>\n<p>sun.misc.Launcher$ExtClassLoader@7259da</p>\n<p>测试三和测试二输出结果一致。那就是说，放置到&lt; Java_Runtime_Home &gt;/lib目录下的TestBean对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载&lt; Java_Runtime_Home &gt;/lib存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除&lt; Java_Runtime_Home &gt;/lib/ext目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有ClassNotFoundException异常抛出。有关这个问题，大家可以在java.lang.ClassLoader中的loadClass(String name, boolean resolve)方法中设置相应断点运行测试三进行调试，会发现findBootstrapClass0()会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（sun.misc.Launcher$ExtClassLoader），这一点可以通过JDT中变量视图查看验证。</p>\n<p>(5)被不同的ClassLoader加载的两个类之间有什么限制和不同?</p>\n<p>现在我们来看一下一个现象：</p>\n<p>在eclipse里面我是这样做的：</p>\n<p>OneCls.java</p>\n<pre><code>package org.corey.one;\nimport org.corey.two.TwoCls;\npublic class OneCls {\n public OneCls() {\n System.out.println();\n   TwoCls two = new TwoCls();\n  two.say();\n }\n}\n</code></pre><p>TwoCls.java</p>\n<pre><code>package org.corey.two;\npublic class TwoCls {\n\n public void say() {\n  System.out.println(&quot;i am two&quot;);\n }\n}\n</code></pre><p>Demo.java:</p>\n<pre><code>package org.corey.Demo;\nimport org.corey.one.OneCls;\npublic class Demo {\n /**\n  * @param args\n  */\n public static void main(String[] args) {\n  OneCls one=new OneCls();\n }\n}\n</code></pre><p>在这里，我们来仔细看下，one引用了two，demo引用了one，这是三个类都是由AppClassLoader加载的；运行正常；</p>\n<p>把OneCls打成jar包，放在lib/ext路径下面，然后在工程里面引入这个jar包；运行：异常，这是因为：</p>\n<p>Demo是由AppClassLoader载入，委托给双亲加载失败后，由AppClassLoader加载，而加载OneCls的时候，委托给双亲，被ExtClassLoader加载成功，但是在载入OneCls的时候，同时引用了TwoCls,但是ExtClassLoader引用TwoCls失败，但是他只会委托给双亲，而不会委托给AppClassLoader这个儿子，所以会出现异常；</p>\n<p>\\3. 奇怪的隔离性</p>\n<p>我们不难发现，图2中的类装载器AA和AB， AB和BB，AA和B等等位于不同分支下，他们之间没有父子关系，我不知道如何定义这种关系，姑且称他们位于不同分支下。两个位于不同分支的类装载器具有隔离性，这种隔离性使得在分别使用它们装载同一个类，也会在内存中出现两个Class类的实例。因为被具有隔离性的类装载器装载的类不会共享内存空间，使得使用一个类装载器不可能完成的任务变得可以轻而易举，例如类的静态变量可能同时拥有多个值（虽然好像作用不大），因为就算是被装载类的同一静态变量，它们也将被保存不同的内存空间，又例如程序需要使用某些包，但又不希望被程序另外一些包所使用，很简单，编写自定义的类装载器。类装载器的这种隔离性在许多大型的软件应用和服务程序得到了很好的应用。下面是同一个类静态变量为不同值的例子。</p>\n<p>package test;<br>public class A {<br>  public static void main( String[] args ) {<br>    try {<br>      //定义两个类装载器<br>      MyClassLoader aa= new MyClassLoader();<br>      MyClassLoader bb = new MyClassLoader();<br>      //用类装载器aa装载testb.B类<br>      Class clazz=aa.loadClass(“testb. B”);<br>      Constructor constructor=<br>        clazz.getConstructor(new Class[]{Integer.class});<br>      Object object =<br>     constructor.newInstance(new Object[]{new Integer(1)});<br>      Method method =<br>     clazz.getDeclaredMethod(“printB”,new Class[0]);<br>      //用类装载器bb装载testb.B类<br>      Class clazz2=bb.loadClass(“testb. B”);<br>      Constructor constructor2 =<br>        clazz2.getConstructor(new Class[]{Integer.class});<br>      Object object2 =<br>     constructor2.newInstance(new Object[]{new Integer(2)});<br>      Method method2 =<br>     clazz2.getDeclaredMethod(“printB”,new Class[0]);<br>      //显示test.B中的静态变量的值<br>      method.invoke( object,new Object[0]);<br>      method2.invoke( object2,new Object[0]);<br>    } catch ( Exception e ) {<br>      e.printStackTrace();<br>    }<br>  }<br>}</p>\n<p>//Class B 必须位于MyClassLoader的查找范围内，<br>//而不应该在MyClassLoader的父类装载器的查找范围内。<br>package testb;<br>public class B {<br>    static int b ;<br>    public B(Integer testb) {<br>        b = testb.intValue();<br>    }<br>    public void printB() {<br>        System.out.print(“my static field b is “, b);<br>    }<br>}</p>\n<p>public class MyClassLoader extends URLClassLoader{<br>  private static File file = new File(“c://classes “);<br>  //该路径存放着class B，但是没有class A<br>  public MyClassLoader() {<br>    super(getUrl());<br>  }<br>  public static URL[] getUrl() {<br>    try {<br>      return new URL[]{file.toURL()};<br>    } catch ( MalformedURLException e ) {<br>      return new URL[0];<br>    }<br>  }<br>}<br>程序的运行结果为：<br>my static field b is 1<br>my static field b is 2<br>程序的结果非常有意思，从编程者的角度，我们甚至可以把不在同一个分支的类装载器看作不同的java虚拟机，因为它们彼此觉察不到对方的存在。程序在使用具有分支的类装载的体系结构时要非常小心，弄清楚每个类装载器的类查找范围，尽量避免父类装载器和子类装载器的类查找范围中有相同类名的类（包括包名和类名），下面这个例子就是用来说明这种情况可能带来的问题。</p>\n<p>(6) 类如何被装载及类被装载的方式(转自Java类装载体系中的隔离性  作者：盛戈歆)<br>在java2中，JVM是如何装载类的呢，可以分为两种类型，一种是隐式的类装载，一种式显式的类装载。<br>2.1 隐式的类装载<br>隐式的类装载是编码中最常用得方式：<br>A b = new A();<br>如果程序运行到这段代码时还没有A类，那么JVM会请求装载当前类的类装器来装载类。问题来了，我把代码弄得复杂一点点，但依旧没有任何难度，请思考JVM得装载次序：<br>package test;<br>Public class A{<br>    public void static main(String args[]){<br>        B b ＝ new B();<br>    }<br>}<br>class B{C c;}<br>class C{}<br>揭晓答案，类装载的次序为A-&gt;B，而类C根本不会被JVM理会,先不要惊讶，仔细想想，这不正是我们最需要得到的结果。我们仔细了解一下JVM装载顺序。当使用Java A命令运行A类时，JVM会首先要求类路径类装载器(AppClassLoader)装载A类，但是这时只装载A，不会装载A中出现的其他类(B类)，接着它会调用A中的main函数，直到运行语句b ＝ new B()时，JVM发现必须装载B类程序才能继续运行，于是类路径类装载器会去装载B类，虽然我们可以看到B中有有C类的声明，但是并不是实际的执行语句，所以并不去装载C类，也就是说JVM按照运行时的有效执行语句，来决定是否需要装载新类，从而装载尽可能少的类，这一点和编译类是不相同的。<br>2.2 显式的类装载<br>使用显示的类装载方法很多，我们都装载类test.A为例。<br>使用Class类的forName方法。它可以指定装载器，也可以使用装载当前类的装载器。例如：<br>Class.forName(“test.A”);<br>它的效果和<br>Class.forName(“test.A”,true,this.getClass().getClassLoader());<br>是一样的。<br>使用类路径类装载装载.<br>ClassLoader.getSystemClassLoader().loadClass(“test.A”);<br>使用当前进程上下文的使用的类装载器进行装载，这种装载类的方法常常被有着复杂类装载体系结构的系统所使用。<br>Thread.currentThread().getContextClassLoader().loadClass(“test.A”)<br>使用自定义的类装载器装载类<br>public class MyClassLoader extends URLClassLoader{<br>public MyClassLoader() {<br>        super(new URL[0]);<br>    }<br>}<br>MyClassLoader myClassLoader = new MyClassLoader();<br>myClassLoader.loadClass(“test.A”);<br>MyClassLoader继承了URLClassLoader类，这是JDK核心包中的类装载器，在没有指定父类装载器的情况下，类路径类装载器就是它的父类装载器，MyClassLoader并没有增加类的查找范围，因此它和类路径装载器有相同的效果。</p>\n<p>(7)ClassLoader的一些方法实现的功能：<br>方法 loadClass</p>\n<p>ClassLoader.loadClass() 是 ClassLoader 的入口点。其特征如下：</p>\n<p>Class loadClass( String name, boolean resolve ); name 参数指定了 JVM 需要的类的名称，该名称以包表示法表示，如 Foo 或 java.lang.Object。<br>resolve 参数告诉方法是否需要解析类。在准备执行类之前，应考虑类解析。并不总是需要解析。如果 JVM 只需要知道该类是否存在或找出该类的超类，那么就不需要解析。<br>在 Java 版本 1.1 和以前的版本中，loadClass 方法是创建定制的 ClassLoader 时唯一需要覆盖的方法。（Java 2 中 ClassLoader 的变动提供了关于 Java 1.2 中 findClass() 方法的信息。）</p>\n<p>方法 defineClass</p>\n<p>defineClass 方法是 ClassLoader 的主要诀窍。该方法接受由原始字节组成的数组并把它转换成 Class 对象。原始数组包含如从文件系统或网络装入的数据。<br>defineClass 管理 JVM 的许多复杂、神秘和倚赖于实现的方面 – 它把字节码分析成运行时数据结构、校验有效性等等。不必担心，您无需亲自编写它。事实上，即使您想要这么做也不能覆盖它，因为它已被标记成最终的。<br>你可以看见native标记，知道defineClass是一个jni调用的方法，是由c++实现数据到内存的加载的；</p>\n<p>方法 findSystemClass</p>\n<p>findSystemClass 方法从本地文件系统装入文件。它在本地文件系统中寻找类文件，如果存在，就使用 defineClass 将原始字节转换成 Class 对象，以将该文件转换成类。当运行 Java 应用程序时，这是 JVM 正常装入类的缺省机制。（Java 2 中 ClassLoader 的变动提供了关于 Java 版本 1.2 这个过程变动的详细信息。）<br>对于定制的 ClassLoader，只有在尝试其它方法装入类之后，再使用 findSystemClass。原因很简单：ClassLoader 是负责执行装入类的特殊步骤，不是负责所有类。例如，即使 ClassLoader 从远程的 Web 站点装入了某些类，仍然需要在本地机器上装入大量的基本 Java 库。而这些类不是我们所关心的，所以要 JVM 以缺省方式装入它们：从本地文件系统。这就是 findSystemClass 的用途。<br>其工作流程如下：</p>\n<p>请求定制的 ClassLoader 装入类。<br>检查远程 Web 站点，查看是否有所需要的类。<br>如果有，那么好；抓取这个类，完成任务。<br>如果没有，假定这个类是在基本 Java 库中，那么调用 findSystemClass，使它从文件系统装入该类。<br>在大多数定制 ClassLoaders 中，首先调用 findSystemClass 以节省在本地就可以装入的许多 Java 库类而要在远程 Web 站点上查找所花的时间。然而，正如，在下一章节所看到的，直到确信能自动编译我们的应用程序代码时，才让 JVM 从本地文件系统装入类。</p>\n<p>方法 resolveClass<br>正如前面所提到的，可以不完全地（不带解析）装入类，也可以完全地（带解析）装入类。当编写我们自己的 loadClass 时，可以调用 resolveClass，这取决于 loadClass 的 resolve 参数的值。<br>方法 findLoadedClass<br>findLoadedClass 充当一个缓存：当请求 loadClass 装入类时，它调用该方法来查看ClassLoader 是否已装入这个类，这样可以避免重新装入已存在类所造成的麻烦。应首先调用该方法。</p>\n<p>三．命名空间及其作用<br>每个类装载器有自己的命名空间，命名空间由所有以此装载器为创始类装载器的类组成。不同命名空间的两个类是不可见的，但只要得到类所对应的Class对象的reference，还是可以访问另一命名空间的类。</p>\n<p>例2演示了一个命名空间的类如何使用另一命名空间的类。在例子中，LoaderSample2由系统类装载器装载，LoaderSample3由自定义的装载器loader负责装载，两个类不在同一命名空间，但LoaderSample2得到了LoaderSample3所对应的Class对象的reference，所以它可以访问LoaderSampl3中公共的成员(如age)。<br>例2不同命名空间的类的访问</p>\n<p>/*LoaderSample2.java*/</p>\n<pre><code>import  java.net. * ;\nimport  java.lang.reflect. * ;\npublic   class  LoaderSample2 {\n public   static   void  main(String[] args) {\n     try  {\n        String path  =  System.getProperty( &quot; user.dir &quot; );\n        URL[] us  =  { new  URL( &quot; file:// &quot;   +  path  +   &quot; /sub/ &quot; )};\n        ClassLoader loader  =   new  URLClassLoader(us);\n        Class c  =  loader.loadClass( &quot; LoaderSample3 &quot; );\n        Object o  =  c.newInstance();\n        Field f  =  c.getField( &quot; age &quot; );\n         int  age  =  f.getInt(o);\n        System.out.println( &quot; age is  &quot;   +  age);\n    }  catch  (Exception e) {\n        e.printStackTrace();\n    }\n}\n}\n</code></pre><p>/*sub/Loadersample3.java*/</p>\n<pre><code>public   class  LoaderSample3 {\n static  {\n    System.out.println( &quot; LoaderSample3 loaded &quot; );\n}\n public   int  age  =   30 ;\n}\n</code></pre><p>编译：javac LoaderSample2.java; javac sub/LoaderSample3.java</p>\n<p>运行：java LoaderSample2</p>\n<p>LoaderSample3 loaded</p>\n<p>age is 30</p>\n<p>从运行结果中可以看出，在类LoaderSample2中可以创建处于另一命名空间的类LoaderSample3中的对象并可以访问其公共成员age。</p>\n<p>运行时包(runtime package)</p>\n<p>由同一类装载器定义装载的属于相同包的类组成了运行时包，决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看的定义类装载器是否相同。只有属于同一运行时包的类才能互相访问包可见的类和成员。这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。假设用户自己定义了一个类java.lang.Yes，并用用户自定义的类装载器装载，由于java.lang.Yes和核心类库java.lang.*由不同的装载器装载，它们属于不同的运行时包，所以java.lang.Yes不能访问核心类库java.lang中类的包可见的成员。</p>\n<p>(7)有关ClassLoader的重载</p>\n<p>  扩展ClassLoader方法</p>\n<p>我们目的是从本地文件系统使用我们实现的类装载器装载一个类。为了创建自己的类装载器我们应该扩展ClassLoader类，这是一个抽象类。我们创建一个FileClassLoader extends ClassLoader。我们需要覆盖ClassLoader中的findClass(String name)方法，这个方法通过类的名字而得到一个Class对象。</p>\n<pre><code> public  Class findClass(String name)    {\n byte [] data  =  loadClassData(name);\n return  defineClass(name, data,  0 , data.length);\n}\n</code></pre><p>   我们还应该提供一个方法loadClassData(String name)，通过类的名称返回class文件的字节数组。然后使用ClassLoader提供的defineClass()方法我们就可以返回Class对象了。</p>\n<pre><code> public   byte [] loadClassData(String name)    {\n    FileInputStream fis  =   null ;\n     byte [] data  =   null ;\n     try  {\n        fis  =   new  FileInputStream( new  File(drive  +  name  +  fileType));\n        ByteArrayOutputStream baos  =   new  ByteArrayOutputStream();\n         int  ch  =   0 ;\n         while  ((ch  =  fis.read())  !=   - 1 )  {\n            baos.write(ch);              \n        }\n        data  =  baos.toByteArray();\n    }  catch  (IOException e)  {\n        e.printStackTrace();\n    }       \n     return  data;\n}\n</code></pre>"},{"title":"笔试题20170620","date":"2017-06-20T05:24:02.000Z","_content":"\nQuestions\n---\rQuestion 1)\rWhich of the following lines will compile without warning or error.\n\n\r1) float f=1.3;\r\r2) char c=\"a\";\r\r3) byte b=257;\r\r4) boolean b=null;\r\r5) int i=10;\n\n---\rQuestion 2)\n\rWhat will happen if you try to compile and run the following code\r\r\tpublic class MyClass {\r    public static void main(String arguments[]) {\r        amethod(arguments);\r    }\r    public void amethod(String[] arguments) {\r        System.out.println(arguments);\r        System.out.println(arguments[1]);\r\t} \n\t}\n\r1) error Can't make static reference to void amethod.\n\r2) error method main not correct\n\r3) error array must include parameter\n\r4) amethod must be declared with String\n\n---\rQuestion 3)\n\rWhich of the following will compile without error\n\r1)\r\r\timport java.awt.*;\r\tpackage Mypackage;\r\tclass Myclass {}\n\r2)\r\r\tpackage MyPackage;\r\timport java.awt.*;\r\tclass MyClass{}\n\r3)\n\n\t/*This is a comment */\r\tpackage MyPackage;\r\timport java.awt.*;\r\tclass MyClass{}\n\n---\rQuestion 4)\n\rA byte can be of what size\n\r1) -128 to 127\n\r2) (-2 power 8 )-1 to 2 power 8\n\r3) -255 to 256\n\r4)depends on the particular implementation of the Java Virtual machine\r\r---\rQuestion 5)\n\rWhat will be printed out if this code is run with the following command line?\r\r\tjava myprog good morning\n\t\r\tpublic class myprog{\n\tpublic static void main(String argv[])\n    {\r        System.out.println(argv[2]);\r    }\r\t}\r              \n1) myprog\n\r2) good\n\r3) morning\n\r4) Exception raised: \"java.lang.ArrayIndexOutOfBoundsException: 2\"\n\n---\rQuestion 6)\n\rWhich of the following are keywords or reserved words in Java?\r\r1) if\r\r2) then\r\r3) goto\r\r4) while\r\r5) case\n\n---\n\rQuestion 7)\n\rWhich of the following are legal identifiers\r\r1) 2variable\r\r2) variable2\r\r3) _whatavariable\r\r4) \\_3\\_\r\r5) $anothervar\r\r6) #myvar\n\n---\n\rQuestion 8)\r\rWhat will happen when you compile and run the following code?\r\r\tpublic class MyClass{\r\t static int i;\r \tpublic static void main(String argv[]){\r \tSystem.out.println(i);\r \t}\r\t}\r                     \n1) Error Variable i may not have been initialized\r\r2) null\r\r3) 1\r\r4) 0\n\n---\rQuestion 9)\n\rWhat will happen if you try to compile and run the following code?\r\r\tpublic class Q {\r \t\tpublic static void main(String argv[]){\r \t\tint anar[]=new int[]{1,2,3};\r \t\tSystem.out.println(anar[1]);\r \t\t}\r\t}\n\r1) 1\n\r2) Error anar is referenced before it is initialized\n\r3) 2\n\r4) Error: size of array must be defined\n\n---\rQuestion 10)\n\rWhat will happen if you try to compile and run the following code?\r\r\tpublic class Q {\r \tpublic static void main(String argv[]){\r \t\tint anar[]=new int[5];\r \t\tSystem.out.println(anar[0]);\r \t}\r\t}\n\r1) Error: anar is referenced before it is initialized\r\r2) null\r\r3) 0\r\r4) 5\r \n ---                    \nQuestion 11)\n\rWhat will be the result of attempting to compile and run the following code?\n\r\tabstract class MineBase {\r \tabstract void amethod();\r \tstatic int i;\r\t}\r\r\tpublic class Mine extends MineBase {\r \tpublic static void main(String argv[]){\r \tint[] ar=new int[5];\r \tfor(i=0;i < ar.length;i++)\r \tSystem.out.println(ar[i]);\r\t} }\n\r1) a sequence of 5 0's will be printed\n\r2) Error: ar is used before it is initialized\n\r3) Error Mine must be declared abstract\n\r4) IndexOutOfBoundes Error\n\n---\rQuestion 12)\n\rWhat will be printed out if you attempt to compile and run the following code ?\n\r\tint i=1;\r \tswitch (i) {\r \tcase 0:\r \tSystem.out.println(\"zero\");\r \tbreak;\r \tcase 1:\r \tSystem.out.println(\"one\");\r \tcase 2:\r \tSystem.out.println(\"two\");\r \tdefault:\r \tSystem.out.println(\"default\");\r \t}\n \r1) one\n\r2) one, default\r       \n3) one, two, default\n\r4) default\n\n---\rQuestion 13)\n\rWhat will be printed out if you attempt to compile and run the following code?\n\r\tint i=9;\r\tswitch (i) {\r \tdefault:\r \tSystem.out.println(\"default\");\r \tcase 0:\r \tSystem.out.println(\"zero\");\r \tbreak;\r \tcase 1:\r \tSystem.out.println(\"one\");\r \tcase 2:\r \tSystem.out.println(\"two\");\r\t}\n\r1) default\n\r2) default, zero\n\r3) error default clause not defined\n\r4) no output displayed\n\n---\rQuestion 14)\n\rWhich of the following lines of code will compile without error\r\r1)\r\r\tint i=0;\r\tif(i) {\r \t\tSystem.out.println(\"Hello\");\r \t}\n \r2)\n\t\n\tboolean b=true;\r\tboolean b2=true;             \n\tif(b==b2) {\r \t\tSystem.out.println(\"So true\");\r \t}\n \r3)\r\r\tint i=1;\r\tint j=2;\r\tif(i==1|| j==2)\r\t System.out.println(\"OK\");\n \r4)\r\r\tint i=1;\r\tint j=2;\r\tif(i==1 &| j==2)\r \tSystem.out.println(\"OK\");\n \n ---\rQuestion 15)\n\rWhat will be output if you try to compile and run the following code, but there is no file called Hello.txt in the current directory?.\n\r\timport java.io.*;\r\tpublic class Mine {\r   \t public static void main(String argv[]){\r        \tMine m=new Mine();\r        \tSystem.out.println(m.amethod());\r   \t }\r    \tpublic int amethod() {\r        try {\r            FileInputStream dis=new FileInputStream(\"Hello.txt\");\r        }catch (FileNotFoundException fne) {\r            System.out.println(\"No such file found\");\r            return -1;\r        }catch(IOException ioe) {\r        } finally{\r            System.out.println(\"Doing finally\");\r        }\r\treturn 0; }       \n\t}\n\r1) No such file found\n\r2 No such file found ,-1\n\r3) No such file found, Doing finally, -1\n\r4) 0\n\n---\rQuestion 16)\n\rWhich of the following statements are true?\n\r1) Methods cannot be overriden to be more private\n\r2) static methods cannot be overloaded\n\r3) private methods cannot be overloaded\n\r4) An overloaded method cannot throw exceptions not checked in the base class\n\n---\rQuestion 17)\n\rWhat will happen if you attempt to compile and run the following code?\r\r\t\tclass Base {}\r\t\tclass Sub extends Base {}\r\t\tclass Sub2 extends Base {}\r\t\tpublic class CEx{\r   \t\t public static void main(String argv[]){\r        \tBase b=new Base();\r        \tSub s=(Sub) b;\r\t\t\t} \n\t\t}\n\n\r1) Compile and run without error\n\r2) Compile time Exception\n\r3) Runtime Exception\r\r---\rQuestion 18)\n\rWhich of the following statements are true?\r                     \n1) System.out.println( -1 >>> 2);will output a result larger than 10 \n\n2) System.out.println( -1 >>> 2); will output a positive number\r\r3) System.out.println( 2 >> 1); will output the number 1\r\r4) System.out.println( 1 <<< 2); will output the number 4\r\r---\rQuestion 19)\r\rWhat will happen when you attempt to compile and run the following code?\n\n\tpublic class Tux extends Thread{\r        static String sName = \"vandeleur\";\r        public static void main(String argv[]){\r        Tux t = new Tux();\r        t.piggy(sName);\r        System.out.println(sName);\r        }\r        public void piggy(String sName){\r                sName = sName + \" wiggy\";\r        start();\r        }\r        public void run(){\r        for(int i=0;i  <  4; i++){\r                sName = sName + \" \" + i;\r\t} }\r\t}\n\r1) Compile time error\r\r2) Compilation and output of \"vandeleur wiggy\"\r\r3) Compilation and output of \"vandeleur wiggy 0 1 2 3\"\r\r4) Compilation and output of either \"vandeleur\", \"vandeleur 0\", \"vandeleur 0 1\" \"vandaleur 0 1 2\" or \"vandaleur 0 1 2 3\"\r\r---\rQuestion 20)\r              \nWhat will be displayed when you attempt to compile and run the following code\r\r\t//Code start\r\timport java.awt.*;\r\tpublic class Butt extends Frame{\r    \tpublic static void main(String argv[]){\r        Butt MyBut=new Butt();\r\t} \n\tButt(){\r        Button HelloBut=new Button(\"Hello\");\r        Button ByeBut=new Button(\"Bye\");\r        add(HelloBut);\r        add(ByeBut);\r        setSize(300,300);\r        setVisible(true);\r   \t}\r\t}\r\t//Code end`\n\r1) Two buttons side by side occupying all of the frame, Hello on the left and Bye on the right\r\r2) One button occupying the entire frame saying Hello\r\r3) One button occupying the entire frame saying Bye\r\r4) Two buttons at the top of the frame one saying Hello the other saying Bye\r\r---\rQuestion 21)\r\rWhat will be output by the following code?\r\r\tpublic class MyFor{\r    public static void main(String argv[]){\r\tint i;\r\tint j; \n\t\touter:\r        for (i=1;i <3;i++)\r            inner:\r        for(j=1; j<3; j++) {\r            if (j==2)\r       continue outer;\r\tSystem.out.println(\"Value for i=\" + i + \" Value for j=\" +j);\r\t} }\r\t}\r\r1) Value for i=1 Value for j=1\r\r2) Value for i=2 Value for j=1\r\r3) Value for i=2 Value for j=2\r\r4) Value for i=3 Value for j=1\r\r---\rQuestion 22)\r\rWhich statement is true of the following code?\r\r\tpublic class Agg{\r\tpublic static void main(String argv[]){\r        Agg a = new Agg();\r        a.go();\r        }\r        public void go(){\r               DSRoss ds1 = new DSRoss(\"one\");\r               ds1.start();\r\t} }\r\tclass DSRoss extends Thread{\r\tprivate String sTname=\"\";\r\tDSRoss(String s){\r\t\tsTname = s;\r\t}\r\tpublic void run(){\r        notwait();\r        System.out.println(\"finished\");\r       }\r\tpublic void notwait(){\r        while(true){\r               try{\r\tSystem.out.println(\"waiting\");\r\twait();\r\t}catch(InterruptedException ie){}\r\t\tSystem.out.println(sTname);\n               notifyAll();\r\t} }\n\r1) It will cause a compile time error\r\r2) Compilation and output of \"waiting\"\r\r3) Compilation and output of \"waiting\" followed by \"finished\"\r\r4) Runtime error, an exception will be thrown\r\r---\nQuestion 23)\r\rWhich of the following methods can be legally inserted in place of the comment //Method Here ?\r\r\tclass Base{\r \tpublic void amethod(int i) { }\r\t}\r\tpublic class Scope extends Base{\r \tpublic static void main(String argv[]){\r \t}\r \t//Method Here\r\t}\r\r1) void amethod(int i) throws Exception {}\r\r2) void amethod(long i)throws Exception {}\r\r3) void amethod(long i){}\r\r4) public void amethod(int i) throws Exception {}\r\r---\nQuestion 24)\r\rWhich of the following will output -4.0\r\r1) System.out.println(Math.floor(-4.7));\r\r2) System.out.println(Math.round(-4.7));\r}\r              \n3) System.out.println(Math.ceil(-4.7));\r\r4) System.out.println(Math.min(-4.7));\r\r---\rQuestion 25)\r\rWhat will happen if you attempt to compile and run the following code?\r\r\tInteger ten=new Integer(10);\r\tLong nine=new Long (9);\r\tSystem.out.println(ten + nine);\r\tint i=1;\r\tSystem.out.println(i + ten);\r\r1) 19 followed by 20\r\r2) 19 followed by 11\r\r3) Compile time error\r\r4) 10 followed by 1\r\r---\nQuestion 26)\r\rIf you run the code below, what gets printed out?\r\r\tString s=new String(\"Bicycle\");\r\tint iBegin=1;\r\tchar iEnd=3;\r\tSystem.out.println(s.substring(iBegin,iEnd));\r\r1) Bic\r\r2) ic\r\r3) icy\r\r4) error: no method matching substring(int,char)\r\r---\nQuestion 27)\r\rIf you wanted to find out where the position of the letter v (ie return 2) in the string s containing \"Java\", which of the following could you use?\r                     \n1) mid(2,s);\r\r2) charAt(2);\r\r3) s.indexOf('v');\r\r4) indexOf(s,'v');\r\r---\nQuestion 28)\rGiven the following declarations\r\r\r\tString s1=new String(\"Hello\")\r\tString s2=new String(\"there\");\r\tString s3=new String();\r\rWhich of the following are legal operations?\r\r1) s3=s1 + s2;\r\r2) s3=s1-s2;\r\r3) s3=s1 & s2;\r\r4) s3=s1 && s2\r\r---\nQuestion 29)\r\rWhat is the result of the following operation?\r\r\tSystem.out.println(4 | 3);\r\r1) 6\r\r2) 0\r\r3) 1\r\r4) 7\r\r---\nQuestion 30)\r\r\tpublic class MyClass1 {\r\tpublic static void main(String argv[]){ }\r\t/*Modifier at XX */ class MyInner {}\r\t}\r\rWhat modifiers would be legal at XX in the above code?\r                     \n1) public\r\r2) private\r\r3) static\r\r4) friend\n\n---\rQuestion 31)\n\rWhat will happen when you attempt to compile and run the following code?\n\r\tpublic class Holt extends Thread{\r        private String sThreadName;\r        public static void main(String argv[]){\r                Holt h = new Holt();\r\th.go(); }\r\tHolt(){}\r\tHolt(String s){\r        sThreadName = s;\r\t}\r\tpublic String getThreadName(){\r        return sThreadName;\r\t}\r\tpublic void go(){\r        Holt first = new Holt(\"first\");\r       }\r\tfirst.start();\r\tHolt second = new Holt(\"second\");\r\tsecond.start();\r\tpublic void start(){\r        for(int i = 0; i < 2; i ++){\r\t}\r\t} }\r\ttry{\r\t\tSystem.out.println(getThreadName() +i);\r\t\tThread.sleep(100);\r                        } catch(InterruptedException\r\t\te){System.out.println(e.getMessage());}\n\n1) Compile time error\n\r2) Output of first0, second0, first0, second1\n\r3) Output of first0, first1, second0, second1\n\r4) Runtime error\n\r---\nQuestion 32)\r\rAn Applet has its Layout Manager set to the default of FlowLayout. What code would be correct to change to another Layout Manager.\r\r1) setLayoutManager(new GridLayout());\r\r2) setLayout(new GridLayout(2,2));\r\r3) setGridLayout(2,2);\r\r4) setBorderLayout();\r\r---\nQuestion 33)\r\rWhat will happen when you attempt to compile and run the following code?.\r\r\tclass Background implements Runnable{\r        int i=0;\r               public int run(){\r                        while(true){\r                                  return 1;\r         }//End run\r\t}//End class\r\ti++;\r\tSystem.out.println(\"i=\"+i);\r\t} //End while\n\r1) It will compile and the run method will print out the increasing value of i.\n\r2) It will compile and calling start will print out the increasing value of i.\n\r3) The code will cause an error at compile time.\r\r4) Compilation will cause an error because while cannot take a parameter of true.\n       \n---\nQuestion 34)\r\rWhich of the following statements about this code are true?\r\r\tpublic class Morecombe{\r\tpublic static void main(String argv[]){\r        Morecombe m = new Morecombe();\r        m.go(new Turing(){});\r\t}\r\tpublic void go(Turing t){\r\tt.start(); \n\t}\r\t}\r\tclass Turing extends Thread{\r        public void run(){\r               for(int i =0; i < 2; i++){\r                       System.out.println(i);\r\t} }\r\r1) Compilation error due to malformed parameter to go method\r\r2) Compilation error, class Turing has no start method\r\r3) Compilation and output of 0 followed by 1\r\r4) Compilation but runtime error\r\r---\rQuestion 35)\r\rWhat will be the result when you attempt to compile and run the following code?.\r\r\tpublic class Conv{\r    public static void main(String argv[]){\r        Conv c=new Conv();\r        String s=new String(\"ello\");\r\t}\r  \tc.amethod(s);\r    }\r    public void amethod(String s){\r        char c='H';\r\t\t c+=s;\r        System.out.println(c);\r\t    }\r\t}\r\r1) Compilation and output the string \"Hello\"\r\r2) Compilation and output the string \"ello\"\r\r3) Compilation and output the string elloH\r\r4) Compile time error\r\r---\nQuestion 36)\r\rGiven the following code, what test would you need to put in place of the comment line?\r\r\t//place test here\r\tto result in an output of the string\r\tEqual\r\tpublic class EqTest{\r         public static void main(String argv[]){\r                EqTest e=new EqTest();\r\t}\r        EqTest(){\r                String s=\"Java\";\r                String s2=\"java\";\r                //place test here {\r       }\r\t} }\r\tSystem.out.println(\"Equal\");\r\t}else\r\t{\r\tSystem.out.println(\"Not equal\");\n\n1) if(s==s2)\r\r2) if(s.equals(s2)\r\r3) if(s.equalsIgnoreCase(s2))\r\r4)if(s.noCaseMatch(s2))\r\r---\rQuestion 37)\r\rGiven the following code\r\r\timport java.awt.*;\r\tpublic class SetF extends Frame{\r\tpublic static void main(String argv[]){\r \t\tSetF s=new SetF();\r \t\ts.setSize(300,200);\r \t\ts.setVisible(true);\r \t}\r\t}\r\rHow could you set the frame surface color to pink\r\r1)s.setBackground(Color.pink);\r\r2)s.setColor(PINK);\r\r3)s.Background(pink);\r\r4)s.color=Color.pink\r\r---\rQuestion 38)\n\rHow can you change the current working directory using an instance of the File class called FileName?\r\r1) FileName.chdir(\"DirName\")\r\r2) FileName.cd(\"DirName\")\r\r3) FileName.cwd(\"DirName\")\r\r4) The File class does not support directly changing the current\rdirectory.\n\n---\rQuestion 39)\r                     \nIf you create a TextField with a constructor to set it to occupy 5 columns, what difference will it make if you use it with a proportional font (ie Times Roman) or a fixed pitch typewriter style font (Courier).\r\r1)With a fixed font you will see 5 characters, with a proportional it will depend on the width of the characters\r\r2)With a fixed font you will see 5 characters,with a proportional it will cause the field to expand to fit the text\r\r3)The columns setting does not affect the number of characters displayed 4)Both will show exactly 5 characters\r\r---\rQuestion 40)\rGiven the following code how could you invoke the Base constructor that will print out the string \"base constructor\";\r\r\tclass Base{\r    \tBase(int i){\r        System.out.println(\"base constructor\");\r    \t}\r\tBase(){\r\t\t} }\r\tpublic class Sup extends Base{\r    \tpublic static void main(String argv[]){\r        Sup s= new Sup();\r\t\t//One }\r\t\tSup() {\r\t\t//Two }\r    public void derived()\r    {\r\t//Three }\r\t}\n\r1) On the line After //One put Base(10);\r\r2) On the line After //One put super(10);\r       \n3) On the line After //Two put super(10);\r\r4) On the line After //Three put super(10);\r\r---\rQuestion 41)\r\rGiven the following code what will be output?\r\r\tpublic class Pass{\r    static int j=20;\r    public static void main(String argv[]){\r        int i=10;\r        Pass p = new Pass();\r        p.amethod(i);\r        System.out.println(i);\r        System.out.println(j);\r\t\t}\r    public void amethod(int x){\r        x=x*2;\r\t\t\tj=j*2; \n\t}\r\t}\n\r1) Error: amethod parameter does not match variable\r\r2) 20 and 40\r\r3) 10 and 40\r\r4) 10, and 20\r\r---\nQuestion 42)\r\rWhat code placed after the comment //For loop would result in the population of every element of the array ia[] with a value from variable i.?\r\r\tpublic class Lin{\r    public static void main(String argv[]){\r        Lin l = new Lin();\r        l.amethod();\r    }\r    public void amethod(){\r              \n        int ia[] = new int[4];\r        //Start For loop\r        {\r\t\t\t\tia[i]=i;\r            \tSystem.out.println(ia[i]);\r        }\r\t} }\r1) for(int i=0; i < ia.length() -1; i++)\r\r2) for (int i=0; i< ia.length(); i++)\r\r3) for(int i=1; i < 4; i++)\r\r4) for(int i=0; i< ia.length;i++)\r\r---\nQuestion 43)\r\rWhat will be the result when you try to compile and run the following code?\r\r\t\tprivate class Base{\r   \t\t\t Base(){\r\t\t\t\tint i = 100;\r        \t\tSystem.out.println(i);\r    \t\t\t}\r\t\t}\r\t\tpublic class Pri extends Base{\r  \t\t  static int i = 200;\r   \t\t\t public static void main(String argv[]){\r        \tPri p = new Pri();\r       \t System.out.println(i);\r    \t\t}\r\t\t}\r1) Error at compile time\r\r2) 200\r\r3) 100 followed by 200\r\r4) 100\r\r---\nQuestion 44)\r\rWhat will the following code print out?\r              \n\tpublic class Oct{\r\t    public static void main(String argv[]){\r        Oct o = new Oct();\r        o.amethod();\r   \t \t}\r    \tpublic void amethod(){\r        int oi= 012;\r        System.out.println(oi);\r    \t}\r\t}\n\r1)12\n\r2)012\n\r3)10\n\r4)10.0\n\n---\rQuestion 45\r\rWhat will happen when you try compiling and running this code?\r\r\tpublic class Ref{\r    public static void main(String argv[]){\r        Ref r = new Ref();\r        r.amethod(r);\r    }\r    public void amethod(Ref r){\r        int i=99;\r\t\t  multi(r);\r        System.out.println(i);\r    }\r    public void multi(Ref r){\r        r.i = r.i*2;\r\t} }\r\r1) Error at compile time\r\r2) An output of 99\r\r3) An output of 198\r\r4) An error at runtime\r              \n---\nQuestion 46)\r\rYou need to create a class that will store unique object elements. You do not need to sort these elements but they must be unique.\rWhat interface might be most suitable to meet this need?\r\r1)Set\r\r2)List\r\r3)Map\r\r4)Vector\r\r---\nQuestion 47)\r\rWhich of the following will successfully create an instance of the Vector class and add an element?\r\r1) Vector v=new Vector(99);\rv[1]=99;\n\r2) Vector v=new Vector();\rv.addElement(99);\n\r3) Vector v=new Vector();\rv.add(99);\n\r4 Vector v=new Vector(100);\rv.addElement(\"99\");\n\n---\rQuestion 48)\rYou have created a simple Frame and overridden the paint method as follows\n\r\t\tpublic void paint(Graphics g){\r\t\t\tg.drawString(\"Dolly\",50,10);\r\t\t}\r              \nWhat will be the result when you attempt to compile and run the program?\n\r1) The string \"Dolly\" will be displayed at the centre of the frame\r\r2) An error at compilation complaining at the signature of the paint method \n\n3) The lower part of the word Dolly will be seen at the top of the frame, with the top hidden.\r\r4) The string \"Dolly\" will be shown at the bottom of the frame.\r\r---\nQuestion 49)\r\rWhat will be the result when you attempt to compile this program?\r\r\tpublic class Rand{\r    public static void main(String argv[]){\r        int iRand;\r        iRand = Math.random();\r        System.out.println(iRand);\r\t} }\r\r1) Compile time error referring to a cast problem\r\r2) A random number between 1 and 10\r\r3) A random number between 0 and 1\r\r4) A compile time error about random being an unrecognised method\r\r---\nQuestion 50)\r\rGiven the following code\r\t\n\timport java.io.*;\r\tpublic class Th{\r    public static void main(String argv[]){\r        Th t = new Th();\r        t.amethod();\r    }\r    public void amethod(){\r        try{\r            ioCall();\r        }catch(IOException ioe){}\r              \n\t} }\r\rWhat code would be most likely for the body of the ioCall method\r\r1) \n\t\n\t\tpublic void ioCall ()throws IOException{\r\t\t DataInputStream din = new DataInputStream(System.in);\r \t\tdin.readChar();\r \t\t}\r2) \n\n\tpublic void ioCall ()throw IOException{\r \t\tDataInputStream din = new DataInputStream(System.in);\r\t    din.readChar();\r \t}\n \t\r3) \n\n\tpublic void ioCall (){\r\t \tDataInputStream din = new DataInputStream(System.in);\r \t\tdin.readChar();\r \t}\n \r4) \n\n\tpublic void ioCall throws IOException(){\r \t\t\tDataInputStream din = new DataInputStream(System.in);\r \t\t\t\tdin.readChar();\r\t\t}\n\r---\nQuestion 51)\rWhat will happen when you compile and run the following code?\rpublic class Scope{\r    private int i;\r    public static void main(String argv[]){\r        Scope s = new Scope();\r        s.amethod();\r    }//End of main\r    public static void amethod(){\r        System.out.println(i);\r    }//end of amethod\r}//End of class\r1) A value of 0 will be printed out\r2) Nothing will be printed out\r3) A compile time error\r4) A compile time error complaining of the scope of the variable i\r       \n---\nQuestion 52)\r\rYou want to lay out a set of buttons horizontally but with more space between the first button and the rest. You are going to use the GridBagLayout manager to control the way the buttons are set out. How will you modify the way the GridBagLayout acts in order to change the spacing around the first button?\r\r1) Create an instance of the GridBagConstraints class, call the weightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r3) Create an instance of the GridBagLayout class, set the weightx field and then call the setConstraints method of the GridBagLayoutClass with the component as a parameter.\r\r4) Create an instance of the GridBagLayout class, call the setWeightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r---\rQuestion 53)\r\rWhich of the following can you perform using the File class?\r\r1) Change the current directory\r\r2) Return the name of the parent directory\r\r3) Delete a file\r\r4) Find if a file contains text or binary information\r\r---\nQuestion 54)\r\rWhich statement is true of the following code?\r\r\tpublic class Rpcraven{\r        public static void main(String argv[]){\r              \n        Pmcraven pm1 = new Pmcraven(\"One\");\r        pm1.run();\r        Pmcraven pm2 = new Pmcraven(\"Two\");\r        pm2.run();\r\t} }\r\tclass Pmcraven extends Thread{\r\t\tprivate String sTname=\"\";\r\t\tPmcraven(String s){\r\t\tsTname = s;\r\t}\r\tpublic void run(){\r        for(int i =0; i < 2 ; i++){\r               try{\r\t} }\r \tsleep(1000);\r\t}catch(InterruptedException e){}\r\tyield();\r\tSystem.out.println(sTname);\r\t}\r1) Compile time error, class Rpcraven does not import java.lang.Thread \n\n2) Output of One One Two Two\r\r3) Output of One Two One Two\r\r4) Compilation but no output at runtime\r\r---\nQuestion 55)\r\rYou are concerned that your program may attempt to use more memory than is available. To avoid this situation you want to ensure that the Java Virtual Machine will run its garbage collection just before you start a complex routine. What can you do to be certain that garbage collection will run when you want .\r\r1) You cannot be certain when garbage collection will run\r\r2) Use the Runtime.gc() method to force garbage collection\r\r3) Ensure that all the variables you require to be garbage collected are set to null\r\r4) Use the System.gc() method to force garbage collection\r\r---\rQuestion 56)\rYou are using the GridBagLayout manager to place a series of buttons on a Frame. You want to make the size of one of the buttons bigger than the text it contains. Which of the following will allow you to do that?\r\r1) The GridBagLayout manager does not allow you to do this\r\r2) The setFill method of the GridBagLayout class\r\r3) The setFill method of the GridBagConstraints class\r\r4) The fill field of the GridBagConstraints class\r\r\r---\nQuestion 57)\r\rWhich of the following most closely describes a bitset collection?\r\r1) A class that contains groups of unique sequences of bits\r\r2) A method for flipping individual bits in instance of a primitive type \n\n3) An array of boolean primitives that indicate zeros or ones\r\r4) A collection for storing bits as on-off information, like a vector of bits\r\r---\nQuestion 58)\r\rYou have these files in the same directory. What will happen when you attempt to compile and run Class1.java if you have not already compiled Base.java\r\r\t//Base.java\r\tpackage Base;\r\tclass Base{\r    protected void amethod(){\r        System.out.println(\"amethod\");\r    }//End of amethod\r\t}//End of class base\r                     \n\tpackage Class1;\r\t//Class1.java\r\tpublic class Class1 extends Base{\r    public static void main(String argv[]){\r        Base b = new Base();\r        b.amethod();\r    }//End of main\r\t}//End of Class1\r\r1) Compile Error: Methods in Base not found\r\r2) Compile Error: Unable to access protected method in base class\r\r3) Compilation followed by the output \"amethod\"\r\r4)Compile error: Superclass Class1.Base of class Class1.Class1 not found\r\r---\nQuestion 59)\rWhat will happen when you attempt to compile and run the following code\r\tclass Base{\r    private void amethod(int iBase){\r        System.out.println(\"Base.amethod\");\r    }\r\t}\r\tclass Over extends Base{\r    public static void main(String argv[]){\r        Over o = new Over();\r        int iBase=0;\r        o.amethod(iBase);\r\t}\r    public void amethod(int iOver){\r        System.out.println(\"Over.amethod\");\r\t} }\r       \n1) Compile time error complaining that Base.amethod is private\r\r2) Runtime error complaining that Base.amethod is private\r\r3) Output of \"Base.amethod\"\r\r4) Output of \"Over.amethod\"\r\r---\nQuestion 60)\r\rYou are creating an applet with a Frame that contains buttons. You are using the GridBagLayout manager and you have added Four buttons. At the moment the buttons appear in the centre of the frame from left to right. You want them to appear one on top of the other going down the screen. What is the most appropriate way to do this.\r\r1) Set the gridy value of the GridBagConstraints class to a value\rincreasing from 1 to 4\r\r2) set the fill value of the GridBagConstraints class to VERTICAL\r\r3) Set the ipady value of the GridBagConstraints class to a value\rincreasing from 0 to 4\r\r4) Set the fill value of the GridBagLayouts class to GridBag.VERTICAL\r   Answer 1) Back to question 1) Objective 4.5)\r5) int i=10;\n\n\r答案\n---\rexplanation:\n\r1) float f=1.3;\n\rWill not compile because the default type of a number with a floating point component is a double. This would compile with a cast as in\nfloat f=(float) 1.3\n\r2) char c=\"a\";\n\rWill not compile because a char (16 bit unsigned integer) must be defined with single quotes. This would compile if it were in the form\rchar c='a';\n\r3) byte b=257;\n\rWill not compile because a byte is eight bits. Take of one bit for the sign component you can define numbers between\r-128 to +127\n\r4) a boolean value can either be true or false, null is not allowed\r\rAnswer 2)\rBack to question 2)\rObjective 4.1\r1) Can't make static reference to void amethod.\rBecause main is defined as static you need to create an instance of the class in order to call any non-static methods. Thus a typical way to do this would be.\rMyClass m=new MyClass(); m.amethod();\rAnswer 2 is an attempt to confuse because the convention is for a main method to be in the form String argv[]\rThat argv is just a convention and any acceptable identifier for a string array can be used. \n\nAnswers3 and 4 are just nonsense.\r Answer 3)\r\rback to Question 3) Objective 4.1)\r2 and 3 will compile without error.\r1 will not compile because any package declaration must come before any other code. Comments may appear anywhere. \n\nAnswer 4)\rBack to question 4) Objective 4.5)\r1) A byte is a signed 8 bit integer.\r Answer 5)\rBack to question 5) Objective 4.2)\r4) Exception raised: \"java.lang.ArrayIndexOutOfBoundsException: 2\"\rUnlike C/C++ java does not start the parameter count with the program name. It does however start from zero. So in this case zero starts with good, morning would be 1 and there is no parameter 2 so an exception is raised.\r \nAnswer 6)\rBack to question 6) Objective 4.3)\r1) if\r3) goto 4) while\n5) case\rthen is not a Java keyword, though if you are from a VB background you might think it was. Goto is a reserved word in Java.\r \nAnswer 7)\rBack to Question 7) \nObjective 4.1)\r2) variable2\r3) _whatavariable 4) \\_3\\_\r5) $anothervar\n\n\rAn identifier can begin with a letter (most common) or a dollar sign($) or an underscore(\\_). An identifier cannot start with anything else such as a number, a hash, # or a dash -. An identifier cannot have a dash in its body, but it may have an underscore \\_. Choice 4) \\_3\\_ looks strange but it is an acceptable, if unwise form for an identifier.\r \n Answer 8)\n \rBack to Question 8) Objective 4.4)\r4) 0\rClass level variables are always initialised to default values. In the case of an int this will be 0. Method level variables are not given default values and if you attempt to use one before it has been initialised it will cause the\rError Variable i may not have been initialized type of error.\n\r Answer 9)\rBack to Question 9) Objective 4.4)\n3)2\rNo error will be triggered.\rLike in C/C++, arrays are always referenced from 0. Java allows an array to be populated at creation time. The size of array is taken from the number of initializers. If you put a size within any of the square brackets you will get an error.\r \n Answer 10)\rBack to question 10) Objective 4.4)\r3) 0\rArrays are always initialised when they are created. As this is an array of ints it will be initalised with zeros.\r \n Answer 11)\rBack to Question 11) Objective 1.2\r3) Error Mine must be declared abstract\rA class that contains an abstract method must itself be declared as abstract. It may however contain non abstract methods. Any class derived from an abstract class must either define all of the abstract methods or be declared abstract itself.\r \n Answer 12)\n \rBack to Question 12) Objective 2.1)\r3) one, two, default\rCode will continue to fall through a case statement until it encounters a break.\n\r Answer 13)\n \nBack to Question 13) Objective 4.1)\r2) default, zero\rAlthough it is normally placed last the default statement does not have to be the last item as you fall through the case block. Because there is no case label found matching the expression the default label is executed and the code continues to fall through until it encounters a break.\n\r Answer 14)\n \rBack to Question 14) Objective 5.1\r2,3\rExample 1 will not compile because if must always test a boolean. This can catch out C/C++ programmers who expect the test to be for either 0 or not 0.\n\r Answer 15)\n \rBack to Question 15) Objective 11.5)\r3) No such file found, doing finally, -1\rThe no such file found message is to be expected, however you can get caught out if you are not aware that the finally clause is almost always executed, even if there is a return statement.\n\rAnswer 16)\n\rBack to Question 16) Objective 6.2)\r1) Methods cannot be overriden to be more private\rStatic methods cannot be overriden but they can be overloaded. If you have doubts about that statement, please follow and read carefully the link given to the Sun tutorial below. There is no logic or reason why private methods should not be overloaded. Option 4 is a jumbled up version of the limitations of exceptions for overriden methods\n\rAnswer 17)\n\rBack to Question 17) Objective 6.2)\r3) Runtime Exception\rWithout the cast to sub you would get a compile time error. The cast tells the compiler that you really mean to do this and the actual type of b does not get resolved until runtime. Casting down the object hierarchy is a problem, as the compiler cannot be sure what has been implemented in descendent classes. Casting up is not a problem because sub classes will have the features of the base classes. This can feel counter intuitive if you are aware that with primitives casting is allowed for widening operations (ie byte to int).\r\rAnswer 18)\n\rBack to question 18) Objective 5.1)\r1) System.out.println( -1 >>> 2);will output a result larger than 10 2) System.out.println( -1 >>> 2); will output a positive number\r3) System.out.println( 2 >> 1); will output the number 1\rYou can test this with the following class\rpublic class shift{\rstatic int i=2;\rpublic static void main(String argv[]){\rSystem.out.println( -1 System.out.println( -1 System.out.println( 2 }\r\\>\\>\\> 2);\r\\>\\>\\> 2); \\>\\> 1);\r}\rJava does not have a \\<\\<\\< operator. The operation 1 \\<\\< 2 would output 4\rBecause of the way twos complement number representation works the unsigned right shift operation means a small shift in a negative number can return a very large value so the output of\noption 1 will be much larger than 10.\rThe unsigned right shift places no significance on the leading bit that indicates the sign. For this shift the value 1 of the bit sign is replaced with a zero turning the result into a positive number for option 2.\n\r Answer 19)\n \rBack to Question 19) Objective 7.1)\r4) Compilation and output of either \"vandaleur\", \"vandaleur 0\", \"vandaleur 0 1\" \"vandaleur 0 1 2\" or \"vandaleur 0 1 2 3\"\rIf that seems a vauge answer it is because you cannot be certain of the system that the underlying OS uses for allocating cycles for a Thread. The chances are that once the thread has been spun off in the call to start in the method piggy the main method will run to completion and the value of sName will still be vandeluer before the Thread modifies it. You cannot be certain of this though.\n\r Answer 20)\n \rBack to Question 20) Objective 8.1)\r3) One button occupying the entire frame saying Bye\rThe default layout manager for a Frame is a border layout. If directions are not given (ie North, South, East or West), any button will simply go in the centre and occupy all the space. An additional button will simply be placed over the previous button. What you would probably want in a real example is to set up a flow layout as in\rsetLayout(new FlowLayout());\rWhich would allow the buttons to both appear side by side, given the appropriate font and size. Applets and panels have a default FlowLayout manager\n\r Answer 21)\n \rBack to Question 21) Objective 2.2)\n1,2\rValue for i=1 Value for j=1 Value for i=2 Value for j=1\rThe statement continue outer causes the code to jump to the label outer and the for loop increments to the next number.\r\r Answer 22)\n \rBack to Question 22)\rObjective 7.3)\r4) Runtime error, an exception will be thrown\rA call to wait/notify must be within synchronized code. With JDK1.2 this code throws the error message\rjava.lang.IllegalMonitorStateException: currentthreadnotowner at java.lang.Object.wait(Native Method)\rat java.lang.Object.wait(Object.java:424) at DSRoss.notwait(Compiled Code)\rat DSRoss.run(Agg.java:21)\n\r Answer 23)\n \rBack to Question 23) Objective 2.3)\r2,3\rOptions 1, & 4 will not compile as they attempt to throw Exceptions not declared in the base class. Because options 2 and 3 take a parameter of type long they represent overloading not overriding and there is no such limitations on overloaded methods.\n\r Answer 24)\n \rBack to Question 24) Objective 9.1)\r3) System.out.println(Math.ceil(-4.7));\nOptions 1 and 2 will produce -5 and option 4 will not compile because the min method requires 2 parameters.\n\r Answer 25)\n \rBack to Question 25 Objective 4.5)\r3) Compile time error\rThe wrapper classes cannot be used like primitives.\rDepending on your compiler you will get an error that says someting like \"Error: Can't convert java lang Integer\". Wrapper classes have similar names to primitives but all start with upper case letters.\rThus in this case we have int as a primitive and Integer as a wrapper. The objectives do not specifically mention the wrapper classes but don't be surprised if they come up.\n\r Answer 26)\n \rBack to Question 26) Objective 4.5)\r2) ic\rThis is a bit of a catch question. Anyone with a C/C++ background would figure out that addressing in strings starts with 0 so that 1 corresponds to i in the string Bicycle. The catch is that the second parameter returns the endcharacter minus 1. In this case it means instead of the \"icy\" being returned as intuition would expect it is only \"ic\".\n\r Answer 27)\n \rBack to Question 27) Objective 9.2)\r3) s.indexOf('v');\rcharAt returns the letter at the position rather than searching for a letter and returning the position, MID is just to confuse the Basic Programmers, indexOf(s,'v'); is how some future VB/J++ nightmare hybrid, might perform such a calculation.\n\n Answer 28)\n \rObjective 5.1)\rBack to Question 28\r1) s3=s1 + s2;\rJava does not allow operator overloading as in C++, but for the sake of convenience the + operator is overridden for strings.\n\rAnswer 29)\n\rBack to Question 29) Objective 5.3)\r4) 7\rThe | is known as the Or operator, you could think of it as the either/or operator. Turning the numbers into binary gives\r4=100 3=011\rFor each position, if either number contains a 1 the result will contain a result in that position. As every position contains a 1 the result will be\r111\rWhich is decimal 7.\n\r Answer 30)\n \rBack to Question 30 Objective 4.1)\r1,2,3\rpublic, private, static are all legal access modifiers for this inner class.\n\n Answer 31)\n \rBack to Question 31 Objective 7.1\r3) Output of first0, first1, second0, second1\rNote that this code overrides and calls the start method. If you wished to get the output mixed you would need to override the run method but call the start method.\n\r Answer 32)\n \rBack to Question 32) Objective 8.1)\r2) setLayout(new GridLayout(2,2));\rChanging the layout manager is the same for an Applet or an application. Answer 1 is wrong though it might have been a reasonable name for the designers to choose. Answers 3 and 4 are incorrect because changing the layout manager always requires an instance of one of the Layout Managers and these are bogus methods.\rInstead of creating the anonymous instance of the Layout manager as in option 2 you can also create a named instance and pass that as a parameter. This is often what automatic code generators such as Borland/Inprise JBuilder do.\n\r Answer 33)\n \rBack to Question 33) Objective 7.1)\r3) The code will cause an error at compile time\rThe error is caused because run should have a void not an int return type.\rAny class that is implements an interface must create a method to match all of the methods in the interface. The Runnable interface has one method called run that has a void return type.The sun\ncompiler gives the error\rMethod redefined with different return type: int run() was defined as void run();\n\r Answer 34)\n \rBack to Question 34) Objective 7.1)\r3) Compilation and output of 0 followed by 1\rThe creation of an anonymous class as a parameter to go is fairly strange as you would expect it to override a method in its parent class (Turing). You don't have to though. The fact that class Turing extends Thread means the anonymous instance that is passed to go has a start method which then calls the run method.\n\r Answer 35)\n \rBack to Question 35 Objective 5.1)\r4) Compile time error\rThe only operator overloading offered by java is the + sign for the String class. Achar is a 16 bit integer and cannot be concatenated to a string with the + operator.\n\r Answer 36)\n \rBack to Question 36 Objective 5.2)\r3) if(s.equalsIgnoreCase(s2))\rString comparison is case sensitive so using the equals string method will not return a match. Using the==operator just compares where memory address of the references and noCaseMatch was just something I made up to give me a fourth slightly plausible option.\n\r Answer 37)\n \nBack to Question 37 Objective 8.1)\r1) s.setBackground(Color.pink);\rFor speakers of the more British spelt English note that there is no letter u in Color. Also the constants for colors are in lower case.\n\r Answer 38)\n \rBack to Question 38) Objective 11.1)\r4) The File class does not support directly changing the current directory.\rThis seems rather surprising to me, as changing the current directory is a very common requirement. You may be able to get around this limitation by creating a new instance of the File class passing the new directory to the constructor as the path name.\n\r Answer 39)\n \rBack to Question 39) Objective 8.1)\r1)With a fixed font you will see 5 characters, with a the characters\rproportional it will depend on the width of\rWith a proportional font the letter w will occupy more space than the letter i. So if you have all wide characters you may have to scroll to the right to see the entire text of a TextField.\n\rAnswer 40)\n\rBack to Question 40) Objective 6.2\r3) On the line After //Two put super(10);\rConstructors can only be invoked from within constructors. \n\nAnswer 41)\n\rBack to Question 41) Objective 5.4)\r3) 10 and 40\rwhen a parameter is passed to a method the method receives a copy of the value. The method can modify its value without affecting the original copy. Thus in this example when the value is printed out the method has not changed the value.\r\rAnswer 42)\n\rBack to Question 42 Objective 1.1\r4) for(int i=0; i< ia.length;i++)\rAlthough you could control the looping with a literal number as with the number 4 used in option 3, it is better practice to use the length property of an array. This provides against bugs that might result if the size of the array changes. This question also checks that you know that arrays starts from zero and not One as option 3 starts from one. Remember that array length is a field and not a function like the String length() method.\n\rAnswer 43)\rBack to Question 43) Objective 1.2\r1) Error at compile time\rThis is a slightly sneaky one as it looks like a question about constructors, but it is attempting to test knowledge of the use of the private modifier. A top level class cannot be defined as private. If you didn't notice the modifier private, remember in the exam to be real careful to read every part of the question.\n\rAnswer 44)\n\rBack to Question 44 Objective 4.5)\n3)10\rThe name of the class might give you a clue with this question, Oct for Octal. Prefixing a number with a zero indicates that it is in Octal format. Thus when printed out it gets converted to base ten. 012 in octal means the first column from the right has a value of 2 and the next along has a value of one times eight. In decimal that adds up to 10.\n\r Answer 45)\n \rBack to Question 45 Objective 1.2)\r1) Error at compile time\rThe variable i is created at the level of amethod and will not be available inside the method multi.\n\rAnswer 46)\n\rBack to Question 46 Objective 10.1)\r1) Set\rThe Set interface ensures that its elements are unique, but does not order the elements. In reality you probably wouldn't create your own class using the Set interface. You would be more likely to use one of the JDK classes that use the Set interface such as HashSet or TreeSet.\n\r Answer 47)\n \rBack to Question 47 Objective 10.1)\r4) Vector v=new Vector(100); v.addElement(\"99\")\rA vector can only store objects not primitives. The parameter \"99\" for the addElement method pases a string object to the Vector. Option 1) creates a vector OK but then uses array syntax to attempt to assign a primitive. Option 2 also creates a vector then uses correct Vector syntax but falls over when the parameter is a primitive instead of an object.\r\nAnswer 48)\n\rObjective 8.1)\rBack to Question 48\r3) The lower part of the word Dolly will be seen at the top of the form\rThe Second parameter to the drawstring method indicates where the baseline of the string will be placed. Thus the 3rd parameter of 10 indicates the Y coordinate to be 10 pixels from the top of the Frame. This will result in just the bottom of the string Dolly showing up or possibly only the descending part of the letter y.\n\rAnswer 49)\n\rBack to Question 49) Objective 9.1)\r1) Compile time error referring to a cast problem\rThis is a bit of a sneaky one as the Math.random method returns a pseudo random number between 0 and 1, and thus option 3 is a plausible Answer. However the number returned is a double and so the compiler will complain that a cast is needed to convert a double to an int.\n\r Answer 50)\n \rObjective 2.3) Back to question 50\r1) public void ioCall ()throws IOException{ DataInputStream din = new DataInputStream(System.in); din.readChar();\r}\rIf a method might throw an exception it must either be caught within the method with a try/catch block, or the method must indicate the exception to any calling method by use of the throws statement in its declaration. Without this, an error will occur at compile time.\n\r Answer 51)\n \rObjective 1.2)\rBack to Question 51)\n3) A compile time error\rBecause only one instance of a static method exists not matter how many instance of the class exists it cannot access any non static variables. The JVM cannot know which instance of the variable to access. Thus you will get an error saying something like\rCan't make a static reference to a non static variable \n\rAnswer 52)\n\rObjective 8.1)\rBack to Question 52)\r2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\rThe Key to using the GridBagLayout manager is the GridBagConstraint class. This class is not consistent with the general naming conventions in the java API as you would expect that weightx would be set with a method, whereas it is a simple field (variable).\rIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error which is corrected in later versions of the book\r\rAnswer 53)\n\rObjective 11.1)\rBack to Question 53)\r2) Return the name of the parent directory 3) Delete a file\rIt is surprising that you can't change the current directory. It is not so surprising that you can't tell if a file contains text or binary information.\r\r Answer 54)\n \rBack to Question 54) Objective 7.1\n2) Output of One One Two Two\rAnswer 3 would would be true if the code called the start method instead of the run method (well it is on my Windows machine anyway, I'm not sure it would be for ever implementation of Java Threads). If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished executing.\r\rAnswer 55)\n\rObjective 3.1)\rBack to Question 55)\r1) You cannot be certain when garbage collection will run\rAlthough there is a Runtime.gc(), this only suggests that the Java Virtual Machine does its garbage collection. You can never be certain when the garbage collector will run. Roberts and Heller is more specific abou this than Boone. This uncertainty can cause consternation for C++ programmers who wish to run finalize methods with the same intent as they use destructor methods.\r\rAnswer 56)\n\rObjective 8.1)\rBack to Question 56)\r4) The fill field of the GridBagConstraints class\rUnlike the GridLayout manager you can set the individual size of a control such as a button using the GridBagLayout manager. A little background knowledge would indicate that it should be controlled by a setSomethingOrOther method, but it isn't.\rIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at\r\rAnswer 57)\n\rObjective 10.1)\rBack to Question 57)\n4) A collection for storing bits as on-off information, like a vector of bits\rThis is the description given to a bitset in Bruce Eckels \"Thinking in Java\" book. The reference to unique sequence of bits was an attempt to mislead because of the use of the word Set in the name bitset. Normally something called a set implies uniqueness of the members, but not in this context.\r\rAnswer 58)\n\rBack to Question 58) Objective 4.1)\r4)Compile error: Superclass Class1.Base of class Class1.Class1 not found\rUsing the package statement has an effect similar to placing a source file into a different directory. Because the files are in different packages they cannot see each other. The stuff about File1 not having been compiled was just to mislead, java has the equivalent of an \"automake\", whereby if it was not for the package statements the other file would have been automatically compiled.\r \n Answer 59)\n \rBack to Question 59) Objective 6.2)\r4) Output of Over.amethod()\rThe names of parameters to an overridden method is not important, but as the version of amethod in class Base is set to be private it is not visible within Over (despite Over extending Base) and thus does not take part in overriding.\r\rAnswer 60)\n\rObjective 8.1)\rBack to Question 60)\r1) Set the gridy value of the GridBagConstraints class to a value increasing from 1 to 4\rAnswer 4 is fairly obviously bogus as it is the GridBagConstraints class that does most of the magic in laying out components under the GridBagLayout manager. The fill value of the GridBagConstraints class controls the behavior inside its virtual cell and the ipady field controls the internal padding around a component.\nIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at\r","source":"_posts/笔试题20170620.md","raw":"---\ntitle: 笔试题20170620\ndate: 2017-06-20 13:24:02\ntags: 笔试题\n---\n\nQuestions\n---\rQuestion 1)\rWhich of the following lines will compile without warning or error.\n\n\r1) float f=1.3;\r\r2) char c=\"a\";\r\r3) byte b=257;\r\r4) boolean b=null;\r\r5) int i=10;\n\n---\rQuestion 2)\n\rWhat will happen if you try to compile and run the following code\r\r\tpublic class MyClass {\r    public static void main(String arguments[]) {\r        amethod(arguments);\r    }\r    public void amethod(String[] arguments) {\r        System.out.println(arguments);\r        System.out.println(arguments[1]);\r\t} \n\t}\n\r1) error Can't make static reference to void amethod.\n\r2) error method main not correct\n\r3) error array must include parameter\n\r4) amethod must be declared with String\n\n---\rQuestion 3)\n\rWhich of the following will compile without error\n\r1)\r\r\timport java.awt.*;\r\tpackage Mypackage;\r\tclass Myclass {}\n\r2)\r\r\tpackage MyPackage;\r\timport java.awt.*;\r\tclass MyClass{}\n\r3)\n\n\t/*This is a comment */\r\tpackage MyPackage;\r\timport java.awt.*;\r\tclass MyClass{}\n\n---\rQuestion 4)\n\rA byte can be of what size\n\r1) -128 to 127\n\r2) (-2 power 8 )-1 to 2 power 8\n\r3) -255 to 256\n\r4)depends on the particular implementation of the Java Virtual machine\r\r---\rQuestion 5)\n\rWhat will be printed out if this code is run with the following command line?\r\r\tjava myprog good morning\n\t\r\tpublic class myprog{\n\tpublic static void main(String argv[])\n    {\r        System.out.println(argv[2]);\r    }\r\t}\r              \n1) myprog\n\r2) good\n\r3) morning\n\r4) Exception raised: \"java.lang.ArrayIndexOutOfBoundsException: 2\"\n\n---\rQuestion 6)\n\rWhich of the following are keywords or reserved words in Java?\r\r1) if\r\r2) then\r\r3) goto\r\r4) while\r\r5) case\n\n---\n\rQuestion 7)\n\rWhich of the following are legal identifiers\r\r1) 2variable\r\r2) variable2\r\r3) _whatavariable\r\r4) \\_3\\_\r\r5) $anothervar\r\r6) #myvar\n\n---\n\rQuestion 8)\r\rWhat will happen when you compile and run the following code?\r\r\tpublic class MyClass{\r\t static int i;\r \tpublic static void main(String argv[]){\r \tSystem.out.println(i);\r \t}\r\t}\r                     \n1) Error Variable i may not have been initialized\r\r2) null\r\r3) 1\r\r4) 0\n\n---\rQuestion 9)\n\rWhat will happen if you try to compile and run the following code?\r\r\tpublic class Q {\r \t\tpublic static void main(String argv[]){\r \t\tint anar[]=new int[]{1,2,3};\r \t\tSystem.out.println(anar[1]);\r \t\t}\r\t}\n\r1) 1\n\r2) Error anar is referenced before it is initialized\n\r3) 2\n\r4) Error: size of array must be defined\n\n---\rQuestion 10)\n\rWhat will happen if you try to compile and run the following code?\r\r\tpublic class Q {\r \tpublic static void main(String argv[]){\r \t\tint anar[]=new int[5];\r \t\tSystem.out.println(anar[0]);\r \t}\r\t}\n\r1) Error: anar is referenced before it is initialized\r\r2) null\r\r3) 0\r\r4) 5\r \n ---                    \nQuestion 11)\n\rWhat will be the result of attempting to compile and run the following code?\n\r\tabstract class MineBase {\r \tabstract void amethod();\r \tstatic int i;\r\t}\r\r\tpublic class Mine extends MineBase {\r \tpublic static void main(String argv[]){\r \tint[] ar=new int[5];\r \tfor(i=0;i < ar.length;i++)\r \tSystem.out.println(ar[i]);\r\t} }\n\r1) a sequence of 5 0's will be printed\n\r2) Error: ar is used before it is initialized\n\r3) Error Mine must be declared abstract\n\r4) IndexOutOfBoundes Error\n\n---\rQuestion 12)\n\rWhat will be printed out if you attempt to compile and run the following code ?\n\r\tint i=1;\r \tswitch (i) {\r \tcase 0:\r \tSystem.out.println(\"zero\");\r \tbreak;\r \tcase 1:\r \tSystem.out.println(\"one\");\r \tcase 2:\r \tSystem.out.println(\"two\");\r \tdefault:\r \tSystem.out.println(\"default\");\r \t}\n \r1) one\n\r2) one, default\r       \n3) one, two, default\n\r4) default\n\n---\rQuestion 13)\n\rWhat will be printed out if you attempt to compile and run the following code?\n\r\tint i=9;\r\tswitch (i) {\r \tdefault:\r \tSystem.out.println(\"default\");\r \tcase 0:\r \tSystem.out.println(\"zero\");\r \tbreak;\r \tcase 1:\r \tSystem.out.println(\"one\");\r \tcase 2:\r \tSystem.out.println(\"two\");\r\t}\n\r1) default\n\r2) default, zero\n\r3) error default clause not defined\n\r4) no output displayed\n\n---\rQuestion 14)\n\rWhich of the following lines of code will compile without error\r\r1)\r\r\tint i=0;\r\tif(i) {\r \t\tSystem.out.println(\"Hello\");\r \t}\n \r2)\n\t\n\tboolean b=true;\r\tboolean b2=true;             \n\tif(b==b2) {\r \t\tSystem.out.println(\"So true\");\r \t}\n \r3)\r\r\tint i=1;\r\tint j=2;\r\tif(i==1|| j==2)\r\t System.out.println(\"OK\");\n \r4)\r\r\tint i=1;\r\tint j=2;\r\tif(i==1 &| j==2)\r \tSystem.out.println(\"OK\");\n \n ---\rQuestion 15)\n\rWhat will be output if you try to compile and run the following code, but there is no file called Hello.txt in the current directory?.\n\r\timport java.io.*;\r\tpublic class Mine {\r   \t public static void main(String argv[]){\r        \tMine m=new Mine();\r        \tSystem.out.println(m.amethod());\r   \t }\r    \tpublic int amethod() {\r        try {\r            FileInputStream dis=new FileInputStream(\"Hello.txt\");\r        }catch (FileNotFoundException fne) {\r            System.out.println(\"No such file found\");\r            return -1;\r        }catch(IOException ioe) {\r        } finally{\r            System.out.println(\"Doing finally\");\r        }\r\treturn 0; }       \n\t}\n\r1) No such file found\n\r2 No such file found ,-1\n\r3) No such file found, Doing finally, -1\n\r4) 0\n\n---\rQuestion 16)\n\rWhich of the following statements are true?\n\r1) Methods cannot be overriden to be more private\n\r2) static methods cannot be overloaded\n\r3) private methods cannot be overloaded\n\r4) An overloaded method cannot throw exceptions not checked in the base class\n\n---\rQuestion 17)\n\rWhat will happen if you attempt to compile and run the following code?\r\r\t\tclass Base {}\r\t\tclass Sub extends Base {}\r\t\tclass Sub2 extends Base {}\r\t\tpublic class CEx{\r   \t\t public static void main(String argv[]){\r        \tBase b=new Base();\r        \tSub s=(Sub) b;\r\t\t\t} \n\t\t}\n\n\r1) Compile and run without error\n\r2) Compile time Exception\n\r3) Runtime Exception\r\r---\rQuestion 18)\n\rWhich of the following statements are true?\r                     \n1) System.out.println( -1 >>> 2);will output a result larger than 10 \n\n2) System.out.println( -1 >>> 2); will output a positive number\r\r3) System.out.println( 2 >> 1); will output the number 1\r\r4) System.out.println( 1 <<< 2); will output the number 4\r\r---\rQuestion 19)\r\rWhat will happen when you attempt to compile and run the following code?\n\n\tpublic class Tux extends Thread{\r        static String sName = \"vandeleur\";\r        public static void main(String argv[]){\r        Tux t = new Tux();\r        t.piggy(sName);\r        System.out.println(sName);\r        }\r        public void piggy(String sName){\r                sName = sName + \" wiggy\";\r        start();\r        }\r        public void run(){\r        for(int i=0;i  <  4; i++){\r                sName = sName + \" \" + i;\r\t} }\r\t}\n\r1) Compile time error\r\r2) Compilation and output of \"vandeleur wiggy\"\r\r3) Compilation and output of \"vandeleur wiggy 0 1 2 3\"\r\r4) Compilation and output of either \"vandeleur\", \"vandeleur 0\", \"vandeleur 0 1\" \"vandaleur 0 1 2\" or \"vandaleur 0 1 2 3\"\r\r---\rQuestion 20)\r              \nWhat will be displayed when you attempt to compile and run the following code\r\r\t//Code start\r\timport java.awt.*;\r\tpublic class Butt extends Frame{\r    \tpublic static void main(String argv[]){\r        Butt MyBut=new Butt();\r\t} \n\tButt(){\r        Button HelloBut=new Button(\"Hello\");\r        Button ByeBut=new Button(\"Bye\");\r        add(HelloBut);\r        add(ByeBut);\r        setSize(300,300);\r        setVisible(true);\r   \t}\r\t}\r\t//Code end`\n\r1) Two buttons side by side occupying all of the frame, Hello on the left and Bye on the right\r\r2) One button occupying the entire frame saying Hello\r\r3) One button occupying the entire frame saying Bye\r\r4) Two buttons at the top of the frame one saying Hello the other saying Bye\r\r---\rQuestion 21)\r\rWhat will be output by the following code?\r\r\tpublic class MyFor{\r    public static void main(String argv[]){\r\tint i;\r\tint j; \n\t\touter:\r        for (i=1;i <3;i++)\r            inner:\r        for(j=1; j<3; j++) {\r            if (j==2)\r       continue outer;\r\tSystem.out.println(\"Value for i=\" + i + \" Value for j=\" +j);\r\t} }\r\t}\r\r1) Value for i=1 Value for j=1\r\r2) Value for i=2 Value for j=1\r\r3) Value for i=2 Value for j=2\r\r4) Value for i=3 Value for j=1\r\r---\rQuestion 22)\r\rWhich statement is true of the following code?\r\r\tpublic class Agg{\r\tpublic static void main(String argv[]){\r        Agg a = new Agg();\r        a.go();\r        }\r        public void go(){\r               DSRoss ds1 = new DSRoss(\"one\");\r               ds1.start();\r\t} }\r\tclass DSRoss extends Thread{\r\tprivate String sTname=\"\";\r\tDSRoss(String s){\r\t\tsTname = s;\r\t}\r\tpublic void run(){\r        notwait();\r        System.out.println(\"finished\");\r       }\r\tpublic void notwait(){\r        while(true){\r               try{\r\tSystem.out.println(\"waiting\");\r\twait();\r\t}catch(InterruptedException ie){}\r\t\tSystem.out.println(sTname);\n               notifyAll();\r\t} }\n\r1) It will cause a compile time error\r\r2) Compilation and output of \"waiting\"\r\r3) Compilation and output of \"waiting\" followed by \"finished\"\r\r4) Runtime error, an exception will be thrown\r\r---\nQuestion 23)\r\rWhich of the following methods can be legally inserted in place of the comment //Method Here ?\r\r\tclass Base{\r \tpublic void amethod(int i) { }\r\t}\r\tpublic class Scope extends Base{\r \tpublic static void main(String argv[]){\r \t}\r \t//Method Here\r\t}\r\r1) void amethod(int i) throws Exception {}\r\r2) void amethod(long i)throws Exception {}\r\r3) void amethod(long i){}\r\r4) public void amethod(int i) throws Exception {}\r\r---\nQuestion 24)\r\rWhich of the following will output -4.0\r\r1) System.out.println(Math.floor(-4.7));\r\r2) System.out.println(Math.round(-4.7));\r}\r              \n3) System.out.println(Math.ceil(-4.7));\r\r4) System.out.println(Math.min(-4.7));\r\r---\rQuestion 25)\r\rWhat will happen if you attempt to compile and run the following code?\r\r\tInteger ten=new Integer(10);\r\tLong nine=new Long (9);\r\tSystem.out.println(ten + nine);\r\tint i=1;\r\tSystem.out.println(i + ten);\r\r1) 19 followed by 20\r\r2) 19 followed by 11\r\r3) Compile time error\r\r4) 10 followed by 1\r\r---\nQuestion 26)\r\rIf you run the code below, what gets printed out?\r\r\tString s=new String(\"Bicycle\");\r\tint iBegin=1;\r\tchar iEnd=3;\r\tSystem.out.println(s.substring(iBegin,iEnd));\r\r1) Bic\r\r2) ic\r\r3) icy\r\r4) error: no method matching substring(int,char)\r\r---\nQuestion 27)\r\rIf you wanted to find out where the position of the letter v (ie return 2) in the string s containing \"Java\", which of the following could you use?\r                     \n1) mid(2,s);\r\r2) charAt(2);\r\r3) s.indexOf('v');\r\r4) indexOf(s,'v');\r\r---\nQuestion 28)\rGiven the following declarations\r\r\r\tString s1=new String(\"Hello\")\r\tString s2=new String(\"there\");\r\tString s3=new String();\r\rWhich of the following are legal operations?\r\r1) s3=s1 + s2;\r\r2) s3=s1-s2;\r\r3) s3=s1 & s2;\r\r4) s3=s1 && s2\r\r---\nQuestion 29)\r\rWhat is the result of the following operation?\r\r\tSystem.out.println(4 | 3);\r\r1) 6\r\r2) 0\r\r3) 1\r\r4) 7\r\r---\nQuestion 30)\r\r\tpublic class MyClass1 {\r\tpublic static void main(String argv[]){ }\r\t/*Modifier at XX */ class MyInner {}\r\t}\r\rWhat modifiers would be legal at XX in the above code?\r                     \n1) public\r\r2) private\r\r3) static\r\r4) friend\n\n---\rQuestion 31)\n\rWhat will happen when you attempt to compile and run the following code?\n\r\tpublic class Holt extends Thread{\r        private String sThreadName;\r        public static void main(String argv[]){\r                Holt h = new Holt();\r\th.go(); }\r\tHolt(){}\r\tHolt(String s){\r        sThreadName = s;\r\t}\r\tpublic String getThreadName(){\r        return sThreadName;\r\t}\r\tpublic void go(){\r        Holt first = new Holt(\"first\");\r       }\r\tfirst.start();\r\tHolt second = new Holt(\"second\");\r\tsecond.start();\r\tpublic void start(){\r        for(int i = 0; i < 2; i ++){\r\t}\r\t} }\r\ttry{\r\t\tSystem.out.println(getThreadName() +i);\r\t\tThread.sleep(100);\r                        } catch(InterruptedException\r\t\te){System.out.println(e.getMessage());}\n\n1) Compile time error\n\r2) Output of first0, second0, first0, second1\n\r3) Output of first0, first1, second0, second1\n\r4) Runtime error\n\r---\nQuestion 32)\r\rAn Applet has its Layout Manager set to the default of FlowLayout. What code would be correct to change to another Layout Manager.\r\r1) setLayoutManager(new GridLayout());\r\r2) setLayout(new GridLayout(2,2));\r\r3) setGridLayout(2,2);\r\r4) setBorderLayout();\r\r---\nQuestion 33)\r\rWhat will happen when you attempt to compile and run the following code?.\r\r\tclass Background implements Runnable{\r        int i=0;\r               public int run(){\r                        while(true){\r                                  return 1;\r         }//End run\r\t}//End class\r\ti++;\r\tSystem.out.println(\"i=\"+i);\r\t} //End while\n\r1) It will compile and the run method will print out the increasing value of i.\n\r2) It will compile and calling start will print out the increasing value of i.\n\r3) The code will cause an error at compile time.\r\r4) Compilation will cause an error because while cannot take a parameter of true.\n       \n---\nQuestion 34)\r\rWhich of the following statements about this code are true?\r\r\tpublic class Morecombe{\r\tpublic static void main(String argv[]){\r        Morecombe m = new Morecombe();\r        m.go(new Turing(){});\r\t}\r\tpublic void go(Turing t){\r\tt.start(); \n\t}\r\t}\r\tclass Turing extends Thread{\r        public void run(){\r               for(int i =0; i < 2; i++){\r                       System.out.println(i);\r\t} }\r\r1) Compilation error due to malformed parameter to go method\r\r2) Compilation error, class Turing has no start method\r\r3) Compilation and output of 0 followed by 1\r\r4) Compilation but runtime error\r\r---\rQuestion 35)\r\rWhat will be the result when you attempt to compile and run the following code?.\r\r\tpublic class Conv{\r    public static void main(String argv[]){\r        Conv c=new Conv();\r        String s=new String(\"ello\");\r\t}\r  \tc.amethod(s);\r    }\r    public void amethod(String s){\r        char c='H';\r\t\t c+=s;\r        System.out.println(c);\r\t    }\r\t}\r\r1) Compilation and output the string \"Hello\"\r\r2) Compilation and output the string \"ello\"\r\r3) Compilation and output the string elloH\r\r4) Compile time error\r\r---\nQuestion 36)\r\rGiven the following code, what test would you need to put in place of the comment line?\r\r\t//place test here\r\tto result in an output of the string\r\tEqual\r\tpublic class EqTest{\r         public static void main(String argv[]){\r                EqTest e=new EqTest();\r\t}\r        EqTest(){\r                String s=\"Java\";\r                String s2=\"java\";\r                //place test here {\r       }\r\t} }\r\tSystem.out.println(\"Equal\");\r\t}else\r\t{\r\tSystem.out.println(\"Not equal\");\n\n1) if(s==s2)\r\r2) if(s.equals(s2)\r\r3) if(s.equalsIgnoreCase(s2))\r\r4)if(s.noCaseMatch(s2))\r\r---\rQuestion 37)\r\rGiven the following code\r\r\timport java.awt.*;\r\tpublic class SetF extends Frame{\r\tpublic static void main(String argv[]){\r \t\tSetF s=new SetF();\r \t\ts.setSize(300,200);\r \t\ts.setVisible(true);\r \t}\r\t}\r\rHow could you set the frame surface color to pink\r\r1)s.setBackground(Color.pink);\r\r2)s.setColor(PINK);\r\r3)s.Background(pink);\r\r4)s.color=Color.pink\r\r---\rQuestion 38)\n\rHow can you change the current working directory using an instance of the File class called FileName?\r\r1) FileName.chdir(\"DirName\")\r\r2) FileName.cd(\"DirName\")\r\r3) FileName.cwd(\"DirName\")\r\r4) The File class does not support directly changing the current\rdirectory.\n\n---\rQuestion 39)\r                     \nIf you create a TextField with a constructor to set it to occupy 5 columns, what difference will it make if you use it with a proportional font (ie Times Roman) or a fixed pitch typewriter style font (Courier).\r\r1)With a fixed font you will see 5 characters, with a proportional it will depend on the width of the characters\r\r2)With a fixed font you will see 5 characters,with a proportional it will cause the field to expand to fit the text\r\r3)The columns setting does not affect the number of characters displayed 4)Both will show exactly 5 characters\r\r---\rQuestion 40)\rGiven the following code how could you invoke the Base constructor that will print out the string \"base constructor\";\r\r\tclass Base{\r    \tBase(int i){\r        System.out.println(\"base constructor\");\r    \t}\r\tBase(){\r\t\t} }\r\tpublic class Sup extends Base{\r    \tpublic static void main(String argv[]){\r        Sup s= new Sup();\r\t\t//One }\r\t\tSup() {\r\t\t//Two }\r    public void derived()\r    {\r\t//Three }\r\t}\n\r1) On the line After //One put Base(10);\r\r2) On the line After //One put super(10);\r       \n3) On the line After //Two put super(10);\r\r4) On the line After //Three put super(10);\r\r---\rQuestion 41)\r\rGiven the following code what will be output?\r\r\tpublic class Pass{\r    static int j=20;\r    public static void main(String argv[]){\r        int i=10;\r        Pass p = new Pass();\r        p.amethod(i);\r        System.out.println(i);\r        System.out.println(j);\r\t\t}\r    public void amethod(int x){\r        x=x*2;\r\t\t\tj=j*2; \n\t}\r\t}\n\r1) Error: amethod parameter does not match variable\r\r2) 20 and 40\r\r3) 10 and 40\r\r4) 10, and 20\r\r---\nQuestion 42)\r\rWhat code placed after the comment //For loop would result in the population of every element of the array ia[] with a value from variable i.?\r\r\tpublic class Lin{\r    public static void main(String argv[]){\r        Lin l = new Lin();\r        l.amethod();\r    }\r    public void amethod(){\r              \n        int ia[] = new int[4];\r        //Start For loop\r        {\r\t\t\t\tia[i]=i;\r            \tSystem.out.println(ia[i]);\r        }\r\t} }\r1) for(int i=0; i < ia.length() -1; i++)\r\r2) for (int i=0; i< ia.length(); i++)\r\r3) for(int i=1; i < 4; i++)\r\r4) for(int i=0; i< ia.length;i++)\r\r---\nQuestion 43)\r\rWhat will be the result when you try to compile and run the following code?\r\r\t\tprivate class Base{\r   \t\t\t Base(){\r\t\t\t\tint i = 100;\r        \t\tSystem.out.println(i);\r    \t\t\t}\r\t\t}\r\t\tpublic class Pri extends Base{\r  \t\t  static int i = 200;\r   \t\t\t public static void main(String argv[]){\r        \tPri p = new Pri();\r       \t System.out.println(i);\r    \t\t}\r\t\t}\r1) Error at compile time\r\r2) 200\r\r3) 100 followed by 200\r\r4) 100\r\r---\nQuestion 44)\r\rWhat will the following code print out?\r              \n\tpublic class Oct{\r\t    public static void main(String argv[]){\r        Oct o = new Oct();\r        o.amethod();\r   \t \t}\r    \tpublic void amethod(){\r        int oi= 012;\r        System.out.println(oi);\r    \t}\r\t}\n\r1)12\n\r2)012\n\r3)10\n\r4)10.0\n\n---\rQuestion 45\r\rWhat will happen when you try compiling and running this code?\r\r\tpublic class Ref{\r    public static void main(String argv[]){\r        Ref r = new Ref();\r        r.amethod(r);\r    }\r    public void amethod(Ref r){\r        int i=99;\r\t\t  multi(r);\r        System.out.println(i);\r    }\r    public void multi(Ref r){\r        r.i = r.i*2;\r\t} }\r\r1) Error at compile time\r\r2) An output of 99\r\r3) An output of 198\r\r4) An error at runtime\r              \n---\nQuestion 46)\r\rYou need to create a class that will store unique object elements. You do not need to sort these elements but they must be unique.\rWhat interface might be most suitable to meet this need?\r\r1)Set\r\r2)List\r\r3)Map\r\r4)Vector\r\r---\nQuestion 47)\r\rWhich of the following will successfully create an instance of the Vector class and add an element?\r\r1) Vector v=new Vector(99);\rv[1]=99;\n\r2) Vector v=new Vector();\rv.addElement(99);\n\r3) Vector v=new Vector();\rv.add(99);\n\r4 Vector v=new Vector(100);\rv.addElement(\"99\");\n\n---\rQuestion 48)\rYou have created a simple Frame and overridden the paint method as follows\n\r\t\tpublic void paint(Graphics g){\r\t\t\tg.drawString(\"Dolly\",50,10);\r\t\t}\r              \nWhat will be the result when you attempt to compile and run the program?\n\r1) The string \"Dolly\" will be displayed at the centre of the frame\r\r2) An error at compilation complaining at the signature of the paint method \n\n3) The lower part of the word Dolly will be seen at the top of the frame, with the top hidden.\r\r4) The string \"Dolly\" will be shown at the bottom of the frame.\r\r---\nQuestion 49)\r\rWhat will be the result when you attempt to compile this program?\r\r\tpublic class Rand{\r    public static void main(String argv[]){\r        int iRand;\r        iRand = Math.random();\r        System.out.println(iRand);\r\t} }\r\r1) Compile time error referring to a cast problem\r\r2) A random number between 1 and 10\r\r3) A random number between 0 and 1\r\r4) A compile time error about random being an unrecognised method\r\r---\nQuestion 50)\r\rGiven the following code\r\t\n\timport java.io.*;\r\tpublic class Th{\r    public static void main(String argv[]){\r        Th t = new Th();\r        t.amethod();\r    }\r    public void amethod(){\r        try{\r            ioCall();\r        }catch(IOException ioe){}\r              \n\t} }\r\rWhat code would be most likely for the body of the ioCall method\r\r1) \n\t\n\t\tpublic void ioCall ()throws IOException{\r\t\t DataInputStream din = new DataInputStream(System.in);\r \t\tdin.readChar();\r \t\t}\r2) \n\n\tpublic void ioCall ()throw IOException{\r \t\tDataInputStream din = new DataInputStream(System.in);\r\t    din.readChar();\r \t}\n \t\r3) \n\n\tpublic void ioCall (){\r\t \tDataInputStream din = new DataInputStream(System.in);\r \t\tdin.readChar();\r \t}\n \r4) \n\n\tpublic void ioCall throws IOException(){\r \t\t\tDataInputStream din = new DataInputStream(System.in);\r \t\t\t\tdin.readChar();\r\t\t}\n\r---\nQuestion 51)\rWhat will happen when you compile and run the following code?\rpublic class Scope{\r    private int i;\r    public static void main(String argv[]){\r        Scope s = new Scope();\r        s.amethod();\r    }//End of main\r    public static void amethod(){\r        System.out.println(i);\r    }//end of amethod\r}//End of class\r1) A value of 0 will be printed out\r2) Nothing will be printed out\r3) A compile time error\r4) A compile time error complaining of the scope of the variable i\r       \n---\nQuestion 52)\r\rYou want to lay out a set of buttons horizontally but with more space between the first button and the rest. You are going to use the GridBagLayout manager to control the way the buttons are set out. How will you modify the way the GridBagLayout acts in order to change the spacing around the first button?\r\r1) Create an instance of the GridBagConstraints class, call the weightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r3) Create an instance of the GridBagLayout class, set the weightx field and then call the setConstraints method of the GridBagLayoutClass with the component as a parameter.\r\r4) Create an instance of the GridBagLayout class, call the setWeightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\r\r---\rQuestion 53)\r\rWhich of the following can you perform using the File class?\r\r1) Change the current directory\r\r2) Return the name of the parent directory\r\r3) Delete a file\r\r4) Find if a file contains text or binary information\r\r---\nQuestion 54)\r\rWhich statement is true of the following code?\r\r\tpublic class Rpcraven{\r        public static void main(String argv[]){\r              \n        Pmcraven pm1 = new Pmcraven(\"One\");\r        pm1.run();\r        Pmcraven pm2 = new Pmcraven(\"Two\");\r        pm2.run();\r\t} }\r\tclass Pmcraven extends Thread{\r\t\tprivate String sTname=\"\";\r\t\tPmcraven(String s){\r\t\tsTname = s;\r\t}\r\tpublic void run(){\r        for(int i =0; i < 2 ; i++){\r               try{\r\t} }\r \tsleep(1000);\r\t}catch(InterruptedException e){}\r\tyield();\r\tSystem.out.println(sTname);\r\t}\r1) Compile time error, class Rpcraven does not import java.lang.Thread \n\n2) Output of One One Two Two\r\r3) Output of One Two One Two\r\r4) Compilation but no output at runtime\r\r---\nQuestion 55)\r\rYou are concerned that your program may attempt to use more memory than is available. To avoid this situation you want to ensure that the Java Virtual Machine will run its garbage collection just before you start a complex routine. What can you do to be certain that garbage collection will run when you want .\r\r1) You cannot be certain when garbage collection will run\r\r2) Use the Runtime.gc() method to force garbage collection\r\r3) Ensure that all the variables you require to be garbage collected are set to null\r\r4) Use the System.gc() method to force garbage collection\r\r---\rQuestion 56)\rYou are using the GridBagLayout manager to place a series of buttons on a Frame. You want to make the size of one of the buttons bigger than the text it contains. Which of the following will allow you to do that?\r\r1) The GridBagLayout manager does not allow you to do this\r\r2) The setFill method of the GridBagLayout class\r\r3) The setFill method of the GridBagConstraints class\r\r4) The fill field of the GridBagConstraints class\r\r\r---\nQuestion 57)\r\rWhich of the following most closely describes a bitset collection?\r\r1) A class that contains groups of unique sequences of bits\r\r2) A method for flipping individual bits in instance of a primitive type \n\n3) An array of boolean primitives that indicate zeros or ones\r\r4) A collection for storing bits as on-off information, like a vector of bits\r\r---\nQuestion 58)\r\rYou have these files in the same directory. What will happen when you attempt to compile and run Class1.java if you have not already compiled Base.java\r\r\t//Base.java\r\tpackage Base;\r\tclass Base{\r    protected void amethod(){\r        System.out.println(\"amethod\");\r    }//End of amethod\r\t}//End of class base\r                     \n\tpackage Class1;\r\t//Class1.java\r\tpublic class Class1 extends Base{\r    public static void main(String argv[]){\r        Base b = new Base();\r        b.amethod();\r    }//End of main\r\t}//End of Class1\r\r1) Compile Error: Methods in Base not found\r\r2) Compile Error: Unable to access protected method in base class\r\r3) Compilation followed by the output \"amethod\"\r\r4)Compile error: Superclass Class1.Base of class Class1.Class1 not found\r\r---\nQuestion 59)\rWhat will happen when you attempt to compile and run the following code\r\tclass Base{\r    private void amethod(int iBase){\r        System.out.println(\"Base.amethod\");\r    }\r\t}\r\tclass Over extends Base{\r    public static void main(String argv[]){\r        Over o = new Over();\r        int iBase=0;\r        o.amethod(iBase);\r\t}\r    public void amethod(int iOver){\r        System.out.println(\"Over.amethod\");\r\t} }\r       \n1) Compile time error complaining that Base.amethod is private\r\r2) Runtime error complaining that Base.amethod is private\r\r3) Output of \"Base.amethod\"\r\r4) Output of \"Over.amethod\"\r\r---\nQuestion 60)\r\rYou are creating an applet with a Frame that contains buttons. You are using the GridBagLayout manager and you have added Four buttons. At the moment the buttons appear in the centre of the frame from left to right. You want them to appear one on top of the other going down the screen. What is the most appropriate way to do this.\r\r1) Set the gridy value of the GridBagConstraints class to a value\rincreasing from 1 to 4\r\r2) set the fill value of the GridBagConstraints class to VERTICAL\r\r3) Set the ipady value of the GridBagConstraints class to a value\rincreasing from 0 to 4\r\r4) Set the fill value of the GridBagLayouts class to GridBag.VERTICAL\r   Answer 1) Back to question 1) Objective 4.5)\r5) int i=10;\n\n\r答案\n---\rexplanation:\n\r1) float f=1.3;\n\rWill not compile because the default type of a number with a floating point component is a double. This would compile with a cast as in\nfloat f=(float) 1.3\n\r2) char c=\"a\";\n\rWill not compile because a char (16 bit unsigned integer) must be defined with single quotes. This would compile if it were in the form\rchar c='a';\n\r3) byte b=257;\n\rWill not compile because a byte is eight bits. Take of one bit for the sign component you can define numbers between\r-128 to +127\n\r4) a boolean value can either be true or false, null is not allowed\r\rAnswer 2)\rBack to question 2)\rObjective 4.1\r1) Can't make static reference to void amethod.\rBecause main is defined as static you need to create an instance of the class in order to call any non-static methods. Thus a typical way to do this would be.\rMyClass m=new MyClass(); m.amethod();\rAnswer 2 is an attempt to confuse because the convention is for a main method to be in the form String argv[]\rThat argv is just a convention and any acceptable identifier for a string array can be used. \n\nAnswers3 and 4 are just nonsense.\r Answer 3)\r\rback to Question 3) Objective 4.1)\r2 and 3 will compile without error.\r1 will not compile because any package declaration must come before any other code. Comments may appear anywhere. \n\nAnswer 4)\rBack to question 4) Objective 4.5)\r1) A byte is a signed 8 bit integer.\r Answer 5)\rBack to question 5) Objective 4.2)\r4) Exception raised: \"java.lang.ArrayIndexOutOfBoundsException: 2\"\rUnlike C/C++ java does not start the parameter count with the program name. It does however start from zero. So in this case zero starts with good, morning would be 1 and there is no parameter 2 so an exception is raised.\r \nAnswer 6)\rBack to question 6) Objective 4.3)\r1) if\r3) goto 4) while\n5) case\rthen is not a Java keyword, though if you are from a VB background you might think it was. Goto is a reserved word in Java.\r \nAnswer 7)\rBack to Question 7) \nObjective 4.1)\r2) variable2\r3) _whatavariable 4) \\_3\\_\r5) $anothervar\n\n\rAn identifier can begin with a letter (most common) or a dollar sign($) or an underscore(\\_). An identifier cannot start with anything else such as a number, a hash, # or a dash -. An identifier cannot have a dash in its body, but it may have an underscore \\_. Choice 4) \\_3\\_ looks strange but it is an acceptable, if unwise form for an identifier.\r \n Answer 8)\n \rBack to Question 8) Objective 4.4)\r4) 0\rClass level variables are always initialised to default values. In the case of an int this will be 0. Method level variables are not given default values and if you attempt to use one before it has been initialised it will cause the\rError Variable i may not have been initialized type of error.\n\r Answer 9)\rBack to Question 9) Objective 4.4)\n3)2\rNo error will be triggered.\rLike in C/C++, arrays are always referenced from 0. Java allows an array to be populated at creation time. The size of array is taken from the number of initializers. If you put a size within any of the square brackets you will get an error.\r \n Answer 10)\rBack to question 10) Objective 4.4)\r3) 0\rArrays are always initialised when they are created. As this is an array of ints it will be initalised with zeros.\r \n Answer 11)\rBack to Question 11) Objective 1.2\r3) Error Mine must be declared abstract\rA class that contains an abstract method must itself be declared as abstract. It may however contain non abstract methods. Any class derived from an abstract class must either define all of the abstract methods or be declared abstract itself.\r \n Answer 12)\n \rBack to Question 12) Objective 2.1)\r3) one, two, default\rCode will continue to fall through a case statement until it encounters a break.\n\r Answer 13)\n \nBack to Question 13) Objective 4.1)\r2) default, zero\rAlthough it is normally placed last the default statement does not have to be the last item as you fall through the case block. Because there is no case label found matching the expression the default label is executed and the code continues to fall through until it encounters a break.\n\r Answer 14)\n \rBack to Question 14) Objective 5.1\r2,3\rExample 1 will not compile because if must always test a boolean. This can catch out C/C++ programmers who expect the test to be for either 0 or not 0.\n\r Answer 15)\n \rBack to Question 15) Objective 11.5)\r3) No such file found, doing finally, -1\rThe no such file found message is to be expected, however you can get caught out if you are not aware that the finally clause is almost always executed, even if there is a return statement.\n\rAnswer 16)\n\rBack to Question 16) Objective 6.2)\r1) Methods cannot be overriden to be more private\rStatic methods cannot be overriden but they can be overloaded. If you have doubts about that statement, please follow and read carefully the link given to the Sun tutorial below. There is no logic or reason why private methods should not be overloaded. Option 4 is a jumbled up version of the limitations of exceptions for overriden methods\n\rAnswer 17)\n\rBack to Question 17) Objective 6.2)\r3) Runtime Exception\rWithout the cast to sub you would get a compile time error. The cast tells the compiler that you really mean to do this and the actual type of b does not get resolved until runtime. Casting down the object hierarchy is a problem, as the compiler cannot be sure what has been implemented in descendent classes. Casting up is not a problem because sub classes will have the features of the base classes. This can feel counter intuitive if you are aware that with primitives casting is allowed for widening operations (ie byte to int).\r\rAnswer 18)\n\rBack to question 18) Objective 5.1)\r1) System.out.println( -1 >>> 2);will output a result larger than 10 2) System.out.println( -1 >>> 2); will output a positive number\r3) System.out.println( 2 >> 1); will output the number 1\rYou can test this with the following class\rpublic class shift{\rstatic int i=2;\rpublic static void main(String argv[]){\rSystem.out.println( -1 System.out.println( -1 System.out.println( 2 }\r\\>\\>\\> 2);\r\\>\\>\\> 2); \\>\\> 1);\r}\rJava does not have a \\<\\<\\< operator. The operation 1 \\<\\< 2 would output 4\rBecause of the way twos complement number representation works the unsigned right shift operation means a small shift in a negative number can return a very large value so the output of\noption 1 will be much larger than 10.\rThe unsigned right shift places no significance on the leading bit that indicates the sign. For this shift the value 1 of the bit sign is replaced with a zero turning the result into a positive number for option 2.\n\r Answer 19)\n \rBack to Question 19) Objective 7.1)\r4) Compilation and output of either \"vandaleur\", \"vandaleur 0\", \"vandaleur 0 1\" \"vandaleur 0 1 2\" or \"vandaleur 0 1 2 3\"\rIf that seems a vauge answer it is because you cannot be certain of the system that the underlying OS uses for allocating cycles for a Thread. The chances are that once the thread has been spun off in the call to start in the method piggy the main method will run to completion and the value of sName will still be vandeluer before the Thread modifies it. You cannot be certain of this though.\n\r Answer 20)\n \rBack to Question 20) Objective 8.1)\r3) One button occupying the entire frame saying Bye\rThe default layout manager for a Frame is a border layout. If directions are not given (ie North, South, East or West), any button will simply go in the centre and occupy all the space. An additional button will simply be placed over the previous button. What you would probably want in a real example is to set up a flow layout as in\rsetLayout(new FlowLayout());\rWhich would allow the buttons to both appear side by side, given the appropriate font and size. Applets and panels have a default FlowLayout manager\n\r Answer 21)\n \rBack to Question 21) Objective 2.2)\n1,2\rValue for i=1 Value for j=1 Value for i=2 Value for j=1\rThe statement continue outer causes the code to jump to the label outer and the for loop increments to the next number.\r\r Answer 22)\n \rBack to Question 22)\rObjective 7.3)\r4) Runtime error, an exception will be thrown\rA call to wait/notify must be within synchronized code. With JDK1.2 this code throws the error message\rjava.lang.IllegalMonitorStateException: currentthreadnotowner at java.lang.Object.wait(Native Method)\rat java.lang.Object.wait(Object.java:424) at DSRoss.notwait(Compiled Code)\rat DSRoss.run(Agg.java:21)\n\r Answer 23)\n \rBack to Question 23) Objective 2.3)\r2,3\rOptions 1, & 4 will not compile as they attempt to throw Exceptions not declared in the base class. Because options 2 and 3 take a parameter of type long they represent overloading not overriding and there is no such limitations on overloaded methods.\n\r Answer 24)\n \rBack to Question 24) Objective 9.1)\r3) System.out.println(Math.ceil(-4.7));\nOptions 1 and 2 will produce -5 and option 4 will not compile because the min method requires 2 parameters.\n\r Answer 25)\n \rBack to Question 25 Objective 4.5)\r3) Compile time error\rThe wrapper classes cannot be used like primitives.\rDepending on your compiler you will get an error that says someting like \"Error: Can't convert java lang Integer\". Wrapper classes have similar names to primitives but all start with upper case letters.\rThus in this case we have int as a primitive and Integer as a wrapper. The objectives do not specifically mention the wrapper classes but don't be surprised if they come up.\n\r Answer 26)\n \rBack to Question 26) Objective 4.5)\r2) ic\rThis is a bit of a catch question. Anyone with a C/C++ background would figure out that addressing in strings starts with 0 so that 1 corresponds to i in the string Bicycle. The catch is that the second parameter returns the endcharacter minus 1. In this case it means instead of the \"icy\" being returned as intuition would expect it is only \"ic\".\n\r Answer 27)\n \rBack to Question 27) Objective 9.2)\r3) s.indexOf('v');\rcharAt returns the letter at the position rather than searching for a letter and returning the position, MID is just to confuse the Basic Programmers, indexOf(s,'v'); is how some future VB/J++ nightmare hybrid, might perform such a calculation.\n\n Answer 28)\n \rObjective 5.1)\rBack to Question 28\r1) s3=s1 + s2;\rJava does not allow operator overloading as in C++, but for the sake of convenience the + operator is overridden for strings.\n\rAnswer 29)\n\rBack to Question 29) Objective 5.3)\r4) 7\rThe | is known as the Or operator, you could think of it as the either/or operator. Turning the numbers into binary gives\r4=100 3=011\rFor each position, if either number contains a 1 the result will contain a result in that position. As every position contains a 1 the result will be\r111\rWhich is decimal 7.\n\r Answer 30)\n \rBack to Question 30 Objective 4.1)\r1,2,3\rpublic, private, static are all legal access modifiers for this inner class.\n\n Answer 31)\n \rBack to Question 31 Objective 7.1\r3) Output of first0, first1, second0, second1\rNote that this code overrides and calls the start method. If you wished to get the output mixed you would need to override the run method but call the start method.\n\r Answer 32)\n \rBack to Question 32) Objective 8.1)\r2) setLayout(new GridLayout(2,2));\rChanging the layout manager is the same for an Applet or an application. Answer 1 is wrong though it might have been a reasonable name for the designers to choose. Answers 3 and 4 are incorrect because changing the layout manager always requires an instance of one of the Layout Managers and these are bogus methods.\rInstead of creating the anonymous instance of the Layout manager as in option 2 you can also create a named instance and pass that as a parameter. This is often what automatic code generators such as Borland/Inprise JBuilder do.\n\r Answer 33)\n \rBack to Question 33) Objective 7.1)\r3) The code will cause an error at compile time\rThe error is caused because run should have a void not an int return type.\rAny class that is implements an interface must create a method to match all of the methods in the interface. The Runnable interface has one method called run that has a void return type.The sun\ncompiler gives the error\rMethod redefined with different return type: int run() was defined as void run();\n\r Answer 34)\n \rBack to Question 34) Objective 7.1)\r3) Compilation and output of 0 followed by 1\rThe creation of an anonymous class as a parameter to go is fairly strange as you would expect it to override a method in its parent class (Turing). You don't have to though. The fact that class Turing extends Thread means the anonymous instance that is passed to go has a start method which then calls the run method.\n\r Answer 35)\n \rBack to Question 35 Objective 5.1)\r4) Compile time error\rThe only operator overloading offered by java is the + sign for the String class. Achar is a 16 bit integer and cannot be concatenated to a string with the + operator.\n\r Answer 36)\n \rBack to Question 36 Objective 5.2)\r3) if(s.equalsIgnoreCase(s2))\rString comparison is case sensitive so using the equals string method will not return a match. Using the==operator just compares where memory address of the references and noCaseMatch was just something I made up to give me a fourth slightly plausible option.\n\r Answer 37)\n \nBack to Question 37 Objective 8.1)\r1) s.setBackground(Color.pink);\rFor speakers of the more British spelt English note that there is no letter u in Color. Also the constants for colors are in lower case.\n\r Answer 38)\n \rBack to Question 38) Objective 11.1)\r4) The File class does not support directly changing the current directory.\rThis seems rather surprising to me, as changing the current directory is a very common requirement. You may be able to get around this limitation by creating a new instance of the File class passing the new directory to the constructor as the path name.\n\r Answer 39)\n \rBack to Question 39) Objective 8.1)\r1)With a fixed font you will see 5 characters, with a the characters\rproportional it will depend on the width of\rWith a proportional font the letter w will occupy more space than the letter i. So if you have all wide characters you may have to scroll to the right to see the entire text of a TextField.\n\rAnswer 40)\n\rBack to Question 40) Objective 6.2\r3) On the line After //Two put super(10);\rConstructors can only be invoked from within constructors. \n\nAnswer 41)\n\rBack to Question 41) Objective 5.4)\r3) 10 and 40\rwhen a parameter is passed to a method the method receives a copy of the value. The method can modify its value without affecting the original copy. Thus in this example when the value is printed out the method has not changed the value.\r\rAnswer 42)\n\rBack to Question 42 Objective 1.1\r4) for(int i=0; i< ia.length;i++)\rAlthough you could control the looping with a literal number as with the number 4 used in option 3, it is better practice to use the length property of an array. This provides against bugs that might result if the size of the array changes. This question also checks that you know that arrays starts from zero and not One as option 3 starts from one. Remember that array length is a field and not a function like the String length() method.\n\rAnswer 43)\rBack to Question 43) Objective 1.2\r1) Error at compile time\rThis is a slightly sneaky one as it looks like a question about constructors, but it is attempting to test knowledge of the use of the private modifier. A top level class cannot be defined as private. If you didn't notice the modifier private, remember in the exam to be real careful to read every part of the question.\n\rAnswer 44)\n\rBack to Question 44 Objective 4.5)\n3)10\rThe name of the class might give you a clue with this question, Oct for Octal. Prefixing a number with a zero indicates that it is in Octal format. Thus when printed out it gets converted to base ten. 012 in octal means the first column from the right has a value of 2 and the next along has a value of one times eight. In decimal that adds up to 10.\n\r Answer 45)\n \rBack to Question 45 Objective 1.2)\r1) Error at compile time\rThe variable i is created at the level of amethod and will not be available inside the method multi.\n\rAnswer 46)\n\rBack to Question 46 Objective 10.1)\r1) Set\rThe Set interface ensures that its elements are unique, but does not order the elements. In reality you probably wouldn't create your own class using the Set interface. You would be more likely to use one of the JDK classes that use the Set interface such as HashSet or TreeSet.\n\r Answer 47)\n \rBack to Question 47 Objective 10.1)\r4) Vector v=new Vector(100); v.addElement(\"99\")\rA vector can only store objects not primitives. The parameter \"99\" for the addElement method pases a string object to the Vector. Option 1) creates a vector OK but then uses array syntax to attempt to assign a primitive. Option 2 also creates a vector then uses correct Vector syntax but falls over when the parameter is a primitive instead of an object.\r\nAnswer 48)\n\rObjective 8.1)\rBack to Question 48\r3) The lower part of the word Dolly will be seen at the top of the form\rThe Second parameter to the drawstring method indicates where the baseline of the string will be placed. Thus the 3rd parameter of 10 indicates the Y coordinate to be 10 pixels from the top of the Frame. This will result in just the bottom of the string Dolly showing up or possibly only the descending part of the letter y.\n\rAnswer 49)\n\rBack to Question 49) Objective 9.1)\r1) Compile time error referring to a cast problem\rThis is a bit of a sneaky one as the Math.random method returns a pseudo random number between 0 and 1, and thus option 3 is a plausible Answer. However the number returned is a double and so the compiler will complain that a cast is needed to convert a double to an int.\n\r Answer 50)\n \rObjective 2.3) Back to question 50\r1) public void ioCall ()throws IOException{ DataInputStream din = new DataInputStream(System.in); din.readChar();\r}\rIf a method might throw an exception it must either be caught within the method with a try/catch block, or the method must indicate the exception to any calling method by use of the throws statement in its declaration. Without this, an error will occur at compile time.\n\r Answer 51)\n \rObjective 1.2)\rBack to Question 51)\n3) A compile time error\rBecause only one instance of a static method exists not matter how many instance of the class exists it cannot access any non static variables. The JVM cannot know which instance of the variable to access. Thus you will get an error saying something like\rCan't make a static reference to a non static variable \n\rAnswer 52)\n\rObjective 8.1)\rBack to Question 52)\r2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.\rThe Key to using the GridBagLayout manager is the GridBagConstraint class. This class is not consistent with the general naming conventions in the java API as you would expect that weightx would be set with a method, whereas it is a simple field (variable).\rIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error which is corrected in later versions of the book\r\rAnswer 53)\n\rObjective 11.1)\rBack to Question 53)\r2) Return the name of the parent directory 3) Delete a file\rIt is surprising that you can't change the current directory. It is not so surprising that you can't tell if a file contains text or binary information.\r\r Answer 54)\n \rBack to Question 54) Objective 7.1\n2) Output of One One Two Two\rAnswer 3 would would be true if the code called the start method instead of the run method (well it is on my Windows machine anyway, I'm not sure it would be for ever implementation of Java Threads). If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished executing.\r\rAnswer 55)\n\rObjective 3.1)\rBack to Question 55)\r1) You cannot be certain when garbage collection will run\rAlthough there is a Runtime.gc(), this only suggests that the Java Virtual Machine does its garbage collection. You can never be certain when the garbage collector will run. Roberts and Heller is more specific abou this than Boone. This uncertainty can cause consternation for C++ programmers who wish to run finalize methods with the same intent as they use destructor methods.\r\rAnswer 56)\n\rObjective 8.1)\rBack to Question 56)\r4) The fill field of the GridBagConstraints class\rUnlike the GridLayout manager you can set the individual size of a control such as a button using the GridBagLayout manager. A little background knowledge would indicate that it should be controlled by a setSomethingOrOther method, but it isn't.\rIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at\r\rAnswer 57)\n\rObjective 10.1)\rBack to Question 57)\n4) A collection for storing bits as on-off information, like a vector of bits\rThis is the description given to a bitset in Bruce Eckels \"Thinking in Java\" book. The reference to unique sequence of bits was an attempt to mislead because of the use of the word Set in the name bitset. Normally something called a set implies uniqueness of the members, but not in this context.\r\rAnswer 58)\n\rBack to Question 58) Objective 4.1)\r4)Compile error: Superclass Class1.Base of class Class1.Class1 not found\rUsing the package statement has an effect similar to placing a source file into a different directory. Because the files are in different packages they cannot see each other. The stuff about File1 not having been compiled was just to mislead, java has the equivalent of an \"automake\", whereby if it was not for the package statements the other file would have been automatically compiled.\r \n Answer 59)\n \rBack to Question 59) Objective 6.2)\r4) Output of Over.amethod()\rThe names of parameters to an overridden method is not important, but as the version of amethod in class Base is set to be private it is not visible within Over (despite Over extending Base) and thus does not take part in overriding.\r\rAnswer 60)\n\rObjective 8.1)\rBack to Question 60)\r1) Set the gridy value of the GridBagConstraints class to a value increasing from 1 to 4\rAnswer 4 is fairly obviously bogus as it is the GridBagConstraints class that does most of the magic in laying out components under the GridBagLayout manager. The fill value of the GridBagConstraints class controls the behavior inside its virtual cell and the ipady field controls the internal padding around a component.\nIf you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at\r","slug":"笔试题20170620","published":1,"updated":"2017-06-20T10:22:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj486x74v00037k2665ujv2ch","content":"<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><p>Question 1)<br>Which of the following lines will compile without warning or error.</p>\n<p>1) float f=1.3;</p>\n<p>2) char c=”a”;</p>\n<p>3) byte b=257;</p>\n<p>4) boolean b=null;</p>\n<p>5) int i=10;</p>\n<hr>\n<p>Question 2)</p>\n<p>What will happen if you try to compile and run the following code</p>\n<pre><code>public class MyClass {\npublic static void main(String arguments[]) {\n    amethod(arguments);\n}\npublic void amethod(String[] arguments) {\n    System.out.println(arguments);\n    System.out.println(arguments[1]);\n} \n}\n</code></pre><p>1) error Can’t make static reference to void amethod.</p>\n<p>2) error method main not correct</p>\n<p>3) error array must include parameter</p>\n<p>4) amethod must be declared with String</p>\n<hr>\n<p>Question 3)</p>\n<p>Which of the following will compile without error</p>\n<p>1)</p>\n<pre><code>import java.awt.*;\npackage Mypackage;\nclass Myclass {}\n</code></pre><p>2)</p>\n<pre><code>package MyPackage;\nimport java.awt.*;\nclass MyClass{}\n</code></pre><p>3)</p>\n<pre><code>/*This is a comment */\npackage MyPackage;\nimport java.awt.*;\nclass MyClass{}\n</code></pre><hr>\n<p>Question 4)</p>\n<p>A byte can be of what size</p>\n<p>1) -128 to 127</p>\n<p>2) (-2 power 8 )-1 to 2 power 8</p>\n<p>3) -255 to 256</p>\n<p>4)depends on the particular implementation of the Java Virtual machine</p>\n<hr>\n<p>Question 5)</p>\n<p>What will be printed out if this code is run with the following command line?</p>\n<pre><code>java myprog good morning\n\npublic class myprog{\npublic static void main(String argv[])\n{\n    System.out.println(argv[2]);\n}\n}\n</code></pre><p>1) myprog</p>\n<p>2) good</p>\n<p>3) morning</p>\n<p>4) Exception raised: “java.lang.ArrayIndexOutOfBoundsException: 2”</p>\n<hr>\n<p>Question 6)</p>\n<p>Which of the following are keywords or reserved words in Java?</p>\n<p>1) if</p>\n<p>2) then</p>\n<p>3) goto</p>\n<p>4) while</p>\n<p>5) case</p>\n<hr>\n<p>Question 7)</p>\n<p>Which of the following are legal identifiers</p>\n<p>1) 2variable</p>\n<p>2) variable2</p>\n<p>3) _whatavariable</p>\n<p>4) _3_</p>\n<p>5) $anothervar</p>\n<p>6) #myvar</p>\n<hr>\n<p>Question 8)</p>\n<p>What will happen when you compile and run the following code?</p>\n<pre><code>public class MyClass{\n static int i;\n public static void main(String argv[]){\n System.out.println(i);\n }\n}\n</code></pre><p>1) Error Variable i may not have been initialized</p>\n<p>2) null</p>\n<p>3) 1</p>\n<p>4) 0</p>\n<hr>\n<p>Question 9)</p>\n<p>What will happen if you try to compile and run the following code?</p>\n<pre><code>public class Q {\n     public static void main(String argv[]){\n     int anar[]=new int[]{1,2,3};\n     System.out.println(anar[1]);\n     }\n}\n</code></pre><p>1) 1</p>\n<p>2) Error anar is referenced before it is initialized</p>\n<p>3) 2</p>\n<p>4) Error: size of array must be defined</p>\n<hr>\n<p>Question 10)</p>\n<p>What will happen if you try to compile and run the following code?</p>\n<pre><code>public class Q {\n public static void main(String argv[]){\n     int anar[]=new int[5];\n     System.out.println(anar[0]);\n }\n}\n</code></pre><p>1) Error: anar is referenced before it is initialized</p>\n<p>2) null</p>\n<p>3) 0</p>\n<p>4) 5</p>\n<hr>\n<p>Question 11)</p>\n<p>What will be the result of attempting to compile and run the following code?</p>\n<pre><code>abstract class MineBase {\n abstract void amethod();\n static int i;\n}\n\npublic class Mine extends MineBase {\n public static void main(String argv[]){\n int[] ar=new int[5];\n for(i=0;i &lt; ar.length;i++)\n System.out.println(ar[i]);\n} }\n</code></pre><p>1) a sequence of 5 0’s will be printed</p>\n<p>2) Error: ar is used before it is initialized</p>\n<p>3) Error Mine must be declared abstract</p>\n<p>4) IndexOutOfBoundes Error</p>\n<hr>\n<p>Question 12)</p>\n<p>What will be printed out if you attempt to compile and run the following code ?</p>\n<pre><code>int i=1;\n switch (i) {\n case 0:\n System.out.println(&quot;zero&quot;);\n break;\n case 1:\n System.out.println(&quot;one&quot;);\n case 2:\n System.out.println(&quot;two&quot;);\n default:\n System.out.println(&quot;default&quot;);\n }\n</code></pre><p>1) one</p>\n<p>2) one, default</p>\n<p>3) one, two, default</p>\n<p>4) default</p>\n<hr>\n<p>Question 13)</p>\n<p>What will be printed out if you attempt to compile and run the following code?</p>\n<pre><code>int i=9;\nswitch (i) {\n default:\n System.out.println(&quot;default&quot;);\n case 0:\n System.out.println(&quot;zero&quot;);\n break;\n case 1:\n System.out.println(&quot;one&quot;);\n case 2:\n System.out.println(&quot;two&quot;);\n}\n</code></pre><p>1) default</p>\n<p>2) default, zero</p>\n<p>3) error default clause not defined</p>\n<p>4) no output displayed</p>\n<hr>\n<p>Question 14)</p>\n<p>Which of the following lines of code will compile without error</p>\n<p>1)</p>\n<pre><code>int i=0;\nif(i) {\n     System.out.println(&quot;Hello&quot;);\n }\n</code></pre><p>2)</p>\n<pre><code>boolean b=true;\nboolean b2=true;             \nif(b==b2) {\n     System.out.println(&quot;So true&quot;);\n }\n</code></pre><p>3)</p>\n<pre><code>int i=1;\nint j=2;\nif(i==1|| j==2)\n System.out.println(&quot;OK&quot;);\n</code></pre><p>4)</p>\n<pre><code>int i=1;\nint j=2;\nif(i==1 &amp;| j==2)\n System.out.println(&quot;OK&quot;);\n</code></pre><hr>\n<p>Question 15)</p>\n<p>What will be output if you try to compile and run the following code, but there is no file called Hello.txt in the current directory?.</p>\n<pre><code>import java.io.*;\npublic class Mine {\n    public static void main(String argv[]){\n        Mine m=new Mine();\n        System.out.println(m.amethod());\n    }\n    public int amethod() {\n    try {\n        FileInputStream dis=new FileInputStream(&quot;Hello.txt&quot;);\n    }catch (FileNotFoundException fne) {\n        System.out.println(&quot;No such file found&quot;);\n        return -1;\n    }catch(IOException ioe) {\n    } finally{\n        System.out.println(&quot;Doing finally&quot;);\n    }\nreturn 0; }       \n}\n</code></pre><p>1) No such file found</p>\n<p>2 No such file found ,-1</p>\n<p>3) No such file found, Doing finally, -1</p>\n<p>4) 0</p>\n<hr>\n<p>Question 16)</p>\n<p>Which of the following statements are true?</p>\n<p>1) Methods cannot be overriden to be more private</p>\n<p>2) static methods cannot be overloaded</p>\n<p>3) private methods cannot be overloaded</p>\n<p>4) An overloaded method cannot throw exceptions not checked in the base class</p>\n<hr>\n<p>Question 17)</p>\n<p>What will happen if you attempt to compile and run the following code?</p>\n<pre><code>class Base {}\nclass Sub extends Base {}\nclass Sub2 extends Base {}\npublic class CEx{\n    public static void main(String argv[]){\n    Base b=new Base();\n    Sub s=(Sub) b;\n    } \n}\n</code></pre><p>1) Compile and run without error</p>\n<p>2) Compile time Exception</p>\n<p>3) Runtime Exception</p>\n<hr>\n<p>Question 18)</p>\n<p>Which of the following statements are true?</p>\n<p>1) System.out.println( -1 &gt;&gt;&gt; 2);will output a result larger than 10 </p>\n<p>2) System.out.println( -1 &gt;&gt;&gt; 2); will output a positive number</p>\n<p>3) System.out.println( 2 &gt;&gt; 1); will output the number 1</p>\n<p>4) System.out.println( 1 &lt;&lt;&lt; 2); will output the number 4</p>\n<hr>\n<p>Question 19)</p>\n<p>What will happen when you attempt to compile and run the following code?</p>\n<pre><code>public class Tux extends Thread{\n    static String sName = &quot;vandeleur&quot;;\n    public static void main(String argv[]){\n    Tux t = new Tux();\n    t.piggy(sName);\n    System.out.println(sName);\n    }\n    public void piggy(String sName){\n            sName = sName + &quot; wiggy&quot;;\n    start();\n    }\n    public void run(){\n    for(int i=0;i  &lt;  4; i++){\n            sName = sName + &quot; &quot; + i;\n} }\n}\n</code></pre><p>1) Compile time error</p>\n<p>2) Compilation and output of “vandeleur wiggy”</p>\n<p>3) Compilation and output of “vandeleur wiggy 0 1 2 3”</p>\n<p>4) Compilation and output of either “vandeleur”, “vandeleur 0”, “vandeleur 0 1” “vandaleur 0 1 2” or “vandaleur 0 1 2 3”</p>\n<hr>\n<p>Question 20)</p>\n<p>What will be displayed when you attempt to compile and run the following code</p>\n<pre><code>//Code start\nimport java.awt.*;\npublic class Butt extends Frame{\n    public static void main(String argv[]){\n    Butt MyBut=new Butt();\n} \nButt(){\n    Button HelloBut=new Button(&quot;Hello&quot;);\n    Button ByeBut=new Button(&quot;Bye&quot;);\n    add(HelloBut);\n    add(ByeBut);\n    setSize(300,300);\n    setVisible(true);\n   }\n}\n//Code end`\n</code></pre><p>1) Two buttons side by side occupying all of the frame, Hello on the left and Bye on the right</p>\n<p>2) One button occupying the entire frame saying Hello</p>\n<p>3) One button occupying the entire frame saying Bye</p>\n<p>4) Two buttons at the top of the frame one saying Hello the other saying Bye</p>\n<hr>\n<p>Question 21)</p>\n<p>What will be output by the following code?</p>\n<pre><code>public class MyFor{\npublic static void main(String argv[]){\nint i;\nint j; \n    outer:\n    for (i=1;i &lt;3;i++)\n        inner:\n    for(j=1; j&lt;3; j++) {\n        if (j==2)\n   continue outer;\nSystem.out.println(&quot;Value for i=&quot; + i + &quot; Value for j=&quot; +j);\n} }\n}\n</code></pre><p>1) Value for i=1 Value for j=1</p>\n<p>2) Value for i=2 Value for j=1</p>\n<p>3) Value for i=2 Value for j=2</p>\n<p>4) Value for i=3 Value for j=1</p>\n<hr>\n<p>Question 22)</p>\n<p>Which statement is true of the following code?</p>\n<pre><code>public class Agg{\npublic static void main(String argv[]){\n    Agg a = new Agg();\n    a.go();\n    }\n    public void go(){\n           DSRoss ds1 = new DSRoss(&quot;one&quot;);\n           ds1.start();\n} }\nclass DSRoss extends Thread{\nprivate String sTname=&quot;&quot;;\nDSRoss(String s){\n    sTname = s;\n}\npublic void run(){\n    notwait();\n    System.out.println(&quot;finished&quot;);\n   }\npublic void notwait(){\n    while(true){\n           try{\nSystem.out.println(&quot;waiting&quot;);\nwait();\n}catch(InterruptedException ie){}\n    System.out.println(sTname);\n           notifyAll();\n} }\n</code></pre><p>1) It will cause a compile time error</p>\n<p>2) Compilation and output of “waiting”</p>\n<p>3) Compilation and output of “waiting” followed by “finished”</p>\n<p>4) Runtime error, an exception will be thrown</p>\n<hr>\n<p>Question 23)</p>\n<p>Which of the following methods can be legally inserted in place of the comment //Method Here ?</p>\n<pre><code>class Base{\n public void amethod(int i) { }\n}\npublic class Scope extends Base{\n public static void main(String argv[]){\n }\n //Method Here\n}\n</code></pre><p>1) void amethod(int i) throws Exception {}</p>\n<p>2) void amethod(long i)throws Exception {}</p>\n<p>3) void amethod(long i){}</p>\n<p>4) public void amethod(int i) throws Exception {}</p>\n<hr>\n<p>Question 24)</p>\n<p>Which of the following will output -4.0</p>\n<p>1) System.out.println(Math.floor(-4.7));</p>\n<p>2) System.out.println(Math.round(-4.7));<br>}</p>\n<p>3) System.out.println(Math.ceil(-4.7));</p>\n<p>4) System.out.println(Math.min(-4.7));</p>\n<hr>\n<p>Question 25)</p>\n<p>What will happen if you attempt to compile and run the following code?</p>\n<pre><code>Integer ten=new Integer(10);\nLong nine=new Long (9);\nSystem.out.println(ten + nine);\nint i=1;\nSystem.out.println(i + ten);\n</code></pre><p>1) 19 followed by 20</p>\n<p>2) 19 followed by 11</p>\n<p>3) Compile time error</p>\n<p>4) 10 followed by 1</p>\n<hr>\n<p>Question 26)</p>\n<p>If you run the code below, what gets printed out?</p>\n<pre><code>String s=new String(&quot;Bicycle&quot;);\nint iBegin=1;\nchar iEnd=3;\nSystem.out.println(s.substring(iBegin,iEnd));\n</code></pre><p>1) Bic</p>\n<p>2) ic</p>\n<p>3) icy</p>\n<p>4) error: no method matching substring(int,char)</p>\n<hr>\n<p>Question 27)</p>\n<p>If you wanted to find out where the position of the letter v (ie return 2) in the string s containing “Java”, which of the following could you use?</p>\n<p>1) mid(2,s);</p>\n<p>2) charAt(2);</p>\n<p>3) s.indexOf(‘v’);</p>\n<p>4) indexOf(s,’v’);</p>\n<hr>\n<p>Question 28)<br>Given the following declarations</p>\n<pre><code>String s1=new String(&quot;Hello&quot;)\nString s2=new String(&quot;there&quot;);\nString s3=new String();\n</code></pre><p>Which of the following are legal operations?</p>\n<p>1) s3=s1 + s2;</p>\n<p>2) s3=s1-s2;</p>\n<p>3) s3=s1 &amp; s2;</p>\n<p>4) s3=s1 &amp;&amp; s2</p>\n<hr>\n<p>Question 29)</p>\n<p>What is the result of the following operation?</p>\n<pre><code>System.out.println(4 | 3);\n</code></pre><p>1) 6</p>\n<p>2) 0</p>\n<p>3) 1</p>\n<p>4) 7</p>\n<hr>\n<p>Question 30)</p>\n<pre><code>public class MyClass1 {\npublic static void main(String argv[]){ }\n/*Modifier at XX */ class MyInner {}\n}\n</code></pre><p>What modifiers would be legal at XX in the above code?</p>\n<p>1) public</p>\n<p>2) private</p>\n<p>3) static</p>\n<p>4) friend</p>\n<hr>\n<p>Question 31)</p>\n<p>What will happen when you attempt to compile and run the following code?</p>\n<pre><code>public class Holt extends Thread{\n    private String sThreadName;\n    public static void main(String argv[]){\n            Holt h = new Holt();\nh.go(); }\nHolt(){}\nHolt(String s){\n    sThreadName = s;\n}\npublic String getThreadName(){\n    return sThreadName;\n}\npublic void go(){\n    Holt first = new Holt(&quot;first&quot;);\n   }\nfirst.start();\nHolt second = new Holt(&quot;second&quot;);\nsecond.start();\npublic void start(){\n    for(int i = 0; i &lt; 2; i ++){\n}\n} }\ntry{\n    System.out.println(getThreadName() +i);\n    Thread.sleep(100);\n                    } catch(InterruptedException\n    e){System.out.println(e.getMessage());}\n</code></pre><p>1) Compile time error</p>\n<p>2) Output of first0, second0, first0, second1</p>\n<p>3) Output of first0, first1, second0, second1</p>\n<p>4) Runtime error</p>\n<hr>\n<p>Question 32)</p>\n<p>An Applet has its Layout Manager set to the default of FlowLayout. What code would be correct to change to another Layout Manager.</p>\n<p>1) setLayoutManager(new GridLayout());</p>\n<p>2) setLayout(new GridLayout(2,2));</p>\n<p>3) setGridLayout(2,2);</p>\n<p>4) setBorderLayout();</p>\n<hr>\n<p>Question 33)</p>\n<p>What will happen when you attempt to compile and run the following code?.</p>\n<pre><code>class Background implements Runnable{\n    int i=0;\n           public int run(){\n                    while(true){\n                              return 1;\n     }//End run\n}//End class\ni++;\nSystem.out.println(&quot;i=&quot;+i);\n} //End while\n</code></pre><p>1) It will compile and the run method will print out the increasing value of i.</p>\n<p>2) It will compile and calling start will print out the increasing value of i.</p>\n<p>3) The code will cause an error at compile time.</p>\n<p>4) Compilation will cause an error because while cannot take a parameter of true.</p>\n<hr>\n<p>Question 34)</p>\n<p>Which of the following statements about this code are true?</p>\n<pre><code>public class Morecombe{\npublic static void main(String argv[]){\n    Morecombe m = new Morecombe();\n    m.go(new Turing(){});\n}\npublic void go(Turing t){\nt.start(); \n}\n}\nclass Turing extends Thread{\n    public void run(){\n           for(int i =0; i &lt; 2; i++){\n                   System.out.println(i);\n} }\n</code></pre><p>1) Compilation error due to malformed parameter to go method</p>\n<p>2) Compilation error, class Turing has no start method</p>\n<p>3) Compilation and output of 0 followed by 1</p>\n<p>4) Compilation but runtime error</p>\n<hr>\n<p>Question 35)</p>\n<p>What will be the result when you attempt to compile and run the following code?.</p>\n<pre><code>public class Conv{\npublic static void main(String argv[]){\n    Conv c=new Conv();\n    String s=new String(&quot;ello&quot;);\n}\n  c.amethod(s);\n}\npublic void amethod(String s){\n    char c=&apos;H&apos;;\n     c+=s;\n    System.out.println(c);\n    }\n}\n</code></pre><p>1) Compilation and output the string “Hello”</p>\n<p>2) Compilation and output the string “ello”</p>\n<p>3) Compilation and output the string elloH</p>\n<p>4) Compile time error</p>\n<hr>\n<p>Question 36)</p>\n<p>Given the following code, what test would you need to put in place of the comment line?</p>\n<pre><code>//place test here\nto result in an output of the string\nEqual\npublic class EqTest{\n     public static void main(String argv[]){\n            EqTest e=new EqTest();\n}\n    EqTest(){\n            String s=&quot;Java&quot;;\n            String s2=&quot;java&quot;;\n            //place test here {\n   }\n} }\nSystem.out.println(&quot;Equal&quot;);\n}else\n{\nSystem.out.println(&quot;Not equal&quot;);\n</code></pre><p>1) if(s==s2)</p>\n<p>2) if(s.equals(s2)</p>\n<p>3) if(s.equalsIgnoreCase(s2))</p>\n<p>4)if(s.noCaseMatch(s2))</p>\n<hr>\n<p>Question 37)</p>\n<p>Given the following code</p>\n<pre><code>import java.awt.*;\npublic class SetF extends Frame{\npublic static void main(String argv[]){\n     SetF s=new SetF();\n     s.setSize(300,200);\n     s.setVisible(true);\n }\n}\n</code></pre><p>How could you set the frame surface color to pink</p>\n<p>1)s.setBackground(Color.pink);</p>\n<p>2)s.setColor(PINK);</p>\n<p>3)s.Background(pink);</p>\n<p>4)s.color=Color.pink</p>\n<hr>\n<p>Question 38)</p>\n<p>How can you change the current working directory using an instance of the File class called FileName?</p>\n<p>1) FileName.chdir(“DirName”)</p>\n<p>2) FileName.cd(“DirName”)</p>\n<p>3) FileName.cwd(“DirName”)</p>\n<p>4) The File class does not support directly changing the current<br>directory.</p>\n<hr>\n<p>Question 39)</p>\n<p>If you create a TextField with a constructor to set it to occupy 5 columns, what difference will it make if you use it with a proportional font (ie Times Roman) or a fixed pitch typewriter style font (Courier).</p>\n<p>1)With a fixed font you will see 5 characters, with a proportional it will depend on the width of the characters</p>\n<p>2)With a fixed font you will see 5 characters,with a proportional it will cause the field to expand to fit the text</p>\n<p>3)The columns setting does not affect the number of characters displayed 4)Both will show exactly 5 characters</p>\n<hr>\n<p>Question 40)<br>Given the following code how could you invoke the Base constructor that will print out the string “base constructor”;</p>\n<pre><code>class Base{\n    Base(int i){\n    System.out.println(&quot;base constructor&quot;);\n    }\nBase(){\n    } }\npublic class Sup extends Base{\n    public static void main(String argv[]){\n    Sup s= new Sup();\n    //One }\n    Sup() {\n    //Two }\npublic void derived()\n{\n//Three }\n}\n</code></pre><p>1) On the line After //One put Base(10);</p>\n<p>2) On the line After //One put super(10);</p>\n<p>3) On the line After //Two put super(10);</p>\n<p>4) On the line After //Three put super(10);</p>\n<hr>\n<p>Question 41)</p>\n<p>Given the following code what will be output?</p>\n<pre><code>public class Pass{\nstatic int j=20;\npublic static void main(String argv[]){\n    int i=10;\n    Pass p = new Pass();\n    p.amethod(i);\n    System.out.println(i);\n    System.out.println(j);\n    }\npublic void amethod(int x){\n    x=x*2;\n        j=j*2; \n}\n}\n</code></pre><p>1) Error: amethod parameter does not match variable</p>\n<p>2) 20 and 40</p>\n<p>3) 10 and 40</p>\n<p>4) 10, and 20</p>\n<hr>\n<p>Question 42)</p>\n<p>What code placed after the comment //For loop would result in the population of every element of the array ia[] with a value from variable i.?</p>\n<pre><code>public class Lin{\npublic static void main(String argv[]){\n    Lin l = new Lin();\n    l.amethod();\n}\npublic void amethod(){\n\n    int ia[] = new int[4];\n    //Start For loop\n    {\n            ia[i]=i;\n            System.out.println(ia[i]);\n    }\n} }\n</code></pre><p>1) for(int i=0; i &lt; ia.length() -1; i++)</p>\n<p>2) for (int i=0; i&lt; ia.length(); i++)</p>\n<p>3) for(int i=1; i &lt; 4; i++)</p>\n<p>4) for(int i=0; i&lt; ia.length;i++)</p>\n<hr>\n<p>Question 43)</p>\n<p>What will be the result when you try to compile and run the following code?</p>\n<pre><code>private class Base{\n        Base(){\n        int i = 100;\n        System.out.println(i);\n        }\n}\npublic class Pri extends Base{\n    static int i = 200;\n        public static void main(String argv[]){\n    Pri p = new Pri();\n    System.out.println(i);\n    }\n}\n</code></pre><p>1) Error at compile time</p>\n<p>2) 200</p>\n<p>3) 100 followed by 200</p>\n<p>4) 100</p>\n<hr>\n<p>Question 44)</p>\n<p>What will the following code print out?</p>\n<pre><code>public class Oct{\n    public static void main(String argv[]){\n    Oct o = new Oct();\n    o.amethod();\n        }\n    public void amethod(){\n    int oi= 012;\n    System.out.println(oi);\n    }\n}\n</code></pre><p>1)12</p>\n<p>2)012</p>\n<p>3)10</p>\n<p>4)10.0</p>\n<hr>\n<p>Question 45</p>\n<p>What will happen when you try compiling and running this code?</p>\n<pre><code>public class Ref{\npublic static void main(String argv[]){\n    Ref r = new Ref();\n    r.amethod(r);\n}\npublic void amethod(Ref r){\n    int i=99;\n      multi(r);\n    System.out.println(i);\n}\npublic void multi(Ref r){\n    r.i = r.i*2;\n} }\n</code></pre><p>1) Error at compile time</p>\n<p>2) An output of 99</p>\n<p>3) An output of 198</p>\n<p>4) An error at runtime</p>\n<hr>\n<p>Question 46)</p>\n<p>You need to create a class that will store unique object elements. You do not need to sort these elements but they must be unique.<br>What interface might be most suitable to meet this need?</p>\n<p>1)Set</p>\n<p>2)List</p>\n<p>3)Map</p>\n<p>4)Vector</p>\n<hr>\n<p>Question 47)</p>\n<p>Which of the following will successfully create an instance of the Vector class and add an element?</p>\n<p>1) Vector v=new Vector(99);<br>v[1]=99;</p>\n<p>2) Vector v=new Vector();<br>v.addElement(99);</p>\n<p>3) Vector v=new Vector();<br>v.add(99);</p>\n<p>4 Vector v=new Vector(100);<br>v.addElement(“99”);</p>\n<hr>\n<p>Question 48)<br>You have created a simple Frame and overridden the paint method as follows</p>\n<pre><code>public void paint(Graphics g){\n    g.drawString(&quot;Dolly&quot;,50,10);\n}\n</code></pre><p>What will be the result when you attempt to compile and run the program?</p>\n<p>1) The string “Dolly” will be displayed at the centre of the frame</p>\n<p>2) An error at compilation complaining at the signature of the paint method </p>\n<p>3) The lower part of the word Dolly will be seen at the top of the frame, with the top hidden.</p>\n<p>4) The string “Dolly” will be shown at the bottom of the frame.</p>\n<hr>\n<p>Question 49)</p>\n<p>What will be the result when you attempt to compile this program?</p>\n<pre><code>public class Rand{\npublic static void main(String argv[]){\n    int iRand;\n    iRand = Math.random();\n    System.out.println(iRand);\n} }\n</code></pre><p>1) Compile time error referring to a cast problem</p>\n<p>2) A random number between 1 and 10</p>\n<p>3) A random number between 0 and 1</p>\n<p>4) A compile time error about random being an unrecognised method</p>\n<hr>\n<p>Question 50)</p>\n<p>Given the following code</p>\n<pre><code>import java.io.*;\npublic class Th{\npublic static void main(String argv[]){\n    Th t = new Th();\n    t.amethod();\n}\npublic void amethod(){\n    try{\n        ioCall();\n    }catch(IOException ioe){}\n\n} }\n</code></pre><p>What code would be most likely for the body of the ioCall method</p>\n<p>1) </p>\n<pre><code>public void ioCall ()throws IOException{\n DataInputStream din = new DataInputStream(System.in);\n din.readChar();\n }\n</code></pre><p>2) </p>\n<pre><code>public void ioCall ()throw IOException{\n     DataInputStream din = new DataInputStream(System.in);\n    din.readChar();\n }\n</code></pre><p>3) </p>\n<pre><code>public void ioCall (){\n     DataInputStream din = new DataInputStream(System.in);\n     din.readChar();\n }\n</code></pre><p>4) </p>\n<pre><code>public void ioCall throws IOException(){\n         DataInputStream din = new DataInputStream(System.in);\n             din.readChar();\n    }\n</code></pre><hr>\n<p>Question 51)<br>What will happen when you compile and run the following code?<br>public class Scope{<br>    private int i;<br>    public static void main(String argv[]){<br>        Scope s = new Scope();<br>        s.amethod();<br>    }//End of main<br>    public static void amethod(){<br>        System.out.println(i);<br>    }//end of amethod<br>}//End of class<br>1) A value of 0 will be printed out<br>2) Nothing will be printed out<br>3) A compile time error<br>4) A compile time error complaining of the scope of the variable i</p>\n<hr>\n<p>Question 52)</p>\n<p>You want to lay out a set of buttons horizontally but with more space between the first button and the rest. You are going to use the GridBagLayout manager to control the way the buttons are set out. How will you modify the way the GridBagLayout acts in order to change the spacing around the first button?</p>\n<p>1) Create an instance of the GridBagConstraints class, call the weightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<p>2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<p>3) Create an instance of the GridBagLayout class, set the weightx field and then call the setConstraints method of the GridBagLayoutClass with the component as a parameter.</p>\n<p>4) Create an instance of the GridBagLayout class, call the setWeightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<hr>\n<p>Question 53)</p>\n<p>Which of the following can you perform using the File class?</p>\n<p>1) Change the current directory</p>\n<p>2) Return the name of the parent directory</p>\n<p>3) Delete a file</p>\n<p>4) Find if a file contains text or binary information</p>\n<hr>\n<p>Question 54)</p>\n<p>Which statement is true of the following code?</p>\n<pre><code>public class Rpcraven{\n    public static void main(String argv[]){\n\n    Pmcraven pm1 = new Pmcraven(&quot;One&quot;);\n    pm1.run();\n    Pmcraven pm2 = new Pmcraven(&quot;Two&quot;);\n    pm2.run();\n} }\nclass Pmcraven extends Thread{\n    private String sTname=&quot;&quot;;\n    Pmcraven(String s){\n    sTname = s;\n}\npublic void run(){\n    for(int i =0; i &lt; 2 ; i++){\n           try{\n} }\n sleep(1000);\n}catch(InterruptedException e){}\nyield();\nSystem.out.println(sTname);\n}\n</code></pre><p>1) Compile time error, class Rpcraven does not import java.lang.Thread </p>\n<p>2) Output of One One Two Two</p>\n<p>3) Output of One Two One Two</p>\n<p>4) Compilation but no output at runtime</p>\n<hr>\n<p>Question 55)</p>\n<p>You are concerned that your program may attempt to use more memory than is available. To avoid this situation you want to ensure that the Java Virtual Machine will run its garbage collection just before you start a complex routine. What can you do to be certain that garbage collection will run when you want .</p>\n<p>1) You cannot be certain when garbage collection will run</p>\n<p>2) Use the Runtime.gc() method to force garbage collection</p>\n<p>3) Ensure that all the variables you require to be garbage collected are set to null</p>\n<p>4) Use the System.gc() method to force garbage collection</p>\n<hr>\n<p>Question 56)<br>You are using the GridBagLayout manager to place a series of buttons on a Frame. You want to make the size of one of the buttons bigger than the text it contains. Which of the following will allow you to do that?</p>\n<p>1) The GridBagLayout manager does not allow you to do this</p>\n<p>2) The setFill method of the GridBagLayout class</p>\n<p>3) The setFill method of the GridBagConstraints class</p>\n<p>4) The fill field of the GridBagConstraints class</p>\n<hr>\n<p>Question 57)</p>\n<p>Which of the following most closely describes a bitset collection?</p>\n<p>1) A class that contains groups of unique sequences of bits</p>\n<p>2) A method for flipping individual bits in instance of a primitive type </p>\n<p>3) An array of boolean primitives that indicate zeros or ones</p>\n<p>4) A collection for storing bits as on-off information, like a vector of bits</p>\n<hr>\n<p>Question 58)</p>\n<p>You have these files in the same directory. What will happen when you attempt to compile and run Class1.java if you have not already compiled Base.java</p>\n<pre><code>//Base.java\npackage Base;\nclass Base{\nprotected void amethod(){\n    System.out.println(&quot;amethod&quot;);\n}//End of amethod\n}//End of class base\n\npackage Class1;\n//Class1.java\npublic class Class1 extends Base{\npublic static void main(String argv[]){\n    Base b = new Base();\n    b.amethod();\n}//End of main\n}//End of Class1\n</code></pre><p>1) Compile Error: Methods in Base not found</p>\n<p>2) Compile Error: Unable to access protected method in base class</p>\n<p>3) Compilation followed by the output “amethod”</p>\n<p>4)Compile error: Superclass Class1.Base of class Class1.Class1 not found</p>\n<hr>\n<p>Question 59)<br>What will happen when you attempt to compile and run the following code<br>    class Base{<br>    private void amethod(int iBase){<br>        System.out.println(“Base.amethod”);<br>    }<br>    }<br>    class Over extends Base{<br>    public static void main(String argv[]){<br>        Over o = new Over();<br>        int iBase=0;<br>        o.amethod(iBase);<br>    }<br>    public void amethod(int iOver){<br>        System.out.println(“Over.amethod”);<br>    } }</p>\n<p>1) Compile time error complaining that Base.amethod is private</p>\n<p>2) Runtime error complaining that Base.amethod is private</p>\n<p>3) Output of “Base.amethod”</p>\n<p>4) Output of “Over.amethod”</p>\n<hr>\n<p>Question 60)</p>\n<p>You are creating an applet with a Frame that contains buttons. You are using the GridBagLayout manager and you have added Four buttons. At the moment the buttons appear in the centre of the frame from left to right. You want them to appear one on top of the other going down the screen. What is the most appropriate way to do this.</p>\n<p>1) Set the gridy value of the GridBagConstraints class to a value<br>increasing from 1 to 4</p>\n<p>2) set the fill value of the GridBagConstraints class to VERTICAL</p>\n<p>3) Set the ipady value of the GridBagConstraints class to a value<br>increasing from 0 to 4</p>\n<p>4) Set the fill value of the GridBagLayouts class to GridBag.VERTICAL<br>   Answer 1) Back to question 1) Objective 4.5)<br>5) int i=10;</p>\n<h2 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h2><p>explanation:</p>\n<p>1) float f=1.3;</p>\n<p>Will not compile because the default type of a number with a floating point component is a double. This would compile with a cast as in<br>float f=(float) 1.3</p>\n<p>2) char c=”a”;</p>\n<p>Will not compile because a char (16 bit unsigned integer) must be defined with single quotes. This would compile if it were in the form<br>char c=’a’;</p>\n<p>3) byte b=257;</p>\n<p>Will not compile because a byte is eight bits. Take of one bit for the sign component you can define numbers between<br>-128 to +127</p>\n<p>4) a boolean value can either be true or false, null is not allowed</p>\n<p>Answer 2)<br>Back to question 2)<br>Objective 4.1<br>1) Can’t make static reference to void amethod.<br>Because main is defined as static you need to create an instance of the class in order to call any non-static methods. Thus a typical way to do this would be.<br>MyClass m=new MyClass(); m.amethod();<br>Answer 2 is an attempt to confuse because the convention is for a main method to be in the form String argv[]<br>That argv is just a convention and any acceptable identifier for a string array can be used. </p>\n<p>Answers3 and 4 are just nonsense.<br> Answer 3)</p>\n<p>back to Question 3) Objective 4.1)<br>2 and 3 will compile without error.<br>1 will not compile because any package declaration must come before any other code. Comments may appear anywhere. </p>\n<p>Answer 4)<br>Back to question 4) Objective 4.5)<br>1) A byte is a signed 8 bit integer.<br> Answer 5)<br>Back to question 5) Objective 4.2)<br>4) Exception raised: “java.lang.ArrayIndexOutOfBoundsException: 2”<br>Unlike C/C++ java does not start the parameter count with the program name. It does however start from zero. So in this case zero starts with good, morning would be 1 and there is no parameter 2 so an exception is raised.</p>\n<p>Answer 6)<br>Back to question 6) Objective 4.3)<br>1) if<br>3) goto 4) while<br>5) case<br>then is not a Java keyword, though if you are from a VB background you might think it was. Goto is a reserved word in Java.</p>\n<p>Answer 7)<br>Back to Question 7)<br>Objective 4.1)<br>2) variable2<br>3) _whatavariable 4) _3_<br>5) $anothervar</p>\n<p>An identifier can begin with a letter (most common) or a dollar sign($) or an underscore(_). An identifier cannot start with anything else such as a number, a hash, # or a dash -. An identifier cannot have a dash in its body, but it may have an underscore _. Choice 4) _3_ looks strange but it is an acceptable, if unwise form for an identifier.</p>\n<p> Answer 8)</p>\n<p>Back to Question 8) Objective 4.4)<br>4) 0<br>Class level variables are always initialised to default values. In the case of an int this will be 0. Method level variables are not given default values and if you attempt to use one before it has been initialised it will cause the<br>Error Variable i may not have been initialized type of error.</p>\n<p> Answer 9)<br>Back to Question 9) Objective 4.4)<br>3)2<br>No error will be triggered.<br>Like in C/C++, arrays are always referenced from 0. Java allows an array to be populated at creation time. The size of array is taken from the number of initializers. If you put a size within any of the square brackets you will get an error.</p>\n<p> Answer 10)<br>Back to question 10) Objective 4.4)<br>3) 0<br>Arrays are always initialised when they are created. As this is an array of ints it will be initalised with zeros.</p>\n<p> Answer 11)<br>Back to Question 11) Objective 1.2<br>3) Error Mine must be declared abstract<br>A class that contains an abstract method must itself be declared as abstract. It may however contain non abstract methods. Any class derived from an abstract class must either define all of the abstract methods or be declared abstract itself.</p>\n<p> Answer 12)</p>\n<p>Back to Question 12) Objective 2.1)<br>3) one, two, default<br>Code will continue to fall through a case statement until it encounters a break.</p>\n<p> Answer 13)</p>\n<p>Back to Question 13) Objective 4.1)<br>2) default, zero<br>Although it is normally placed last the default statement does not have to be the last item as you fall through the case block. Because there is no case label found matching the expression the default label is executed and the code continues to fall through until it encounters a break.</p>\n<p> Answer 14)</p>\n<p>Back to Question 14) Objective 5.1<br>2,3<br>Example 1 will not compile because if must always test a boolean. This can catch out C/C++ programmers who expect the test to be for either 0 or not 0.</p>\n<p> Answer 15)</p>\n<p>Back to Question 15) Objective 11.5)<br>3) No such file found, doing finally, -1<br>The no such file found message is to be expected, however you can get caught out if you are not aware that the finally clause is almost always executed, even if there is a return statement.</p>\n<p>Answer 16)</p>\n<p>Back to Question 16) Objective 6.2)<br>1) Methods cannot be overriden to be more private<br>Static methods cannot be overriden but they can be overloaded. If you have doubts about that statement, please follow and read carefully the link given to the Sun tutorial below. There is no logic or reason why private methods should not be overloaded. Option 4 is a jumbled up version of the limitations of exceptions for overriden methods</p>\n<p>Answer 17)</p>\n<p>Back to Question 17) Objective 6.2)<br>3) Runtime Exception<br>Without the cast to sub you would get a compile time error. The cast tells the compiler that you really mean to do this and the actual type of b does not get resolved until runtime. Casting down the object hierarchy is a problem, as the compiler cannot be sure what has been implemented in descendent classes. Casting up is not a problem because sub classes will have the features of the base classes. This can feel counter intuitive if you are aware that with primitives casting is allowed for widening operations (ie byte to int).</p>\n<p>Answer 18)</p>\n<p>Back to question 18) Objective 5.1)<br>1) System.out.println( -1 &gt;&gt;&gt; 2);will output a result larger than 10 2) System.out.println( -1 &gt;&gt;&gt; 2); will output a positive number<br>3) System.out.println( 2 &gt;&gt; 1); will output the number 1<br>You can test this with the following class<br>public class shift{<br>static int i=2;<br>public static void main(String argv[]){<br>System.out.println( -1 System.out.println( -1 System.out.println( 2 }<br>>>> 2);<br>>>> 2); >> 1);<br>}<br>Java does not have a \\&lt;\\&lt;\\&lt; operator. The operation 1 \\&lt;\\&lt; 2 would output 4<br>Because of the way twos complement number representation works the unsigned right shift operation means a small shift in a negative number can return a very large value so the output of<br>option 1 will be much larger than 10.<br>The unsigned right shift places no significance on the leading bit that indicates the sign. For this shift the value 1 of the bit sign is replaced with a zero turning the result into a positive number for option 2.</p>\n<p> Answer 19)</p>\n<p>Back to Question 19) Objective 7.1)<br>4) Compilation and output of either “vandaleur”, “vandaleur 0”, “vandaleur 0 1” “vandaleur 0 1 2” or “vandaleur 0 1 2 3”<br>If that seems a vauge answer it is because you cannot be certain of the system that the underlying OS uses for allocating cycles for a Thread. The chances are that once the thread has been spun off in the call to start in the method piggy the main method will run to completion and the value of sName will still be vandeluer before the Thread modifies it. You cannot be certain of this though.</p>\n<p> Answer 20)</p>\n<p>Back to Question 20) Objective 8.1)<br>3) One button occupying the entire frame saying Bye<br>The default layout manager for a Frame is a border layout. If directions are not given (ie North, South, East or West), any button will simply go in the centre and occupy all the space. An additional button will simply be placed over the previous button. What you would probably want in a real example is to set up a flow layout as in<br>setLayout(new FlowLayout());<br>Which would allow the buttons to both appear side by side, given the appropriate font and size. Applets and panels have a default FlowLayout manager</p>\n<p> Answer 21)</p>\n<p>Back to Question 21) Objective 2.2)<br>1,2<br>Value for i=1 Value for j=1 Value for i=2 Value for j=1<br>The statement continue outer causes the code to jump to the label outer and the for loop increments to the next number.</p>\n<p> Answer 22)</p>\n<p>Back to Question 22)<br>Objective 7.3)<br>4) Runtime error, an exception will be thrown<br>A call to wait/notify must be within synchronized code. With JDK1.2 this code throws the error message<br>java.lang.IllegalMonitorStateException: currentthreadnotowner at java.lang.Object.wait(Native Method)<br>at java.lang.Object.wait(Object.java:424) at DSRoss.notwait(Compiled Code)<br>at DSRoss.run(Agg.java:21)</p>\n<p> Answer 23)</p>\n<p>Back to Question 23) Objective 2.3)<br>2,3<br>Options 1, &amp; 4 will not compile as they attempt to throw Exceptions not declared in the base class. Because options 2 and 3 take a parameter of type long they represent overloading not overriding and there is no such limitations on overloaded methods.</p>\n<p> Answer 24)</p>\n<p>Back to Question 24) Objective 9.1)<br>3) System.out.println(Math.ceil(-4.7));<br>Options 1 and 2 will produce -5 and option 4 will not compile because the min method requires 2 parameters.</p>\n<p> Answer 25)</p>\n<p>Back to Question 25 Objective 4.5)<br>3) Compile time error<br>The wrapper classes cannot be used like primitives.<br>Depending on your compiler you will get an error that says someting like “Error: Can’t convert java lang Integer”. Wrapper classes have similar names to primitives but all start with upper case letters.<br>Thus in this case we have int as a primitive and Integer as a wrapper. The objectives do not specifically mention the wrapper classes but don’t be surprised if they come up.</p>\n<p> Answer 26)</p>\n<p>Back to Question 26) Objective 4.5)<br>2) ic<br>This is a bit of a catch question. Anyone with a C/C++ background would figure out that addressing in strings starts with 0 so that 1 corresponds to i in the string Bicycle. The catch is that the second parameter returns the endcharacter minus 1. In this case it means instead of the “icy” being returned as intuition would expect it is only “ic”.</p>\n<p> Answer 27)</p>\n<p>Back to Question 27) Objective 9.2)<br>3) s.indexOf(‘v’);<br>charAt returns the letter at the position rather than searching for a letter and returning the position, MID is just to confuse the Basic Programmers, indexOf(s,’v’); is how some future VB/J++ nightmare hybrid, might perform such a calculation.</p>\n<p> Answer 28)</p>\n<p>Objective 5.1)<br>Back to Question 28<br>1) s3=s1 + s2;<br>Java does not allow operator overloading as in C++, but for the sake of convenience the + operator is overridden for strings.</p>\n<p>Answer 29)</p>\n<p>Back to Question 29) Objective 5.3)<br>4) 7<br>The | is known as the Or operator, you could think of it as the either/or operator. Turning the numbers into binary gives<br>4=100 3=011<br>For each position, if either number contains a 1 the result will contain a result in that position. As every position contains a 1 the result will be<br>111<br>Which is decimal 7.</p>\n<p> Answer 30)</p>\n<p>Back to Question 30 Objective 4.1)<br>1,2,3<br>public, private, static are all legal access modifiers for this inner class.</p>\n<p> Answer 31)</p>\n<p>Back to Question 31 Objective 7.1<br>3) Output of first0, first1, second0, second1<br>Note that this code overrides and calls the start method. If you wished to get the output mixed you would need to override the run method but call the start method.</p>\n<p> Answer 32)</p>\n<p>Back to Question 32) Objective 8.1)<br>2) setLayout(new GridLayout(2,2));<br>Changing the layout manager is the same for an Applet or an application. Answer 1 is wrong though it might have been a reasonable name for the designers to choose. Answers 3 and 4 are incorrect because changing the layout manager always requires an instance of one of the Layout Managers and these are bogus methods.<br>Instead of creating the anonymous instance of the Layout manager as in option 2 you can also create a named instance and pass that as a parameter. This is often what automatic code generators such as Borland/Inprise JBuilder do.</p>\n<p> Answer 33)</p>\n<p>Back to Question 33) Objective 7.1)<br>3) The code will cause an error at compile time<br>The error is caused because run should have a void not an int return type.<br>Any class that is implements an interface must create a method to match all of the methods in the interface. The Runnable interface has one method called run that has a void return type.The sun<br>compiler gives the error<br>Method redefined with different return type: int run() was defined as void run();</p>\n<p> Answer 34)</p>\n<p>Back to Question 34) Objective 7.1)<br>3) Compilation and output of 0 followed by 1<br>The creation of an anonymous class as a parameter to go is fairly strange as you would expect it to override a method in its parent class (Turing). You don’t have to though. The fact that class Turing extends Thread means the anonymous instance that is passed to go has a start method which then calls the run method.</p>\n<p> Answer 35)</p>\n<p>Back to Question 35 Objective 5.1)<br>4) Compile time error<br>The only operator overloading offered by java is the + sign for the String class. Achar is a 16 bit integer and cannot be concatenated to a string with the + operator.</p>\n<p> Answer 36)</p>\n<p>Back to Question 36 Objective 5.2)<br>3) if(s.equalsIgnoreCase(s2))<br>String comparison is case sensitive so using the equals string method will not return a match. Using the==operator just compares where memory address of the references and noCaseMatch was just something I made up to give me a fourth slightly plausible option.</p>\n<p> Answer 37)</p>\n<p>Back to Question 37 Objective 8.1)<br>1) s.setBackground(Color.pink);<br>For speakers of the more British spelt English note that there is no letter u in Color. Also the constants for colors are in lower case.</p>\n<p> Answer 38)</p>\n<p>Back to Question 38) Objective 11.1)<br>4) The File class does not support directly changing the current directory.<br>This seems rather surprising to me, as changing the current directory is a very common requirement. You may be able to get around this limitation by creating a new instance of the File class passing the new directory to the constructor as the path name.</p>\n<p> Answer 39)</p>\n<p>Back to Question 39) Objective 8.1)<br>1)With a fixed font you will see 5 characters, with a the characters<br>proportional it will depend on the width of<br>With a proportional font the letter w will occupy more space than the letter i. So if you have all wide characters you may have to scroll to the right to see the entire text of a TextField.</p>\n<p>Answer 40)</p>\n<p>Back to Question 40) Objective 6.2<br>3) On the line After //Two put super(10);<br>Constructors can only be invoked from within constructors. </p>\n<p>Answer 41)</p>\n<p>Back to Question 41) Objective 5.4)<br>3) 10 and 40<br>when a parameter is passed to a method the method receives a copy of the value. The method can modify its value without affecting the original copy. Thus in this example when the value is printed out the method has not changed the value.</p>\n<p>Answer 42)</p>\n<p>Back to Question 42 Objective 1.1<br>4) for(int i=0; i&lt; ia.length;i++)<br>Although you could control the looping with a literal number as with the number 4 used in option 3, it is better practice to use the length property of an array. This provides against bugs that might result if the size of the array changes. This question also checks that you know that arrays starts from zero and not One as option 3 starts from one. Remember that array length is a field and not a function like the String length() method.</p>\n<p>Answer 43)<br>Back to Question 43) Objective 1.2<br>1) Error at compile time<br>This is a slightly sneaky one as it looks like a question about constructors, but it is attempting to test knowledge of the use of the private modifier. A top level class cannot be defined as private. If you didn’t notice the modifier private, remember in the exam to be real careful to read every part of the question.</p>\n<p>Answer 44)</p>\n<p>Back to Question 44 Objective 4.5)<br>3)10<br>The name of the class might give you a clue with this question, Oct for Octal. Prefixing a number with a zero indicates that it is in Octal format. Thus when printed out it gets converted to base ten. 012 in octal means the first column from the right has a value of 2 and the next along has a value of one times eight. In decimal that adds up to 10.</p>\n<p> Answer 45)</p>\n<p>Back to Question 45 Objective 1.2)<br>1) Error at compile time<br>The variable i is created at the level of amethod and will not be available inside the method multi.</p>\n<p>Answer 46)</p>\n<p>Back to Question 46 Objective 10.1)<br>1) Set<br>The Set interface ensures that its elements are unique, but does not order the elements. In reality you probably wouldn’t create your own class using the Set interface. You would be more likely to use one of the JDK classes that use the Set interface such as HashSet or TreeSet.</p>\n<p> Answer 47)</p>\n<p>Back to Question 47 Objective 10.1)<br>4) Vector v=new Vector(100); v.addElement(“99”)<br>A vector can only store objects not primitives. The parameter “99” for the addElement method pases a string object to the Vector. Option 1) creates a vector OK but then uses array syntax to attempt to assign a primitive. Option 2 also creates a vector then uses correct Vector syntax but falls over when the parameter is a primitive instead of an object.<br>Answer 48)</p>\n<p>Objective 8.1)<br>Back to Question 48<br>3) The lower part of the word Dolly will be seen at the top of the form<br>The Second parameter to the drawstring method indicates where the baseline of the string will be placed. Thus the 3rd parameter of 10 indicates the Y coordinate to be 10 pixels from the top of the Frame. This will result in just the bottom of the string Dolly showing up or possibly only the descending part of the letter y.</p>\n<p>Answer 49)</p>\n<p>Back to Question 49) Objective 9.1)<br>1) Compile time error referring to a cast problem<br>This is a bit of a sneaky one as the Math.random method returns a pseudo random number between 0 and 1, and thus option 3 is a plausible Answer. However the number returned is a double and so the compiler will complain that a cast is needed to convert a double to an int.</p>\n<p> Answer 50)</p>\n<p>Objective 2.3) Back to question 50<br>1) public void ioCall ()throws IOException{ DataInputStream din = new DataInputStream(System.in); din.readChar();<br>}<br>If a method might throw an exception it must either be caught within the method with a try/catch block, or the method must indicate the exception to any calling method by use of the throws statement in its declaration. Without this, an error will occur at compile time.</p>\n<p> Answer 51)</p>\n<p>Objective 1.2)<br>Back to Question 51)<br>3) A compile time error<br>Because only one instance of a static method exists not matter how many instance of the class exists it cannot access any non static variables. The JVM cannot know which instance of the variable to access. Thus you will get an error saying something like<br>Can’t make a static reference to a non static variable </p>\n<p>Answer 52)</p>\n<p>Objective 8.1)<br>Back to Question 52)<br>2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.<br>The Key to using the GridBagLayout manager is the GridBagConstraint class. This class is not consistent with the general naming conventions in the java API as you would expect that weightx would be set with a method, whereas it is a simple field (variable).<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error which is corrected in later versions of the book</p>\n<p>Answer 53)</p>\n<p>Objective 11.1)<br>Back to Question 53)<br>2) Return the name of the parent directory 3) Delete a file<br>It is surprising that you can’t change the current directory. It is not so surprising that you can’t tell if a file contains text or binary information.</p>\n<p> Answer 54)</p>\n<p>Back to Question 54) Objective 7.1<br>2) Output of One One Two Two<br>Answer 3 would would be true if the code called the start method instead of the run method (well it is on my Windows machine anyway, I’m not sure it would be for ever implementation of Java Threads). If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished executing.</p>\n<p>Answer 55)</p>\n<p>Objective 3.1)<br>Back to Question 55)<br>1) You cannot be certain when garbage collection will run<br>Although there is a Runtime.gc(), this only suggests that the Java Virtual Machine does its garbage collection. You can never be certain when the garbage collector will run. Roberts and Heller is more specific abou this than Boone. This uncertainty can cause consternation for C++ programmers who wish to run finalize methods with the same intent as they use destructor methods.</p>\n<p>Answer 56)</p>\n<p>Objective 8.1)<br>Back to Question 56)<br>4) The fill field of the GridBagConstraints class<br>Unlike the GridLayout manager you can set the individual size of a control such as a button using the GridBagLayout manager. A little background knowledge would indicate that it should be controlled by a setSomethingOrOther method, but it isn’t.<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at</p>\n<p>Answer 57)</p>\n<p>Objective 10.1)<br>Back to Question 57)<br>4) A collection for storing bits as on-off information, like a vector of bits<br>This is the description given to a bitset in Bruce Eckels “Thinking in Java” book. The reference to unique sequence of bits was an attempt to mislead because of the use of the word Set in the name bitset. Normally something called a set implies uniqueness of the members, but not in this context.</p>\n<p>Answer 58)</p>\n<p>Back to Question 58) Objective 4.1)<br>4)Compile error: Superclass Class1.Base of class Class1.Class1 not found<br>Using the package statement has an effect similar to placing a source file into a different directory. Because the files are in different packages they cannot see each other. The stuff about File1 not having been compiled was just to mislead, java has the equivalent of an “automake”, whereby if it was not for the package statements the other file would have been automatically compiled.</p>\n<p> Answer 59)</p>\n<p>Back to Question 59) Objective 6.2)<br>4) Output of Over.amethod()<br>The names of parameters to an overridden method is not important, but as the version of amethod in class Base is set to be private it is not visible within Over (despite Over extending Base) and thus does not take part in overriding.</p>\n<p>Answer 60)</p>\n<p>Objective 8.1)<br>Back to Question 60)<br>1) Set the gridy value of the GridBagConstraints class to a value increasing from 1 to 4<br>Answer 4 is fairly obviously bogus as it is the GridBagConstraints class that does most of the magic in laying out components under the GridBagLayout manager. The fill value of the GridBagConstraints class controls the behavior inside its virtual cell and the ipady field controls the internal padding around a component.<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><p>Question 1)<br>Which of the following lines will compile without warning or error.</p>\n<p>1) float f=1.3;</p>\n<p>2) char c=”a”;</p>\n<p>3) byte b=257;</p>\n<p>4) boolean b=null;</p>\n<p>5) int i=10;</p>\n<hr>\n<p>Question 2)</p>\n<p>What will happen if you try to compile and run the following code</p>\n<pre><code>public class MyClass {\npublic static void main(String arguments[]) {\n    amethod(arguments);\n}\npublic void amethod(String[] arguments) {\n    System.out.println(arguments);\n    System.out.println(arguments[1]);\n} \n}\n</code></pre><p>1) error Can’t make static reference to void amethod.</p>\n<p>2) error method main not correct</p>\n<p>3) error array must include parameter</p>\n<p>4) amethod must be declared with String</p>\n<hr>\n<p>Question 3)</p>\n<p>Which of the following will compile without error</p>\n<p>1)</p>\n<pre><code>import java.awt.*;\npackage Mypackage;\nclass Myclass {}\n</code></pre><p>2)</p>\n<pre><code>package MyPackage;\nimport java.awt.*;\nclass MyClass{}\n</code></pre><p>3)</p>\n<pre><code>/*This is a comment */\npackage MyPackage;\nimport java.awt.*;\nclass MyClass{}\n</code></pre><hr>\n<p>Question 4)</p>\n<p>A byte can be of what size</p>\n<p>1) -128 to 127</p>\n<p>2) (-2 power 8 )-1 to 2 power 8</p>\n<p>3) -255 to 256</p>\n<p>4)depends on the particular implementation of the Java Virtual machine</p>\n<hr>\n<p>Question 5)</p>\n<p>What will be printed out if this code is run with the following command line?</p>\n<pre><code>java myprog good morning\n\npublic class myprog{\npublic static void main(String argv[])\n{\n    System.out.println(argv[2]);\n}\n}\n</code></pre><p>1) myprog</p>\n<p>2) good</p>\n<p>3) morning</p>\n<p>4) Exception raised: “java.lang.ArrayIndexOutOfBoundsException: 2”</p>\n<hr>\n<p>Question 6)</p>\n<p>Which of the following are keywords or reserved words in Java?</p>\n<p>1) if</p>\n<p>2) then</p>\n<p>3) goto</p>\n<p>4) while</p>\n<p>5) case</p>\n<hr>\n<p>Question 7)</p>\n<p>Which of the following are legal identifiers</p>\n<p>1) 2variable</p>\n<p>2) variable2</p>\n<p>3) _whatavariable</p>\n<p>4) _3_</p>\n<p>5) $anothervar</p>\n<p>6) #myvar</p>\n<hr>\n<p>Question 8)</p>\n<p>What will happen when you compile and run the following code?</p>\n<pre><code>public class MyClass{\n static int i;\n public static void main(String argv[]){\n System.out.println(i);\n }\n}\n</code></pre><p>1) Error Variable i may not have been initialized</p>\n<p>2) null</p>\n<p>3) 1</p>\n<p>4) 0</p>\n<hr>\n<p>Question 9)</p>\n<p>What will happen if you try to compile and run the following code?</p>\n<pre><code>public class Q {\n     public static void main(String argv[]){\n     int anar[]=new int[]{1,2,3};\n     System.out.println(anar[1]);\n     }\n}\n</code></pre><p>1) 1</p>\n<p>2) Error anar is referenced before it is initialized</p>\n<p>3) 2</p>\n<p>4) Error: size of array must be defined</p>\n<hr>\n<p>Question 10)</p>\n<p>What will happen if you try to compile and run the following code?</p>\n<pre><code>public class Q {\n public static void main(String argv[]){\n     int anar[]=new int[5];\n     System.out.println(anar[0]);\n }\n}\n</code></pre><p>1) Error: anar is referenced before it is initialized</p>\n<p>2) null</p>\n<p>3) 0</p>\n<p>4) 5</p>\n<hr>\n<p>Question 11)</p>\n<p>What will be the result of attempting to compile and run the following code?</p>\n<pre><code>abstract class MineBase {\n abstract void amethod();\n static int i;\n}\n\npublic class Mine extends MineBase {\n public static void main(String argv[]){\n int[] ar=new int[5];\n for(i=0;i &lt; ar.length;i++)\n System.out.println(ar[i]);\n} }\n</code></pre><p>1) a sequence of 5 0’s will be printed</p>\n<p>2) Error: ar is used before it is initialized</p>\n<p>3) Error Mine must be declared abstract</p>\n<p>4) IndexOutOfBoundes Error</p>\n<hr>\n<p>Question 12)</p>\n<p>What will be printed out if you attempt to compile and run the following code ?</p>\n<pre><code>int i=1;\n switch (i) {\n case 0:\n System.out.println(&quot;zero&quot;);\n break;\n case 1:\n System.out.println(&quot;one&quot;);\n case 2:\n System.out.println(&quot;two&quot;);\n default:\n System.out.println(&quot;default&quot;);\n }\n</code></pre><p>1) one</p>\n<p>2) one, default</p>\n<p>3) one, two, default</p>\n<p>4) default</p>\n<hr>\n<p>Question 13)</p>\n<p>What will be printed out if you attempt to compile and run the following code?</p>\n<pre><code>int i=9;\nswitch (i) {\n default:\n System.out.println(&quot;default&quot;);\n case 0:\n System.out.println(&quot;zero&quot;);\n break;\n case 1:\n System.out.println(&quot;one&quot;);\n case 2:\n System.out.println(&quot;two&quot;);\n}\n</code></pre><p>1) default</p>\n<p>2) default, zero</p>\n<p>3) error default clause not defined</p>\n<p>4) no output displayed</p>\n<hr>\n<p>Question 14)</p>\n<p>Which of the following lines of code will compile without error</p>\n<p>1)</p>\n<pre><code>int i=0;\nif(i) {\n     System.out.println(&quot;Hello&quot;);\n }\n</code></pre><p>2)</p>\n<pre><code>boolean b=true;\nboolean b2=true;             \nif(b==b2) {\n     System.out.println(&quot;So true&quot;);\n }\n</code></pre><p>3)</p>\n<pre><code>int i=1;\nint j=2;\nif(i==1|| j==2)\n System.out.println(&quot;OK&quot;);\n</code></pre><p>4)</p>\n<pre><code>int i=1;\nint j=2;\nif(i==1 &amp;| j==2)\n System.out.println(&quot;OK&quot;);\n</code></pre><hr>\n<p>Question 15)</p>\n<p>What will be output if you try to compile and run the following code, but there is no file called Hello.txt in the current directory?.</p>\n<pre><code>import java.io.*;\npublic class Mine {\n    public static void main(String argv[]){\n        Mine m=new Mine();\n        System.out.println(m.amethod());\n    }\n    public int amethod() {\n    try {\n        FileInputStream dis=new FileInputStream(&quot;Hello.txt&quot;);\n    }catch (FileNotFoundException fne) {\n        System.out.println(&quot;No such file found&quot;);\n        return -1;\n    }catch(IOException ioe) {\n    } finally{\n        System.out.println(&quot;Doing finally&quot;);\n    }\nreturn 0; }       \n}\n</code></pre><p>1) No such file found</p>\n<p>2 No such file found ,-1</p>\n<p>3) No such file found, Doing finally, -1</p>\n<p>4) 0</p>\n<hr>\n<p>Question 16)</p>\n<p>Which of the following statements are true?</p>\n<p>1) Methods cannot be overriden to be more private</p>\n<p>2) static methods cannot be overloaded</p>\n<p>3) private methods cannot be overloaded</p>\n<p>4) An overloaded method cannot throw exceptions not checked in the base class</p>\n<hr>\n<p>Question 17)</p>\n<p>What will happen if you attempt to compile and run the following code?</p>\n<pre><code>class Base {}\nclass Sub extends Base {}\nclass Sub2 extends Base {}\npublic class CEx{\n    public static void main(String argv[]){\n    Base b=new Base();\n    Sub s=(Sub) b;\n    } \n}\n</code></pre><p>1) Compile and run without error</p>\n<p>2) Compile time Exception</p>\n<p>3) Runtime Exception</p>\n<hr>\n<p>Question 18)</p>\n<p>Which of the following statements are true?</p>\n<p>1) System.out.println( -1 &gt;&gt;&gt; 2);will output a result larger than 10 </p>\n<p>2) System.out.println( -1 &gt;&gt;&gt; 2); will output a positive number</p>\n<p>3) System.out.println( 2 &gt;&gt; 1); will output the number 1</p>\n<p>4) System.out.println( 1 &lt;&lt;&lt; 2); will output the number 4</p>\n<hr>\n<p>Question 19)</p>\n<p>What will happen when you attempt to compile and run the following code?</p>\n<pre><code>public class Tux extends Thread{\n    static String sName = &quot;vandeleur&quot;;\n    public static void main(String argv[]){\n    Tux t = new Tux();\n    t.piggy(sName);\n    System.out.println(sName);\n    }\n    public void piggy(String sName){\n            sName = sName + &quot; wiggy&quot;;\n    start();\n    }\n    public void run(){\n    for(int i=0;i  &lt;  4; i++){\n            sName = sName + &quot; &quot; + i;\n} }\n}\n</code></pre><p>1) Compile time error</p>\n<p>2) Compilation and output of “vandeleur wiggy”</p>\n<p>3) Compilation and output of “vandeleur wiggy 0 1 2 3”</p>\n<p>4) Compilation and output of either “vandeleur”, “vandeleur 0”, “vandeleur 0 1” “vandaleur 0 1 2” or “vandaleur 0 1 2 3”</p>\n<hr>\n<p>Question 20)</p>\n<p>What will be displayed when you attempt to compile and run the following code</p>\n<pre><code>//Code start\nimport java.awt.*;\npublic class Butt extends Frame{\n    public static void main(String argv[]){\n    Butt MyBut=new Butt();\n} \nButt(){\n    Button HelloBut=new Button(&quot;Hello&quot;);\n    Button ByeBut=new Button(&quot;Bye&quot;);\n    add(HelloBut);\n    add(ByeBut);\n    setSize(300,300);\n    setVisible(true);\n   }\n}\n//Code end`\n</code></pre><p>1) Two buttons side by side occupying all of the frame, Hello on the left and Bye on the right</p>\n<p>2) One button occupying the entire frame saying Hello</p>\n<p>3) One button occupying the entire frame saying Bye</p>\n<p>4) Two buttons at the top of the frame one saying Hello the other saying Bye</p>\n<hr>\n<p>Question 21)</p>\n<p>What will be output by the following code?</p>\n<pre><code>public class MyFor{\npublic static void main(String argv[]){\nint i;\nint j; \n    outer:\n    for (i=1;i &lt;3;i++)\n        inner:\n    for(j=1; j&lt;3; j++) {\n        if (j==2)\n   continue outer;\nSystem.out.println(&quot;Value for i=&quot; + i + &quot; Value for j=&quot; +j);\n} }\n}\n</code></pre><p>1) Value for i=1 Value for j=1</p>\n<p>2) Value for i=2 Value for j=1</p>\n<p>3) Value for i=2 Value for j=2</p>\n<p>4) Value for i=3 Value for j=1</p>\n<hr>\n<p>Question 22)</p>\n<p>Which statement is true of the following code?</p>\n<pre><code>public class Agg{\npublic static void main(String argv[]){\n    Agg a = new Agg();\n    a.go();\n    }\n    public void go(){\n           DSRoss ds1 = new DSRoss(&quot;one&quot;);\n           ds1.start();\n} }\nclass DSRoss extends Thread{\nprivate String sTname=&quot;&quot;;\nDSRoss(String s){\n    sTname = s;\n}\npublic void run(){\n    notwait();\n    System.out.println(&quot;finished&quot;);\n   }\npublic void notwait(){\n    while(true){\n           try{\nSystem.out.println(&quot;waiting&quot;);\nwait();\n}catch(InterruptedException ie){}\n    System.out.println(sTname);\n           notifyAll();\n} }\n</code></pre><p>1) It will cause a compile time error</p>\n<p>2) Compilation and output of “waiting”</p>\n<p>3) Compilation and output of “waiting” followed by “finished”</p>\n<p>4) Runtime error, an exception will be thrown</p>\n<hr>\n<p>Question 23)</p>\n<p>Which of the following methods can be legally inserted in place of the comment //Method Here ?</p>\n<pre><code>class Base{\n public void amethod(int i) { }\n}\npublic class Scope extends Base{\n public static void main(String argv[]){\n }\n //Method Here\n}\n</code></pre><p>1) void amethod(int i) throws Exception {}</p>\n<p>2) void amethod(long i)throws Exception {}</p>\n<p>3) void amethod(long i){}</p>\n<p>4) public void amethod(int i) throws Exception {}</p>\n<hr>\n<p>Question 24)</p>\n<p>Which of the following will output -4.0</p>\n<p>1) System.out.println(Math.floor(-4.7));</p>\n<p>2) System.out.println(Math.round(-4.7));<br>}</p>\n<p>3) System.out.println(Math.ceil(-4.7));</p>\n<p>4) System.out.println(Math.min(-4.7));</p>\n<hr>\n<p>Question 25)</p>\n<p>What will happen if you attempt to compile and run the following code?</p>\n<pre><code>Integer ten=new Integer(10);\nLong nine=new Long (9);\nSystem.out.println(ten + nine);\nint i=1;\nSystem.out.println(i + ten);\n</code></pre><p>1) 19 followed by 20</p>\n<p>2) 19 followed by 11</p>\n<p>3) Compile time error</p>\n<p>4) 10 followed by 1</p>\n<hr>\n<p>Question 26)</p>\n<p>If you run the code below, what gets printed out?</p>\n<pre><code>String s=new String(&quot;Bicycle&quot;);\nint iBegin=1;\nchar iEnd=3;\nSystem.out.println(s.substring(iBegin,iEnd));\n</code></pre><p>1) Bic</p>\n<p>2) ic</p>\n<p>3) icy</p>\n<p>4) error: no method matching substring(int,char)</p>\n<hr>\n<p>Question 27)</p>\n<p>If you wanted to find out where the position of the letter v (ie return 2) in the string s containing “Java”, which of the following could you use?</p>\n<p>1) mid(2,s);</p>\n<p>2) charAt(2);</p>\n<p>3) s.indexOf(‘v’);</p>\n<p>4) indexOf(s,’v’);</p>\n<hr>\n<p>Question 28)<br>Given the following declarations</p>\n<pre><code>String s1=new String(&quot;Hello&quot;)\nString s2=new String(&quot;there&quot;);\nString s3=new String();\n</code></pre><p>Which of the following are legal operations?</p>\n<p>1) s3=s1 + s2;</p>\n<p>2) s3=s1-s2;</p>\n<p>3) s3=s1 &amp; s2;</p>\n<p>4) s3=s1 &amp;&amp; s2</p>\n<hr>\n<p>Question 29)</p>\n<p>What is the result of the following operation?</p>\n<pre><code>System.out.println(4 | 3);\n</code></pre><p>1) 6</p>\n<p>2) 0</p>\n<p>3) 1</p>\n<p>4) 7</p>\n<hr>\n<p>Question 30)</p>\n<pre><code>public class MyClass1 {\npublic static void main(String argv[]){ }\n/*Modifier at XX */ class MyInner {}\n}\n</code></pre><p>What modifiers would be legal at XX in the above code?</p>\n<p>1) public</p>\n<p>2) private</p>\n<p>3) static</p>\n<p>4) friend</p>\n<hr>\n<p>Question 31)</p>\n<p>What will happen when you attempt to compile and run the following code?</p>\n<pre><code>public class Holt extends Thread{\n    private String sThreadName;\n    public static void main(String argv[]){\n            Holt h = new Holt();\nh.go(); }\nHolt(){}\nHolt(String s){\n    sThreadName = s;\n}\npublic String getThreadName(){\n    return sThreadName;\n}\npublic void go(){\n    Holt first = new Holt(&quot;first&quot;);\n   }\nfirst.start();\nHolt second = new Holt(&quot;second&quot;);\nsecond.start();\npublic void start(){\n    for(int i = 0; i &lt; 2; i ++){\n}\n} }\ntry{\n    System.out.println(getThreadName() +i);\n    Thread.sleep(100);\n                    } catch(InterruptedException\n    e){System.out.println(e.getMessage());}\n</code></pre><p>1) Compile time error</p>\n<p>2) Output of first0, second0, first0, second1</p>\n<p>3) Output of first0, first1, second0, second1</p>\n<p>4) Runtime error</p>\n<hr>\n<p>Question 32)</p>\n<p>An Applet has its Layout Manager set to the default of FlowLayout. What code would be correct to change to another Layout Manager.</p>\n<p>1) setLayoutManager(new GridLayout());</p>\n<p>2) setLayout(new GridLayout(2,2));</p>\n<p>3) setGridLayout(2,2);</p>\n<p>4) setBorderLayout();</p>\n<hr>\n<p>Question 33)</p>\n<p>What will happen when you attempt to compile and run the following code?.</p>\n<pre><code>class Background implements Runnable{\n    int i=0;\n           public int run(){\n                    while(true){\n                              return 1;\n     }//End run\n}//End class\ni++;\nSystem.out.println(&quot;i=&quot;+i);\n} //End while\n</code></pre><p>1) It will compile and the run method will print out the increasing value of i.</p>\n<p>2) It will compile and calling start will print out the increasing value of i.</p>\n<p>3) The code will cause an error at compile time.</p>\n<p>4) Compilation will cause an error because while cannot take a parameter of true.</p>\n<hr>\n<p>Question 34)</p>\n<p>Which of the following statements about this code are true?</p>\n<pre><code>public class Morecombe{\npublic static void main(String argv[]){\n    Morecombe m = new Morecombe();\n    m.go(new Turing(){});\n}\npublic void go(Turing t){\nt.start(); \n}\n}\nclass Turing extends Thread{\n    public void run(){\n           for(int i =0; i &lt; 2; i++){\n                   System.out.println(i);\n} }\n</code></pre><p>1) Compilation error due to malformed parameter to go method</p>\n<p>2) Compilation error, class Turing has no start method</p>\n<p>3) Compilation and output of 0 followed by 1</p>\n<p>4) Compilation but runtime error</p>\n<hr>\n<p>Question 35)</p>\n<p>What will be the result when you attempt to compile and run the following code?.</p>\n<pre><code>public class Conv{\npublic static void main(String argv[]){\n    Conv c=new Conv();\n    String s=new String(&quot;ello&quot;);\n}\n  c.amethod(s);\n}\npublic void amethod(String s){\n    char c=&apos;H&apos;;\n     c+=s;\n    System.out.println(c);\n    }\n}\n</code></pre><p>1) Compilation and output the string “Hello”</p>\n<p>2) Compilation and output the string “ello”</p>\n<p>3) Compilation and output the string elloH</p>\n<p>4) Compile time error</p>\n<hr>\n<p>Question 36)</p>\n<p>Given the following code, what test would you need to put in place of the comment line?</p>\n<pre><code>//place test here\nto result in an output of the string\nEqual\npublic class EqTest{\n     public static void main(String argv[]){\n            EqTest e=new EqTest();\n}\n    EqTest(){\n            String s=&quot;Java&quot;;\n            String s2=&quot;java&quot;;\n            //place test here {\n   }\n} }\nSystem.out.println(&quot;Equal&quot;);\n}else\n{\nSystem.out.println(&quot;Not equal&quot;);\n</code></pre><p>1) if(s==s2)</p>\n<p>2) if(s.equals(s2)</p>\n<p>3) if(s.equalsIgnoreCase(s2))</p>\n<p>4)if(s.noCaseMatch(s2))</p>\n<hr>\n<p>Question 37)</p>\n<p>Given the following code</p>\n<pre><code>import java.awt.*;\npublic class SetF extends Frame{\npublic static void main(String argv[]){\n     SetF s=new SetF();\n     s.setSize(300,200);\n     s.setVisible(true);\n }\n}\n</code></pre><p>How could you set the frame surface color to pink</p>\n<p>1)s.setBackground(Color.pink);</p>\n<p>2)s.setColor(PINK);</p>\n<p>3)s.Background(pink);</p>\n<p>4)s.color=Color.pink</p>\n<hr>\n<p>Question 38)</p>\n<p>How can you change the current working directory using an instance of the File class called FileName?</p>\n<p>1) FileName.chdir(“DirName”)</p>\n<p>2) FileName.cd(“DirName”)</p>\n<p>3) FileName.cwd(“DirName”)</p>\n<p>4) The File class does not support directly changing the current<br>directory.</p>\n<hr>\n<p>Question 39)</p>\n<p>If you create a TextField with a constructor to set it to occupy 5 columns, what difference will it make if you use it with a proportional font (ie Times Roman) or a fixed pitch typewriter style font (Courier).</p>\n<p>1)With a fixed font you will see 5 characters, with a proportional it will depend on the width of the characters</p>\n<p>2)With a fixed font you will see 5 characters,with a proportional it will cause the field to expand to fit the text</p>\n<p>3)The columns setting does not affect the number of characters displayed 4)Both will show exactly 5 characters</p>\n<hr>\n<p>Question 40)<br>Given the following code how could you invoke the Base constructor that will print out the string “base constructor”;</p>\n<pre><code>class Base{\n    Base(int i){\n    System.out.println(&quot;base constructor&quot;);\n    }\nBase(){\n    } }\npublic class Sup extends Base{\n    public static void main(String argv[]){\n    Sup s= new Sup();\n    //One }\n    Sup() {\n    //Two }\npublic void derived()\n{\n//Three }\n}\n</code></pre><p>1) On the line After //One put Base(10);</p>\n<p>2) On the line After //One put super(10);</p>\n<p>3) On the line After //Two put super(10);</p>\n<p>4) On the line After //Three put super(10);</p>\n<hr>\n<p>Question 41)</p>\n<p>Given the following code what will be output?</p>\n<pre><code>public class Pass{\nstatic int j=20;\npublic static void main(String argv[]){\n    int i=10;\n    Pass p = new Pass();\n    p.amethod(i);\n    System.out.println(i);\n    System.out.println(j);\n    }\npublic void amethod(int x){\n    x=x*2;\n        j=j*2; \n}\n}\n</code></pre><p>1) Error: amethod parameter does not match variable</p>\n<p>2) 20 and 40</p>\n<p>3) 10 and 40</p>\n<p>4) 10, and 20</p>\n<hr>\n<p>Question 42)</p>\n<p>What code placed after the comment //For loop would result in the population of every element of the array ia[] with a value from variable i.?</p>\n<pre><code>public class Lin{\npublic static void main(String argv[]){\n    Lin l = new Lin();\n    l.amethod();\n}\npublic void amethod(){\n\n    int ia[] = new int[4];\n    //Start For loop\n    {\n            ia[i]=i;\n            System.out.println(ia[i]);\n    }\n} }\n</code></pre><p>1) for(int i=0; i &lt; ia.length() -1; i++)</p>\n<p>2) for (int i=0; i&lt; ia.length(); i++)</p>\n<p>3) for(int i=1; i &lt; 4; i++)</p>\n<p>4) for(int i=0; i&lt; ia.length;i++)</p>\n<hr>\n<p>Question 43)</p>\n<p>What will be the result when you try to compile and run the following code?</p>\n<pre><code>private class Base{\n        Base(){\n        int i = 100;\n        System.out.println(i);\n        }\n}\npublic class Pri extends Base{\n    static int i = 200;\n        public static void main(String argv[]){\n    Pri p = new Pri();\n    System.out.println(i);\n    }\n}\n</code></pre><p>1) Error at compile time</p>\n<p>2) 200</p>\n<p>3) 100 followed by 200</p>\n<p>4) 100</p>\n<hr>\n<p>Question 44)</p>\n<p>What will the following code print out?</p>\n<pre><code>public class Oct{\n    public static void main(String argv[]){\n    Oct o = new Oct();\n    o.amethod();\n        }\n    public void amethod(){\n    int oi= 012;\n    System.out.println(oi);\n    }\n}\n</code></pre><p>1)12</p>\n<p>2)012</p>\n<p>3)10</p>\n<p>4)10.0</p>\n<hr>\n<p>Question 45</p>\n<p>What will happen when you try compiling and running this code?</p>\n<pre><code>public class Ref{\npublic static void main(String argv[]){\n    Ref r = new Ref();\n    r.amethod(r);\n}\npublic void amethod(Ref r){\n    int i=99;\n      multi(r);\n    System.out.println(i);\n}\npublic void multi(Ref r){\n    r.i = r.i*2;\n} }\n</code></pre><p>1) Error at compile time</p>\n<p>2) An output of 99</p>\n<p>3) An output of 198</p>\n<p>4) An error at runtime</p>\n<hr>\n<p>Question 46)</p>\n<p>You need to create a class that will store unique object elements. You do not need to sort these elements but they must be unique.<br>What interface might be most suitable to meet this need?</p>\n<p>1)Set</p>\n<p>2)List</p>\n<p>3)Map</p>\n<p>4)Vector</p>\n<hr>\n<p>Question 47)</p>\n<p>Which of the following will successfully create an instance of the Vector class and add an element?</p>\n<p>1) Vector v=new Vector(99);<br>v[1]=99;</p>\n<p>2) Vector v=new Vector();<br>v.addElement(99);</p>\n<p>3) Vector v=new Vector();<br>v.add(99);</p>\n<p>4 Vector v=new Vector(100);<br>v.addElement(“99”);</p>\n<hr>\n<p>Question 48)<br>You have created a simple Frame and overridden the paint method as follows</p>\n<pre><code>public void paint(Graphics g){\n    g.drawString(&quot;Dolly&quot;,50,10);\n}\n</code></pre><p>What will be the result when you attempt to compile and run the program?</p>\n<p>1) The string “Dolly” will be displayed at the centre of the frame</p>\n<p>2) An error at compilation complaining at the signature of the paint method </p>\n<p>3) The lower part of the word Dolly will be seen at the top of the frame, with the top hidden.</p>\n<p>4) The string “Dolly” will be shown at the bottom of the frame.</p>\n<hr>\n<p>Question 49)</p>\n<p>What will be the result when you attempt to compile this program?</p>\n<pre><code>public class Rand{\npublic static void main(String argv[]){\n    int iRand;\n    iRand = Math.random();\n    System.out.println(iRand);\n} }\n</code></pre><p>1) Compile time error referring to a cast problem</p>\n<p>2) A random number between 1 and 10</p>\n<p>3) A random number between 0 and 1</p>\n<p>4) A compile time error about random being an unrecognised method</p>\n<hr>\n<p>Question 50)</p>\n<p>Given the following code</p>\n<pre><code>import java.io.*;\npublic class Th{\npublic static void main(String argv[]){\n    Th t = new Th();\n    t.amethod();\n}\npublic void amethod(){\n    try{\n        ioCall();\n    }catch(IOException ioe){}\n\n} }\n</code></pre><p>What code would be most likely for the body of the ioCall method</p>\n<p>1) </p>\n<pre><code>public void ioCall ()throws IOException{\n DataInputStream din = new DataInputStream(System.in);\n din.readChar();\n }\n</code></pre><p>2) </p>\n<pre><code>public void ioCall ()throw IOException{\n     DataInputStream din = new DataInputStream(System.in);\n    din.readChar();\n }\n</code></pre><p>3) </p>\n<pre><code>public void ioCall (){\n     DataInputStream din = new DataInputStream(System.in);\n     din.readChar();\n }\n</code></pre><p>4) </p>\n<pre><code>public void ioCall throws IOException(){\n         DataInputStream din = new DataInputStream(System.in);\n             din.readChar();\n    }\n</code></pre><hr>\n<p>Question 51)<br>What will happen when you compile and run the following code?<br>public class Scope{<br>    private int i;<br>    public static void main(String argv[]){<br>        Scope s = new Scope();<br>        s.amethod();<br>    }//End of main<br>    public static void amethod(){<br>        System.out.println(i);<br>    }//end of amethod<br>}//End of class<br>1) A value of 0 will be printed out<br>2) Nothing will be printed out<br>3) A compile time error<br>4) A compile time error complaining of the scope of the variable i</p>\n<hr>\n<p>Question 52)</p>\n<p>You want to lay out a set of buttons horizontally but with more space between the first button and the rest. You are going to use the GridBagLayout manager to control the way the buttons are set out. How will you modify the way the GridBagLayout acts in order to change the spacing around the first button?</p>\n<p>1) Create an instance of the GridBagConstraints class, call the weightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<p>2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<p>3) Create an instance of the GridBagLayout class, set the weightx field and then call the setConstraints method of the GridBagLayoutClass with the component as a parameter.</p>\n<p>4) Create an instance of the GridBagLayout class, call the setWeightx() method and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.</p>\n<hr>\n<p>Question 53)</p>\n<p>Which of the following can you perform using the File class?</p>\n<p>1) Change the current directory</p>\n<p>2) Return the name of the parent directory</p>\n<p>3) Delete a file</p>\n<p>4) Find if a file contains text or binary information</p>\n<hr>\n<p>Question 54)</p>\n<p>Which statement is true of the following code?</p>\n<pre><code>public class Rpcraven{\n    public static void main(String argv[]){\n\n    Pmcraven pm1 = new Pmcraven(&quot;One&quot;);\n    pm1.run();\n    Pmcraven pm2 = new Pmcraven(&quot;Two&quot;);\n    pm2.run();\n} }\nclass Pmcraven extends Thread{\n    private String sTname=&quot;&quot;;\n    Pmcraven(String s){\n    sTname = s;\n}\npublic void run(){\n    for(int i =0; i &lt; 2 ; i++){\n           try{\n} }\n sleep(1000);\n}catch(InterruptedException e){}\nyield();\nSystem.out.println(sTname);\n}\n</code></pre><p>1) Compile time error, class Rpcraven does not import java.lang.Thread </p>\n<p>2) Output of One One Two Two</p>\n<p>3) Output of One Two One Two</p>\n<p>4) Compilation but no output at runtime</p>\n<hr>\n<p>Question 55)</p>\n<p>You are concerned that your program may attempt to use more memory than is available. To avoid this situation you want to ensure that the Java Virtual Machine will run its garbage collection just before you start a complex routine. What can you do to be certain that garbage collection will run when you want .</p>\n<p>1) You cannot be certain when garbage collection will run</p>\n<p>2) Use the Runtime.gc() method to force garbage collection</p>\n<p>3) Ensure that all the variables you require to be garbage collected are set to null</p>\n<p>4) Use the System.gc() method to force garbage collection</p>\n<hr>\n<p>Question 56)<br>You are using the GridBagLayout manager to place a series of buttons on a Frame. You want to make the size of one of the buttons bigger than the text it contains. Which of the following will allow you to do that?</p>\n<p>1) The GridBagLayout manager does not allow you to do this</p>\n<p>2) The setFill method of the GridBagLayout class</p>\n<p>3) The setFill method of the GridBagConstraints class</p>\n<p>4) The fill field of the GridBagConstraints class</p>\n<hr>\n<p>Question 57)</p>\n<p>Which of the following most closely describes a bitset collection?</p>\n<p>1) A class that contains groups of unique sequences of bits</p>\n<p>2) A method for flipping individual bits in instance of a primitive type </p>\n<p>3) An array of boolean primitives that indicate zeros or ones</p>\n<p>4) A collection for storing bits as on-off information, like a vector of bits</p>\n<hr>\n<p>Question 58)</p>\n<p>You have these files in the same directory. What will happen when you attempt to compile and run Class1.java if you have not already compiled Base.java</p>\n<pre><code>//Base.java\npackage Base;\nclass Base{\nprotected void amethod(){\n    System.out.println(&quot;amethod&quot;);\n}//End of amethod\n}//End of class base\n\npackage Class1;\n//Class1.java\npublic class Class1 extends Base{\npublic static void main(String argv[]){\n    Base b = new Base();\n    b.amethod();\n}//End of main\n}//End of Class1\n</code></pre><p>1) Compile Error: Methods in Base not found</p>\n<p>2) Compile Error: Unable to access protected method in base class</p>\n<p>3) Compilation followed by the output “amethod”</p>\n<p>4)Compile error: Superclass Class1.Base of class Class1.Class1 not found</p>\n<hr>\n<p>Question 59)<br>What will happen when you attempt to compile and run the following code<br>    class Base{<br>    private void amethod(int iBase){<br>        System.out.println(“Base.amethod”);<br>    }<br>    }<br>    class Over extends Base{<br>    public static void main(String argv[]){<br>        Over o = new Over();<br>        int iBase=0;<br>        o.amethod(iBase);<br>    }<br>    public void amethod(int iOver){<br>        System.out.println(“Over.amethod”);<br>    } }</p>\n<p>1) Compile time error complaining that Base.amethod is private</p>\n<p>2) Runtime error complaining that Base.amethod is private</p>\n<p>3) Output of “Base.amethod”</p>\n<p>4) Output of “Over.amethod”</p>\n<hr>\n<p>Question 60)</p>\n<p>You are creating an applet with a Frame that contains buttons. You are using the GridBagLayout manager and you have added Four buttons. At the moment the buttons appear in the centre of the frame from left to right. You want them to appear one on top of the other going down the screen. What is the most appropriate way to do this.</p>\n<p>1) Set the gridy value of the GridBagConstraints class to a value<br>increasing from 1 to 4</p>\n<p>2) set the fill value of the GridBagConstraints class to VERTICAL</p>\n<p>3) Set the ipady value of the GridBagConstraints class to a value<br>increasing from 0 to 4</p>\n<p>4) Set the fill value of the GridBagLayouts class to GridBag.VERTICAL<br>   Answer 1) Back to question 1) Objective 4.5)<br>5) int i=10;</p>\n<h2 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h2><p>explanation:</p>\n<p>1) float f=1.3;</p>\n<p>Will not compile because the default type of a number with a floating point component is a double. This would compile with a cast as in<br>float f=(float) 1.3</p>\n<p>2) char c=”a”;</p>\n<p>Will not compile because a char (16 bit unsigned integer) must be defined with single quotes. This would compile if it were in the form<br>char c=’a’;</p>\n<p>3) byte b=257;</p>\n<p>Will not compile because a byte is eight bits. Take of one bit for the sign component you can define numbers between<br>-128 to +127</p>\n<p>4) a boolean value can either be true or false, null is not allowed</p>\n<p>Answer 2)<br>Back to question 2)<br>Objective 4.1<br>1) Can’t make static reference to void amethod.<br>Because main is defined as static you need to create an instance of the class in order to call any non-static methods. Thus a typical way to do this would be.<br>MyClass m=new MyClass(); m.amethod();<br>Answer 2 is an attempt to confuse because the convention is for a main method to be in the form String argv[]<br>That argv is just a convention and any acceptable identifier for a string array can be used. </p>\n<p>Answers3 and 4 are just nonsense.<br> Answer 3)</p>\n<p>back to Question 3) Objective 4.1)<br>2 and 3 will compile without error.<br>1 will not compile because any package declaration must come before any other code. Comments may appear anywhere. </p>\n<p>Answer 4)<br>Back to question 4) Objective 4.5)<br>1) A byte is a signed 8 bit integer.<br> Answer 5)<br>Back to question 5) Objective 4.2)<br>4) Exception raised: “java.lang.ArrayIndexOutOfBoundsException: 2”<br>Unlike C/C++ java does not start the parameter count with the program name. It does however start from zero. So in this case zero starts with good, morning would be 1 and there is no parameter 2 so an exception is raised.</p>\n<p>Answer 6)<br>Back to question 6) Objective 4.3)<br>1) if<br>3) goto 4) while<br>5) case<br>then is not a Java keyword, though if you are from a VB background you might think it was. Goto is a reserved word in Java.</p>\n<p>Answer 7)<br>Back to Question 7)<br>Objective 4.1)<br>2) variable2<br>3) _whatavariable 4) _3_<br>5) $anothervar</p>\n<p>An identifier can begin with a letter (most common) or a dollar sign($) or an underscore(_). An identifier cannot start with anything else such as a number, a hash, # or a dash -. An identifier cannot have a dash in its body, but it may have an underscore _. Choice 4) _3_ looks strange but it is an acceptable, if unwise form for an identifier.</p>\n<p> Answer 8)</p>\n<p>Back to Question 8) Objective 4.4)<br>4) 0<br>Class level variables are always initialised to default values. In the case of an int this will be 0. Method level variables are not given default values and if you attempt to use one before it has been initialised it will cause the<br>Error Variable i may not have been initialized type of error.</p>\n<p> Answer 9)<br>Back to Question 9) Objective 4.4)<br>3)2<br>No error will be triggered.<br>Like in C/C++, arrays are always referenced from 0. Java allows an array to be populated at creation time. The size of array is taken from the number of initializers. If you put a size within any of the square brackets you will get an error.</p>\n<p> Answer 10)<br>Back to question 10) Objective 4.4)<br>3) 0<br>Arrays are always initialised when they are created. As this is an array of ints it will be initalised with zeros.</p>\n<p> Answer 11)<br>Back to Question 11) Objective 1.2<br>3) Error Mine must be declared abstract<br>A class that contains an abstract method must itself be declared as abstract. It may however contain non abstract methods. Any class derived from an abstract class must either define all of the abstract methods or be declared abstract itself.</p>\n<p> Answer 12)</p>\n<p>Back to Question 12) Objective 2.1)<br>3) one, two, default<br>Code will continue to fall through a case statement until it encounters a break.</p>\n<p> Answer 13)</p>\n<p>Back to Question 13) Objective 4.1)<br>2) default, zero<br>Although it is normally placed last the default statement does not have to be the last item as you fall through the case block. Because there is no case label found matching the expression the default label is executed and the code continues to fall through until it encounters a break.</p>\n<p> Answer 14)</p>\n<p>Back to Question 14) Objective 5.1<br>2,3<br>Example 1 will not compile because if must always test a boolean. This can catch out C/C++ programmers who expect the test to be for either 0 or not 0.</p>\n<p> Answer 15)</p>\n<p>Back to Question 15) Objective 11.5)<br>3) No such file found, doing finally, -1<br>The no such file found message is to be expected, however you can get caught out if you are not aware that the finally clause is almost always executed, even if there is a return statement.</p>\n<p>Answer 16)</p>\n<p>Back to Question 16) Objective 6.2)<br>1) Methods cannot be overriden to be more private<br>Static methods cannot be overriden but they can be overloaded. If you have doubts about that statement, please follow and read carefully the link given to the Sun tutorial below. There is no logic or reason why private methods should not be overloaded. Option 4 is a jumbled up version of the limitations of exceptions for overriden methods</p>\n<p>Answer 17)</p>\n<p>Back to Question 17) Objective 6.2)<br>3) Runtime Exception<br>Without the cast to sub you would get a compile time error. The cast tells the compiler that you really mean to do this and the actual type of b does not get resolved until runtime. Casting down the object hierarchy is a problem, as the compiler cannot be sure what has been implemented in descendent classes. Casting up is not a problem because sub classes will have the features of the base classes. This can feel counter intuitive if you are aware that with primitives casting is allowed for widening operations (ie byte to int).</p>\n<p>Answer 18)</p>\n<p>Back to question 18) Objective 5.1)<br>1) System.out.println( -1 &gt;&gt;&gt; 2);will output a result larger than 10 2) System.out.println( -1 &gt;&gt;&gt; 2); will output a positive number<br>3) System.out.println( 2 &gt;&gt; 1); will output the number 1<br>You can test this with the following class<br>public class shift{<br>static int i=2;<br>public static void main(String argv[]){<br>System.out.println( -1 System.out.println( -1 System.out.println( 2 }<br>>>> 2);<br>>>> 2); >> 1);<br>}<br>Java does not have a \\&lt;\\&lt;\\&lt; operator. The operation 1 \\&lt;\\&lt; 2 would output 4<br>Because of the way twos complement number representation works the unsigned right shift operation means a small shift in a negative number can return a very large value so the output of<br>option 1 will be much larger than 10.<br>The unsigned right shift places no significance on the leading bit that indicates the sign. For this shift the value 1 of the bit sign is replaced with a zero turning the result into a positive number for option 2.</p>\n<p> Answer 19)</p>\n<p>Back to Question 19) Objective 7.1)<br>4) Compilation and output of either “vandaleur”, “vandaleur 0”, “vandaleur 0 1” “vandaleur 0 1 2” or “vandaleur 0 1 2 3”<br>If that seems a vauge answer it is because you cannot be certain of the system that the underlying OS uses for allocating cycles for a Thread. The chances are that once the thread has been spun off in the call to start in the method piggy the main method will run to completion and the value of sName will still be vandeluer before the Thread modifies it. You cannot be certain of this though.</p>\n<p> Answer 20)</p>\n<p>Back to Question 20) Objective 8.1)<br>3) One button occupying the entire frame saying Bye<br>The default layout manager for a Frame is a border layout. If directions are not given (ie North, South, East or West), any button will simply go in the centre and occupy all the space. An additional button will simply be placed over the previous button. What you would probably want in a real example is to set up a flow layout as in<br>setLayout(new FlowLayout());<br>Which would allow the buttons to both appear side by side, given the appropriate font and size. Applets and panels have a default FlowLayout manager</p>\n<p> Answer 21)</p>\n<p>Back to Question 21) Objective 2.2)<br>1,2<br>Value for i=1 Value for j=1 Value for i=2 Value for j=1<br>The statement continue outer causes the code to jump to the label outer and the for loop increments to the next number.</p>\n<p> Answer 22)</p>\n<p>Back to Question 22)<br>Objective 7.3)<br>4) Runtime error, an exception will be thrown<br>A call to wait/notify must be within synchronized code. With JDK1.2 this code throws the error message<br>java.lang.IllegalMonitorStateException: currentthreadnotowner at java.lang.Object.wait(Native Method)<br>at java.lang.Object.wait(Object.java:424) at DSRoss.notwait(Compiled Code)<br>at DSRoss.run(Agg.java:21)</p>\n<p> Answer 23)</p>\n<p>Back to Question 23) Objective 2.3)<br>2,3<br>Options 1, &amp; 4 will not compile as they attempt to throw Exceptions not declared in the base class. Because options 2 and 3 take a parameter of type long they represent overloading not overriding and there is no such limitations on overloaded methods.</p>\n<p> Answer 24)</p>\n<p>Back to Question 24) Objective 9.1)<br>3) System.out.println(Math.ceil(-4.7));<br>Options 1 and 2 will produce -5 and option 4 will not compile because the min method requires 2 parameters.</p>\n<p> Answer 25)</p>\n<p>Back to Question 25 Objective 4.5)<br>3) Compile time error<br>The wrapper classes cannot be used like primitives.<br>Depending on your compiler you will get an error that says someting like “Error: Can’t convert java lang Integer”. Wrapper classes have similar names to primitives but all start with upper case letters.<br>Thus in this case we have int as a primitive and Integer as a wrapper. The objectives do not specifically mention the wrapper classes but don’t be surprised if they come up.</p>\n<p> Answer 26)</p>\n<p>Back to Question 26) Objective 4.5)<br>2) ic<br>This is a bit of a catch question. Anyone with a C/C++ background would figure out that addressing in strings starts with 0 so that 1 corresponds to i in the string Bicycle. The catch is that the second parameter returns the endcharacter minus 1. In this case it means instead of the “icy” being returned as intuition would expect it is only “ic”.</p>\n<p> Answer 27)</p>\n<p>Back to Question 27) Objective 9.2)<br>3) s.indexOf(‘v’);<br>charAt returns the letter at the position rather than searching for a letter and returning the position, MID is just to confuse the Basic Programmers, indexOf(s,’v’); is how some future VB/J++ nightmare hybrid, might perform such a calculation.</p>\n<p> Answer 28)</p>\n<p>Objective 5.1)<br>Back to Question 28<br>1) s3=s1 + s2;<br>Java does not allow operator overloading as in C++, but for the sake of convenience the + operator is overridden for strings.</p>\n<p>Answer 29)</p>\n<p>Back to Question 29) Objective 5.3)<br>4) 7<br>The | is known as the Or operator, you could think of it as the either/or operator. Turning the numbers into binary gives<br>4=100 3=011<br>For each position, if either number contains a 1 the result will contain a result in that position. As every position contains a 1 the result will be<br>111<br>Which is decimal 7.</p>\n<p> Answer 30)</p>\n<p>Back to Question 30 Objective 4.1)<br>1,2,3<br>public, private, static are all legal access modifiers for this inner class.</p>\n<p> Answer 31)</p>\n<p>Back to Question 31 Objective 7.1<br>3) Output of first0, first1, second0, second1<br>Note that this code overrides and calls the start method. If you wished to get the output mixed you would need to override the run method but call the start method.</p>\n<p> Answer 32)</p>\n<p>Back to Question 32) Objective 8.1)<br>2) setLayout(new GridLayout(2,2));<br>Changing the layout manager is the same for an Applet or an application. Answer 1 is wrong though it might have been a reasonable name for the designers to choose. Answers 3 and 4 are incorrect because changing the layout manager always requires an instance of one of the Layout Managers and these are bogus methods.<br>Instead of creating the anonymous instance of the Layout manager as in option 2 you can also create a named instance and pass that as a parameter. This is often what automatic code generators such as Borland/Inprise JBuilder do.</p>\n<p> Answer 33)</p>\n<p>Back to Question 33) Objective 7.1)<br>3) The code will cause an error at compile time<br>The error is caused because run should have a void not an int return type.<br>Any class that is implements an interface must create a method to match all of the methods in the interface. The Runnable interface has one method called run that has a void return type.The sun<br>compiler gives the error<br>Method redefined with different return type: int run() was defined as void run();</p>\n<p> Answer 34)</p>\n<p>Back to Question 34) Objective 7.1)<br>3) Compilation and output of 0 followed by 1<br>The creation of an anonymous class as a parameter to go is fairly strange as you would expect it to override a method in its parent class (Turing). You don’t have to though. The fact that class Turing extends Thread means the anonymous instance that is passed to go has a start method which then calls the run method.</p>\n<p> Answer 35)</p>\n<p>Back to Question 35 Objective 5.1)<br>4) Compile time error<br>The only operator overloading offered by java is the + sign for the String class. Achar is a 16 bit integer and cannot be concatenated to a string with the + operator.</p>\n<p> Answer 36)</p>\n<p>Back to Question 36 Objective 5.2)<br>3) if(s.equalsIgnoreCase(s2))<br>String comparison is case sensitive so using the equals string method will not return a match. Using the==operator just compares where memory address of the references and noCaseMatch was just something I made up to give me a fourth slightly plausible option.</p>\n<p> Answer 37)</p>\n<p>Back to Question 37 Objective 8.1)<br>1) s.setBackground(Color.pink);<br>For speakers of the more British spelt English note that there is no letter u in Color. Also the constants for colors are in lower case.</p>\n<p> Answer 38)</p>\n<p>Back to Question 38) Objective 11.1)<br>4) The File class does not support directly changing the current directory.<br>This seems rather surprising to me, as changing the current directory is a very common requirement. You may be able to get around this limitation by creating a new instance of the File class passing the new directory to the constructor as the path name.</p>\n<p> Answer 39)</p>\n<p>Back to Question 39) Objective 8.1)<br>1)With a fixed font you will see 5 characters, with a the characters<br>proportional it will depend on the width of<br>With a proportional font the letter w will occupy more space than the letter i. So if you have all wide characters you may have to scroll to the right to see the entire text of a TextField.</p>\n<p>Answer 40)</p>\n<p>Back to Question 40) Objective 6.2<br>3) On the line After //Two put super(10);<br>Constructors can only be invoked from within constructors. </p>\n<p>Answer 41)</p>\n<p>Back to Question 41) Objective 5.4)<br>3) 10 and 40<br>when a parameter is passed to a method the method receives a copy of the value. The method can modify its value without affecting the original copy. Thus in this example when the value is printed out the method has not changed the value.</p>\n<p>Answer 42)</p>\n<p>Back to Question 42 Objective 1.1<br>4) for(int i=0; i&lt; ia.length;i++)<br>Although you could control the looping with a literal number as with the number 4 used in option 3, it is better practice to use the length property of an array. This provides against bugs that might result if the size of the array changes. This question also checks that you know that arrays starts from zero and not One as option 3 starts from one. Remember that array length is a field and not a function like the String length() method.</p>\n<p>Answer 43)<br>Back to Question 43) Objective 1.2<br>1) Error at compile time<br>This is a slightly sneaky one as it looks like a question about constructors, but it is attempting to test knowledge of the use of the private modifier. A top level class cannot be defined as private. If you didn’t notice the modifier private, remember in the exam to be real careful to read every part of the question.</p>\n<p>Answer 44)</p>\n<p>Back to Question 44 Objective 4.5)<br>3)10<br>The name of the class might give you a clue with this question, Oct for Octal. Prefixing a number with a zero indicates that it is in Octal format. Thus when printed out it gets converted to base ten. 012 in octal means the first column from the right has a value of 2 and the next along has a value of one times eight. In decimal that adds up to 10.</p>\n<p> Answer 45)</p>\n<p>Back to Question 45 Objective 1.2)<br>1) Error at compile time<br>The variable i is created at the level of amethod and will not be available inside the method multi.</p>\n<p>Answer 46)</p>\n<p>Back to Question 46 Objective 10.1)<br>1) Set<br>The Set interface ensures that its elements are unique, but does not order the elements. In reality you probably wouldn’t create your own class using the Set interface. You would be more likely to use one of the JDK classes that use the Set interface such as HashSet or TreeSet.</p>\n<p> Answer 47)</p>\n<p>Back to Question 47 Objective 10.1)<br>4) Vector v=new Vector(100); v.addElement(“99”)<br>A vector can only store objects not primitives. The parameter “99” for the addElement method pases a string object to the Vector. Option 1) creates a vector OK but then uses array syntax to attempt to assign a primitive. Option 2 also creates a vector then uses correct Vector syntax but falls over when the parameter is a primitive instead of an object.<br>Answer 48)</p>\n<p>Objective 8.1)<br>Back to Question 48<br>3) The lower part of the word Dolly will be seen at the top of the form<br>The Second parameter to the drawstring method indicates where the baseline of the string will be placed. Thus the 3rd parameter of 10 indicates the Y coordinate to be 10 pixels from the top of the Frame. This will result in just the bottom of the string Dolly showing up or possibly only the descending part of the letter y.</p>\n<p>Answer 49)</p>\n<p>Back to Question 49) Objective 9.1)<br>1) Compile time error referring to a cast problem<br>This is a bit of a sneaky one as the Math.random method returns a pseudo random number between 0 and 1, and thus option 3 is a plausible Answer. However the number returned is a double and so the compiler will complain that a cast is needed to convert a double to an int.</p>\n<p> Answer 50)</p>\n<p>Objective 2.3) Back to question 50<br>1) public void ioCall ()throws IOException{ DataInputStream din = new DataInputStream(System.in); din.readChar();<br>}<br>If a method might throw an exception it must either be caught within the method with a try/catch block, or the method must indicate the exception to any calling method by use of the throws statement in its declaration. Without this, an error will occur at compile time.</p>\n<p> Answer 51)</p>\n<p>Objective 1.2)<br>Back to Question 51)<br>3) A compile time error<br>Because only one instance of a static method exists not matter how many instance of the class exists it cannot access any non static variables. The JVM cannot know which instance of the variable to access. Thus you will get an error saying something like<br>Can’t make a static reference to a non static variable </p>\n<p>Answer 52)</p>\n<p>Objective 8.1)<br>Back to Question 52)<br>2) Create an instance of the GridBagConstraints class, set the weightx field and then pass the GridBagConstraints instance with the component to the setConstraints method of the GridBagLayout class.<br>The Key to using the GridBagLayout manager is the GridBagConstraint class. This class is not consistent with the general naming conventions in the java API as you would expect that weightx would be set with a method, whereas it is a simple field (variable).<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error which is corrected in later versions of the book</p>\n<p>Answer 53)</p>\n<p>Objective 11.1)<br>Back to Question 53)<br>2) Return the name of the parent directory 3) Delete a file<br>It is surprising that you can’t change the current directory. It is not so surprising that you can’t tell if a file contains text or binary information.</p>\n<p> Answer 54)</p>\n<p>Back to Question 54) Objective 7.1<br>2) Output of One One Two Two<br>Answer 3 would would be true if the code called the start method instead of the run method (well it is on my Windows machine anyway, I’m not sure it would be for ever implementation of Java Threads). If you call the run method directly it just acts as any other method and does not return to the calling code until it has finished executing.</p>\n<p>Answer 55)</p>\n<p>Objective 3.1)<br>Back to Question 55)<br>1) You cannot be certain when garbage collection will run<br>Although there is a Runtime.gc(), this only suggests that the Java Virtual Machine does its garbage collection. You can never be certain when the garbage collector will run. Roberts and Heller is more specific abou this than Boone. This uncertainty can cause consternation for C++ programmers who wish to run finalize methods with the same intent as they use destructor methods.</p>\n<p>Answer 56)</p>\n<p>Objective 8.1)<br>Back to Question 56)<br>4) The fill field of the GridBagConstraints class<br>Unlike the GridLayout manager you can set the individual size of a control such as a button using the GridBagLayout manager. A little background knowledge would indicate that it should be controlled by a setSomethingOrOther method, but it isn’t.<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at</p>\n<p>Answer 57)</p>\n<p>Objective 10.1)<br>Back to Question 57)<br>4) A collection for storing bits as on-off information, like a vector of bits<br>This is the description given to a bitset in Bruce Eckels “Thinking in Java” book. The reference to unique sequence of bits was an attempt to mislead because of the use of the word Set in the name bitset. Normally something called a set implies uniqueness of the members, but not in this context.</p>\n<p>Answer 58)</p>\n<p>Back to Question 58) Objective 4.1)<br>4)Compile error: Superclass Class1.Base of class Class1.Class1 not found<br>Using the package statement has an effect similar to placing a source file into a different directory. Because the files are in different packages they cannot see each other. The stuff about File1 not having been compiled was just to mislead, java has the equivalent of an “automake”, whereby if it was not for the package statements the other file would have been automatically compiled.</p>\n<p> Answer 59)</p>\n<p>Back to Question 59) Objective 6.2)<br>4) Output of Over.amethod()<br>The names of parameters to an overridden method is not important, but as the version of amethod in class Base is set to be private it is not visible within Over (despite Over extending Base) and thus does not take part in overriding.</p>\n<p>Answer 60)</p>\n<p>Objective 8.1)<br>Back to Question 60)<br>1) Set the gridy value of the GridBagConstraints class to a value increasing from 1 to 4<br>Answer 4 is fairly obviously bogus as it is the GridBagConstraints class that does most of the magic in laying out components under the GridBagLayout manager. The fill value of the GridBagConstraints class controls the behavior inside its virtual cell and the ipady field controls the internal padding around a component.<br>If you have a copy of the Roberts and Heller Java2 Guide that says the exam does not cover the GridBagLayout, this is an error. You can confirm this by looking at the online errata at</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj486x74t00027k26jarbuauu","tag_id":"cj486x74w00047k26tj5724px","_id":"cj486x75200067k26x93prr5h"},{"post_id":"cj486x74v00037k2665ujv2ch","tag_id":"cj486x75200057k26h3m53f3a","_id":"cj486x75400077k26xcw9jkbr"}],"Tag":[{"name":"classloader","_id":"cj486x74w00047k26tj5724px"},{"name":"笔试题","_id":"cj486x75200057k26h3m53f3a"}]}}